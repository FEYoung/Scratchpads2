<?php

function scratchpads_taxonomic_name_field_menu_alter(&$items){
  $items['taxonomy/autocomplete'] = array(
    'title' => 'Autocomplete taxonomy',
    'page callback' => 'scratchpads_taxonomic_name_field_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  
  return $items;
}

/**
 * Implementation of hook_taxonomy_vocabulary_insert().
 */
function scratchpads_taxonomic_name_field_taxonomy_vocabulary_insert($vocabulary){
  if(isset($vocabulary->biological_classification) && $vocabulary->biological_classification){
    // We have a biological classification. We need to update the field.
    field_cache_clear(TRUE);
    $field = field_info_field('field_taxonomic_name');
    $bio_vids = variable_get('biological_vids', array());
    $i = 0;
    $field['settings']['allowed_values'] = array();
    foreach($bio_vids as $vid => $value){
      $voc = taxonomy_vocabulary_load($vid);
      if($voc){
        $field['settings']['allowed_values'][$i] = array(
          'parent' => 0,
          'vocabulary' => $voc->machine_name
        );
        $i++;
      }
    }
    $field['settings']['allowed_values'][] = array(
      'parent' => 0,
      'vocabulary' => $vocabulary->machine_name
    );
    field_update_field($field);
  }
}

/**
 * Implements hook_form_alter()
 */
function scratchpads_taxonomic_name_field_form_alter(&$form, &$form_state, $form_id){
  field_cache_clear(TRUE);
  $field = field_info_field('field_taxonomic_name');
  $bio_vids = variable_get('biological_vids', array());
  $i = 0;
  $field['settings']['allowed_values'] = array();
  foreach($bio_vids as $vid => $value){
    $voc = taxonomy_vocabulary_load($vid);
    if($voc){
      $field['settings']['allowed_values'][$i] = array(
        'parent' => 0,
        'vocabulary' => $voc->machine_name
      );
      $i++;
    }
  }
  if(!count($field['settings']['allowed_values'])){
    $field['settings']['allowed_values'][0] = array(
      'parent' => 0,
      'vocabulary' => '__temporary__'
    );
  }
  field_update_field($field);
}

/**
 * Implementation of hook_taxonomy_vocabulary_delete().
 */
function scratchpads_taxonomic_name_field_taxonomy_vocabulary_delete($vocabulary){
  // We have a biological classification. We need to update the field.
  $field = field_info_field('field_taxonomic_name');
  $update = FALSE;
  foreach($field['settings']['allowed_values'] as $key => $value){
    if($value['vocabulary'] == $vocabulary->machine_name){
      $update = TRUE;
      unset($field['settings']['allowed_values'][$key]);
      if(!count($field['settings']['allowed_values'])){
        $field['settings']['allowed_values'][0] = array(
          'parent' => 0,
          'vocabulary' => '__temporary__'
        );
      }
      break;
    }
  }
  if($update){
    $field['settings']['allowed_values'] = array_values($field['settings']['allowed_values']);
    field_update_field($field);
  }
}

/**
 * Implementation of hook_facetapi_facet_info().
 */
function scratchpads_taxonomic_name_field_facetapi_facet_info($searcher_info = FALSE){
  // Facets are usually associated with the type of content stored in the index.
  return array(
    'im_field_taxonomic_name' => array(
      'name' => 'im_field_taxonomic_name',
      'label' => t('Taxonomic name'),
      'description' => t('Taxonomic name'),
      'query types' => array(
        'term'
      ),
      'map callback' => 'facetapi_map_taxonomy_terms'
    ),
    'tid' => array(
      'name' => 'tid',
      'label' => t('Terms'),
      'description' => t('Terms'),
      'query types' => array(
        'term'
      ),
      'map callback' => 'facetapi_map_taxonomy_terms'
    )
  );
}

/**
 * Implements hook_ctools_plugin_api().
 *
 * Magic happens just because this function exists (fucked up, I know).
 */
function scratchpads_taxonomic_name_field_ctools_plugin_api(){}

/**
 * Implements hook_facetapi_default_facet_settings().
 */
function scratchpads_taxonomic_name_field_facetapi_default_facet_settings(){
  $facets = scratchpads_taxonomic_name_field_facetapi_facet_info(FALSE);
  foreach($facets as $facet_id => $facet_values){
    $facet = new stdClass();
    $facet->disabled = FALSE;
    $facet->api_version = 1;
    $facet->name = 'apachesolr@solr:block:' . $facet_id;
    $facet->searcher = 'apachesolr@solr';
    $facet->realm = 'block';
    $facet->facet = $facet_id;
    $facet->enabled = TRUE;
    $facet->settings = array(
      'weight' => 0,
      'widget' => 'facetapi_links',
      'filters' => array(),
      'active_sorts' => array(
        'active' => 'active',
        'count' => 'count',
        'display' => 'display'
      ),
      'sort_weight' => array(
        'active' => -50,
        'count' => -49,
        'display' => -48
      ),
      'sort_order' => array(
        'active' => 3,
        'count' => 3,
        'display' => 4
      ),
      'empty_behavior' => 'text',
      'empty_text' => array(
        'value' => t('There are no facets available to filter on.'),
        'format' => 'filtered_html'
      ),
      'soft_limit' => 20,
      'show_expanded' => 0
    );
    $facets[$facet_id] = $facet;
  }
  return $facets;
}

/**
 * Implementation of hook_block_view_alter()
 */
function scratchpads_taxonomic_name_field_block_view_alter(&$data, $block){
  if($block->module == 'facetapi'){
    $map = facetapi_get_delta_map();
    $facet_info = scratchpads_taxonomic_name_field_facetapi_facet_info();
    foreach(scratchpads_taxonomic_name_field_facetapi_default_facet_settings() as $facet){
      $delta = array_search($facet->name, $map);
      if($delta == $block->delta && isset($facet_info[$facet->facet])){
        $data['subject'] = $facet_info[$facet->facet]['label'];
        break;
      }
    }
  }
}

/**
 * Implementation of hook_cron().
 *
 * FIXME - This should not be required. Unfortunately I have been unable to
 * track down why some taxonomic name fields are not always associated with the
 * correct vocabularies. This will put a giant fucking plaster over the issue.
 */
function scratchpads_taxonomic_name_field_cron(){
  $field = field_info_field('field_taxonomic_name');
  $bio_vids = variable_get('biological_vids', array());
  $i = 0;
  $field['settings']['allowed_values'] = array();
  foreach($bio_vids as $vid => $value){
    $voc = taxonomy_vocabulary_load($vid);
    if($voc){
      $field['settings']['allowed_values'][$i] = array(
        'parent' => 0,
        'vocabulary' => $voc->machine_name
      );
      $i++;
    }
  }
  if(!count($field['settings']['allowed_values'])){
    $field['settings']['allowed_values'][0] = array(
      'parent' => 0,
      'vocabulary' => '__temporary__'
    );
  }
  field_update_field($field);
}

/**
 * Implementation of hook_context_default_contexts().
 */
function scratchpads_taxonomic_name_field_context_default_contexts(){
  $export = array();
  $context = new stdClass();
  $context->disabled = FALSE;
  $context->api_version = 3;
  $context->name = 'taxonomic_name_facet';
  $context->description = t('Taxonomic name field on a search page.');
  $context->tag = 'solr';
  $context->conditions = array(
    'path' => array(
      'values' => array(
        'gallery*' => 'gallery*',
        'biblio*' => 'biblio*',
        'search*' => 'search*',
        'group*' => 'group*'
      )
    )
  );
  $context->reactions = array(
    'block' => array(
      'blocks' => array()
    )
  );
  $map = facetapi_get_delta_map();
  foreach(scratchpads_taxonomic_name_field_facetapi_default_facet_settings() as $facet){
    $delta = array_search($facet->name, $map);
    if($delta){
      $context->reactions['block']['blocks'][] = array(
        'module' => 'facetapi',
        'delta' => $delta,
        'region' => 'sidebar',
        'weight' => -27
      );
    }
  }
  $context->condition_mode = 0;
  $export['taxonomic_name_facet'] = $context;
  return $export;
}

function scratchpads_taxonomic_name_field_autocomplete($field_name, $tags_typed = '') {
  // If the request has a '/' in the search text, then the menu system will have
  // split it into multiple arguments, recover the intended $tags_typed.
  $args = func_get_args();
  // Shift off the $field_name argument.
  array_shift($args);
  $tags_typed = implode('/', $args);

  // Make sure the field exists and is a taxonomy field.
  if (!($field = field_info_field($field_name)) || $field['type'] !== 'taxonomy_term_reference') {
    // Error string. The JavaScript handler will realize this is not JSON and
    // will display it as debugging information.
    print t('Taxonomy field @field_name not found.', array('@field_name' => $field_name));
    exit;
  }
  
  //Only show vocabulary name when there is more than vocabularly allowed
  $multiple = FALSE;
  $field = field_info_field($field_name);
  if (count($field['settings']['allowed_values']) > 1) {$multiple = TRUE;}

  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  $tags_typed = drupal_explode_tags($tags_typed);
  $tag_last = drupal_strtolower(array_pop($tags_typed));

  $matches = array();
  if ($tag_last != '') {

    // Part of the criteria for the query come from the field's own settings.
    $vids = array();
    $vocabularies = taxonomy_vocabulary_get_names();
    foreach ($field['settings']['allowed_values'] as $tree) {
      $vids[] = $vocabularies[$tree['vocabulary']]->vid;
    }

    $query = db_select('taxonomy_term_data', 't');
    $query->addTag('translatable');
    $query->addTag('term_access');
    $query->join('taxonomy_vocabulary', 'v', 't.vid = v.vid');
    $query->addField('v', 'name', 'vocab_name');

    // Do not select already entered terms.
    if (!empty($tags_typed)) {
      $query->condition('t.name', $tags_typed, 'NOT IN');
    }
    // Select rows that match by term name.
    $tags_return = $query
      ->fields('t', array('tid', 'name', 'vid'))
      ->condition('t.vid', $vids)
      ->condition('t.name', '%' . db_like($tag_last) . '%', 'LIKE')
      ->range(0, 10)
      ->execute()
      ->fetchAll();

    $prefix = count($tags_typed) ? drupal_implode_tags($tags_typed) . ', ' : '';

    $term_matches = array();
    foreach ($tags_return as $tag) {
      $n = $tag->name;
      // Term names containing commas or quotes must be wrapped in quotes.
      if (strpos($tag->name, ',') !== FALSE || strpos($tag->name, '"') !== FALSE) {
        $n = '"' . str_replace('"', '""', $tag->name) . '"';
      }
      $term_matches[$prefix . $n] = $multiple ? check_plain($tag-> name.' ('.$tag->vocab_name.')') : check_plain($tag->name);
    }
  }

  drupal_json_output($term_matches);
}
