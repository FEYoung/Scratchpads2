<?php

/*********************************************************************************************
 * 
 * HOOKS
 * 
 ********************************************************************************************/
/**
 * Implement hook_menu_alter().
 */
function formflow_menu_alter(&$callbacks){
  $flows = formflow_get_flows();
  // Register the callbacks for each of these flows
  foreach($flows as $name => $flow){
    $url = $flow['path'];
    // The flow needs to have %step in the path - but we don't want it in the menu callback
    $flow['path'] .= '/%step';
    $flow['name'] = $name;
    $callbacks[$url] = array(
      'page callback' => 'formflow_page',
      'page arguments' => array(
        $flow,
        count(explode('/', $url))
      ),
      'access arguments' => array(
        'access form flows'
      )
    );
  }
}

/**
 * Implements hook_permission().
 */
function formflow_permission(){
  return array(
    'administer form flows' => array(
      'title' => t('Administer form flows')
    ),
    'create form flows' => array(
      'title' => t('Create new form flows')
    ),
    'edit form flows' => array(
      'title' => t('Edit form flows')
    ),
    'access form flows' => array(
      'title' => t('Access form flows'),
      'description' => t('Access form flows - users also need to have permissions for all of the forms in the flow (eg edit permissions for a node form).')
    )
  );
}

/**
 * Implements hook_form_alter().
 */
function formflow_form_alter(&$form, &$form_state, $form_id){
  // Is this a formflow form?
  if(isset($form_state['formflow'])){
    // Array of submit functions to be called on completion
    $form_state['finish'] = array();
    foreach($form['#submit'] as $key => $submit){
      if($submit == 'ctools_wizard_submit' || $submit == 'formflow_submit'){
        continue;
      }
      unset($form['#submit'][$key]);
      $form_state['finish'][] = $submit;
    }
    // Node form uses actions for it's submit functions
    if(isset($form['actions'])){
      if(isset($form['actions']['submit']['#submit'])){
        $form_state['finish'] = array_merge($form_state['finish'], (array)$form['actions']['submit']['#submit']);
      }
      unset($form['actions']);
    }
    if(isset($form['submit'])){
      if(isset($form['submit']['#submit'])){
        $form_state['finish'] = array_merge($form_state['finish'], (array)$form['submit']['#submit']);
      }
      unset($form['submit']);
    }
    $form['#submit'][] = 'formflow_submit';
  }
}

/**
 * Implements hook_field_attach_form().
 */
function formflow_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode){
  formflow_attach_groups($form, $form_state, 'form');
}

/**
 * Implements hook_field_group_formatter_info().
 */
function formflow_field_group_formatter_info(){
  return array(
    'form' => array(
      'formflow' => array(
        'label' => t('Formflow'),
        'description' => t('Treat this group as a stage in a formflow.'),
        'instance_settings' => array(
          'classes' => ''
        )
      )
    )
  );
}

/** 
 * Implementation of hook_theme(). 
 */
function formflow_theme(){
  return array(
    // Theme the views plugin form table
    'formflow_wizard_trail' => array(
      'render element' => 'element',
      'file' => 'theme.inc'
    ),
    'formflow_group' => array(
      'render element' => 'element',
      'file' => 'theme.inc'
    )
  );
}

/*********************************************************************************************
 * 
 * CTOOLS PLUGIN INTEGRATION
 * 
 ********************************************************************************************/
/**
 * Implements hook_ctools_plugin_api().
 */
function formflow_ctools_plugin_api($owner, $api){
  if($owner == 'formflow'){return array(
      'version' => 1
    );}
}

/**
 * Implementation of hook_ctools_plugin_directory() to let the system know
 * we implement task and task_handler plugins.
 */
function formflow_ctools_plugin_directory($module, $plugin){
  if($module == 'formflow'){return 'plugins';}
}

/**
 * Implements hook_ctools_plugin_type().
 */
function formflow_ctools_plugin_type(){
  return array(
    'flows' => array(
      'cache' => TRUE,
      'title' => t("Form flows")
    )
  );
}

/**
 * 
 * Retrieve all flows defined via plugins
 */
function formflow_get_plugin_flows(){
  ctools_include('plugins');
  $plugins = ctools_get_plugins('formflow', 'flows');
  return $plugins;
}

/*********************************************************************************************
 * 
 * DB
 * 
 ********************************************************************************************/
/**
 * 
 * Get all flows (plugins & DB)
 */
function formflow_get_flows($name = null){
  $flows = formflow_get_db_flows();
  $plugins = formflow_get_plugin_flows();
  if(count($plugins)){
    foreach($plugins as $plugin){
      // Don't overwrite DB plugins - allow for overriding 
      if(!isset($flows[$plugin['flow']['name']])){
        $flows[$plugin['flow']['name']] = $plugin['flow'];
      }
      // Register that this is defined in code
      $flows[$plugin['flow']['name']]['plugin'] = true;
    }
  }
  if($name){
    return $flows[$name];
  }else{
    return $flows;
  }
}

/**
 * 
 * Retrieve all flows defined in DB
 * @param optional formflow name $name
 */
function formflow_get_db_flows(){
  $query = db_select('formflow', 'ff');
  $query->fields('ff');
  $result = $query->execute();
  $flows = $result->fetchAllAssoc('name', PDO::FETCH_ASSOC);
  foreach($flows as $name => $flow){
    $flows[$name]['steps'] = formflow_get_db_steps($flow['fid']);
  }
  return $flows;
}

/**
 * 
 * Retrieve the steps for a formflow from the db
 * @param formflow id $fid
 */
function formflow_get_db_steps($fid){
  $query = db_select('formflow_step', 'ffs');
  $query->fields('ffs', array(
    'title',
    'form_id',
    'path'
  ));
  $query->condition('fid', $fid, '=');
  $query->orderBy('weight', 'ASC');
  $result = $query->execute();
  $steps = $result->fetchAll(PDO::FETCH_ASSOC);
  return $steps;
}

function formflow_delete($fid){
  db_delete('formflow')->condition('fid', $fid, '=')->execute();
  formflow_delete_steps($fid);
}

function formflow_delete_steps($fid){
  db_delete('formflow_step')->condition('fid', $fid, '=')->execute();
}

/**
 * 
 * Save a flow & it's steps
 * @param array / object $flow
 */
function formflow_save($flow){
  if(is_array($flow)){
    $flow = (object)$flow;
  }
  $update = array();
  if(isset($flow->fid)){
    $update[] = 'fid';
  }
  drupal_write_record('formflow', $flow, $update);
  // If steps are defined, save them to the database
  if(isset($flow->steps) && isset($flow->fid)){
    formflow_save_steps($flow->fid, $flow->steps);
  }
}

/**
 * Save the form flow steps
 * @param flow id $fid
 * @param array of steps $steps
 */
function formflow_save_steps($fid, $steps){
  // Delete all steps
  formflow_delete_steps($fid);
  // Insert the new steps into the step table
  if(count($steps)){
    foreach($steps as $step){
      $record = (object)$step;
      $record->fid = $fid;
      drupal_write_record('formflow_step', $record);
    }
  }
}

/*********************************************************************************************
 * 
 * MENU CALLBACKS
 * 
 ********************************************************************************************/
function formflow_page($flow, $current_group = null){
  global $user;
  $form_state = array();
  ctools_include('wizard');
  $flow['id'] = $flow['name'];
  $flow['back callback'] = 'formflow_back';
  $flow['next callback'] = 'formflow_next';
  $flow['finish callback'] = 'formflow_finish';
  $flow['cancel callback'] = 'formflow_cancel';
  $flow['order'] = array();
  // Crappy database layer won't let you have spaces in field aliases! Rewrite the keys here 
  foreach(array(
    'show_trail',
    'show_back',
    'show_cancel',
    'show_return',
    'cancel_path'
  ) as $old_key){
    if(isset($flow[$old_key])){
      $new_key = str_replace('_', ' ', $old_key);
      $flow[$new_key] = $flow[$old_key];
      unset($flow[$old_key]);
    }
  }
  foreach($flow['steps'] as $delta => $step){
    $flow['forms'][$delta] = array(
      'form id' => $flow['steps'][$delta]['form_id']
    );
    $flow['order'][$delta] = $flow['steps'][$delta]['title'];
  }
  $cache_id = $flow['name'];
  if(!is_numeric($current_group)){
    $current_group = 0;
    // If the form hasn''t been submitted & step is null, clear the cache    
    if(!count($_POST)){
      formflow_cache_clear($cache_id);
    }
  }
  if(!count($flow['steps'])){
    drupal_set_message(t('There are no forms in this flow.'), 'error');
    return '';
  }
  // check access for this url  
  if(isset($flow['steps'][$current_group]['path'])){
    $item = menu_get_item($flow['steps'][$current_group]['path']);
    if($item['include_file']){
      $flow['steps'][$current_group]['include_file'] = $item['include_file'];
      require_once DRUPAL_ROOT . '/' . $item['include_file'];
    }
  }
  // This automatically gets defaults if there wasn't anything saved.
  $cache = formflow_cache_get($cache_id);
  $form_state = array(
    // Put our object and ID into the form state cache so we can easily find
    // it.
    'formflow' => array(
      'cache_id' => $cache_id,
      'cache' => &$cache
    )
  );
  // Is this a node type form
  if($strpos = strpos($flow['forms'][$current_group]['form id'], '_node_form')){
    $node_type = substr($flow['forms'][$current_group]['form id'], 0, $strpos);
    $node = (object)array(
      'uid' => $user->uid,
      'name' => (isset($user->name) ? $user->name : ''),
      'type' => 'page',
      'language' => LANGUAGE_NONE
    );
    $form_state['build_info']['args'] = array(
      $node
    );
  }else if(isset($flow['steps'][$current_group]['path']) && !drupal_valid_path($flow['steps'][$current_group]['path'])){
    drupal_access_denied();
  }
  // Allow other modules to make changes & additions before loading the form 
  drupal_alter('formflow', $flow, $form_state);
  // Build the form      
  $form = ctools_wizard_multistep_form($flow, $current_group, $form_state);
  if(!$form){
    if(!count($flow['forms'])){
      drupal_set_message(t('There are no forms in this flow.'), 'error');
    }else{
      drupal_set_message(t('Sorry, the form could not be found.'), 'error');
    }
    return '';
  }
  // Messy, but it works: after letting ctools wizard work it's magic, use our cached form if it exists
  if(isset($cache[$current_group]['form'])){
    $form = $cache[$current_group]['form'];
  }
  return $form;
}

/*********************************************************************************************
 * 
 * FORMS
 * 
 ********************************************************************************************/
function formflow_submit(&$form, &$form_state){
  $form_state['formflow']['cache'][$form_state['step']] = array(
    'form' => $form,
    'form_state' => $form_state
  );
  formflow_cache_set($form_state['formflow']['cache_id'], $form_state['formflow']['cache']);
}

/*********************************************************************************************
 * 
 * Wizard helpers
 * 
 ********************************************************************************************/
/**
 * Handle the 'finish' click 
 */
function formflow_finish(&$form_state){
  $form_state['complete'] = TRUE;
  // If a finish path has been set, redirect to it
  if(isset($form_state['form_info']['finish_path'])){
    $form_state['redirect'] = url($form_state['form_info']['finish_path']);
  }else{
    $form_state['redirect'] = url(str_replace('/%step', '', $form_state['form_info']['path']));
  }
  // Call all submit funtions for all forms in the step
  foreach($form_state['formflow']['cache'] as $delta => $cache){
    if(count($cache['form_state']['finish'])){
      foreach($cache['form_state']['finish'] as $func){
        if(isset($cache['form_state']['form_info']['steps'][$delta]['include_file'])){
          require_once DRUPAL_ROOT . '/' . $cache['form_state']['form_info']['steps'][$delta]['include_file'];
        }
        if(function_exists($func)){
          $func($cache['form'], $cache['form_state']);
        }
      }
    }
  }
  // Clear the caches
  formflow_cache_clear($form_state['formflow']['cache_id']);
}

/**
 * Handle the 'cancel' click 
 */
function formflow_cancel(&$form_state){
  $form_state['cancel'] = TRUE;
}

/*********************************************************************************************
 * 
 * Cache functions
 * 
 ********************************************************************************************/
function formflow_cache_set($id, $cache){
  ctools_include('object-cache');
  ctools_object_cache_set('formflow', $id, $cache);
}

function formflow_cache_get($id){
  ctools_include('object-cache');
  return (array)ctools_object_cache_get('formflow', $id);
}

/**
 * Clear the wizard cache.
 */
function formflow_cache_clear($id){
  ctools_include('object-cache');
  ctools_object_cache_clear('formflow', $id);
}

/**
 * 
 * Clear the menu caches
 */
function formflow_menu_cache_clear(){
  menu_rebuild();
}

/*********************************************************************************************
 * 
 * Field group
 * 
 ********************************************************************************************/
/**
 * Attach groups to the (form) build.
 * @param Array $element The part of the form.
 * @param String $view_mode The mode for the build.
 */
function formflow_attach_groups(&$form, &$form_state, $build_mode){
  ctools_add_css('wizard');
  // Attach the fieldgroup CSS
  $form['#attached']['css'] = array(
    drupal_get_path('module', 'formflow') . '/css/formflow.css'
  );
  // If there's no current step, default tot he first one
  if(!isset($form_state['current_group'])){
    $form_state['current_group'] = @array_shift(array_keys($form['#groups']));
  }
  $form['#current_group'] = $form_state['current_group'];
  // Build a trail to display at the top of the form
  $form['trail'] = array(
    '#theme' => 'formflow_wizard_trail',
    '#value' => array(),
    '#weight' => -1000,
    '#formflow' => true
  );
  foreach($form['#groups'] as $group){
    if($group->group_name == $form['#current_group']){
      $class = 'wizard-trail-current';
    }else{
      $class = 'wizard-trail-next';
    }
    $form['trail']['#value'][] = '<span class="' . $class . '">' . $group->label . '</span>';
  }
  // Get the numeric position of the current group
  $form['#position'] = array_search($form['#current_group'], array_keys($form['#groups']));
  $form['formflow_actions'] = array(
    '#type' => 'actions'
  );
  // If this isn't the last group, show the back button
  if($form['#position'] > 0){
    $form['formflow_actions']['back'] = array(
      '#type' => 'submit',
      '#value' => t('Back'),
      '#weight' => -100,
      '#limit_validation_errors' => array(),
      '#submit' => array(
        'formflow_field_group_back_submit'
      ),
      '#formflow' => true // Set a flag to preserve this over all formflow steps
    );
  }
  // If this isn't the last group, show the next button
  if(($form['#position'] + 1) < count($form['#groups'])){
    $form['formflow_actions']['next'] = array(
      '#type' => 'submit',
      '#value' => t('Next'),
      '#limit_validation_errors' => array(),
      '#submit' => array(
        'formflow_field_group_next_submit'
      ),
      '#formflow' => true // Set a flag to preserve this over all formflow steps
    );
  }
  // limit validation errors to only the form items in the current group
  foreach($form['#group_children'] as $element_name => $group){
    if($group == $form['#current_group']){
      $form['formflow_actions']['next']['#limit_validation_errors'][] = array(
        $element_name
      );
    }
  }
  return $form;
}

/**
 * Button submit function: handle the 'back' button on the form.
 */
function formflow_field_group_back_submit($form, &$form_state){
  $form_state['current_group'] = formflow_field_group_navigate('back', $form, $form_state);
  $form_state['rebuild'] = TRUE;
}

/**
 * Button submit function: handle the 'next' button on the form.
 */
function formflow_field_group_next_submit($form, &$form_state){
  $form_state['current_group'] = formflow_field_group_navigate('next', $form, $form_state);
  $form_state['rebuild'] = TRUE;
}

/**
 * 
 * Helper function for handling next/back navigation
 * @param string - direction of travel $op
 * @param array $form
 * @param array $form_state
 */
function formflow_field_group_navigate($op, $form, &$form_state){
  reset($form['#groups']);
  do{
    $current_group = current($form['#groups']);
    if($current_group->group_name == $form_state['current_group']){
      switch($op){
        case 'back':
          $prev_group = prev($form['#groups']);
          return $prev_group->group_name;
          break;
        case 'next':
          $next_group = next($form['#groups']);
          return $next_group->group_name;
          break;
      }
    }
  }
  while(next($form['#groups']));
}

/**
 * Implemntation of hook_field_group_pre_render
 * Adds the formflow field group elements
 * @see called by field_group_pre_render().
 * @param $element Array of group element that needs to be created!
 * @param $group Object with the group information.
 * @param $form The form object itself.
 */
function formflow_field_group_pre_render(&$element, $group, &$form){
  $view_mode = isset($form['#view_mode']) ? $form['#view_mode'] : 'form';
  $id = $form['#entity_type'] . '_' . $form['#bundle'] . '_' . $view_mode . '_' . $group->group_name;
  // Prepare extra classes.
  $classes = array(
    'field-group-' . $group->format_type,
    str_replace('_', '-', $group->group_name)
  );
  if($group->group_name == $form['#current_group']){
    $classes[] = 'active-group';
  }
  switch($group->format_type){
    case 'formflow':
      $element += array(
        '#id' => $id,
        '#weight' => $group->weight,
        '#theme_wrappers' => array(
          'formflow_group'
        ),
        '#prefix' => '<div class="' . implode(' ', $classes) . '">',
        '#suffix' => '</div>',
        '#group' => $group->format_type
      );
      break;
  }
  // Loop through & identify which group is the last one with required fields
  // We can then use this to decide when to show the submit buttons
  foreach(element_children($element) as $key){
    if($instance = field_info_instance($form['#entity_type'], $key, $form['#bundle'])){
      if($instance['required']){
        $form['#last_required_group'] = $group->group_name;
        break;
      }
    }
  }
}

/**
 * 
 * Implementation of hook_field_group_build_pre_render_alter
 * Make changes so only relevant bits of the form are shown
 * @param form $element
 */
function formflow_field_group_build_pre_render_alter(&$form){
  $view_mode = isset($form['#view_mode']) ? $form['#view_mode'] : 'form';
  switch($view_mode){
    case 'form':
      $end_point = false;
      if(isset($form['actions']) && isset($form['formflow_actions'])){
        $form['actions'] += $form['formflow_actions'];
        unset($form['formflow_actions']);
      }
      // If there are actions & formflow_actions, merge them together
      // If we are on the last step on the form, do nothing
      // We'll want to show all buttons
      if(($form['#position'] + 1) == count($form['#groups'])){return;}
      if(!isset($form['changed']) || empty($form['changed']['#value'])){
        // Loop through the groups - if we're not past the last required group in the flow, hide the buttons
        foreach($form['#groups'] as $group_name => $group){
          // If the current group is before the last required group, update the buttons
          if($group_name == $form['#last_required_group']){
            // Can the user end at this stage of the form?
            $end_point = true;
            break;
          }
          if($group_name == $form['#current_group']){
            break;
          }
        }
      }
      formflow_field_group_remove_elements($form, $end_point);
      break;
  }
}

/**
 * 
 * Remove the default submit buttons
 * @param form element $element
 */
function formflow_field_group_remove_elements(&$form, $end_point){
  foreach(element_children($form) as $key){
    if(isset($form[$key]['#formflow']) || (isset($form[$key]['#type']) && in_array($form[$key]['#type'], array(
      'value',
      'hidden',
      'token'
    ))) || ($end_point && isset($form[$key]['#type']) && $form[$key]['#type'] == 'submit')){
      continue;
    }
    if(isset($form[$key]['#type']) && $form[$key]['#type'] == 'container' && count(element_children($form[$key]))){
      formflow_field_group_remove_elements($form[$key], $end_point);
    }elseif(!(isset($form[$key]['#group']) && $form[$key]['#group'] == 'formflow')){
      unset($form[$key]);
    }
  }
  return $form;
}





