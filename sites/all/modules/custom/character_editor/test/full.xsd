<?xml version="1.0" encoding="iso-8859-1"?>
<xs:schema xmlns="http://rs.tdwg.org/UBIF/2006/" xmlns:u="http://rs.tdwg.org/UBIF/2006/" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:html="http://www.w3.org/1999/xhtml" targetNamespace="http://rs.tdwg.org/UBIF/2006/" elementFormDefault="qualified" attributeFormDefault="unqualified" blockDefault="#all" version="Unified Biosciences Information Framework (UBIF) 1.1 and SDD 1.1 rev. 5 (minor change in SDD_TypeLib.xsd)">
  <xs:annotation>
    <xs:documentation xml:lang="en-us">This is the schema file to be referenced in instance documents for validation. It is the top level schema file that integrates the schema components.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">This version integrates UBIF and SDD. To add further object types, this file has to be changed.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Copyright © 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file SDD_(c).xsd for authorship and licensing information.</xs:documentation>
  </xs:annotation>
  <xs:include schemaLocation="SDD_TypeLib.xsd"/>
  <xs:element name="Datasets">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Root element for files or data streams. Multiple Dataset objects are completely independent. Potential relationship may be detected by the consumer, but are not expressed in the UBIF format. The sequence of Dataset objects has no semantics and does not have to be preserved.

The version of the UBIF standard used is defined in the namespace declaration and needs no separate data element.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name="TechnicalMetadata" type="TechnicalMetadata">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Metadata describing provider and process that created the current xml document. The provider is not necessarily the creator or owner of the dataset, compare Owner, IPR of dataset itself.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="Dataset" type="Dataset" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Data from one or several object types, with common technical and content metadata.</xs:documentation>
          </xs:annotation>
          <xs:unique name="AnyObjectURI">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The attribute uri is optional in any first class object and denotes the preferred globally unique identifier. Not two objects may have the same uri. However, although strictly the constraint is global, to simplify dataset integration (where 2 datasets may, e.g., contain the same mediaobject), the uniqueness constraint is enforced only within a dataset, not within the set of datasets.</xs:documentation>
            </xs:annotation>
            <xs:selector xpath=".//u:*"/>
            <xs:field xpath="@uri"/>
          </xs:unique>
        </xs:element>
        <xs:group ref="SpecificExtension" minOccurs="0"/>
      </xs:sequence>
    </xs:complexType>
    <!-- NOTE: Following the decision to make the xml:lang attribute optional on Label/Detail etc. elements, and make it inheritable from a "default" xml:lang on the dataset, many uniqueness constraints on unique label and unique role elements can no longer be expressed in w3c schema. We had to balance the convenience of not requiring to state language each time against validation issues. We believe the following rules should be externally validated. Where the audience is part of a rule, and where it is missing, the audience may be treated as an empty string, i.e. a rule should be evaluated, not skipped.
<xs:unique name="TaxonNames_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of objects must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:TaxonNames/u:TaxonName/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="TaxonHierarchy_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of objects must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:TaxonHierarchies/u:TaxonHierarchy/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="Specimen_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of objects must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:Specimens/u:Specimen/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="DescriptiveConcept_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">All representations within a Label must have different language values.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:DescriptiveConcepts/u:DescriptiveConcept/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="ConceptState_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">@FIXME@ The labels of concept state definitions are required and must - for each concept - be unique for a given language. They do not have to be unique across concepts. Example: two states 'rough' in a single concept are undesirable, but state labels 'rough' for one concept observed with fingers and another concept using an electron microscope would be ok.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:DescriptiveConcepts/u:DescriptiveConcept/u:ConceptStates/u:StateDefinition/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="StatisticalMeasureElaboration_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of Statistical measure elaborations are required and must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:CharacterTrees/u:CharacterTree/u:Nodes/u:Node/u:InheritableDefinitions/u:RecommendedMeasures/u:StatisticalMeasure/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="Modifier_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of modifier definitions are required and must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:DescriptiveConcepts/u:DescriptiveConcept/u:Modifiers/u:Modifier/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="Character_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of Character definitions are required and must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:Characters/u:*/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="CharacterState_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">@@@ The labels of character state definitions are required and must - for each character - be unique for a given language. They do not have to be unique across concepts. Example: two states 'rough' in a single character are undesirable, but state labels 'rough' for one character observed with fingers and another char. using an electron microscope would be ok.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:Characters/u:Character/u:States/u:StateDefinition/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="CharacterTree_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of CharacterTree definitions are required and must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:CharacterTrees/u:CharacterTree/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="Sample_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The audience values must uniquely identify the representations within each Note element (no duplicate language/audience-combination allowed).</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:CodedDescriptions/u:CodedDescription/u:SampleData/u:Sample/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="StoredKey_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of stored key definitions (i. e. for the entire key) are required and must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:StoredKeys/u:StoredKey/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="Agents_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of objects must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:Agents/u:Agent/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="MediaObjects_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of objects must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:MediaObjects/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="Audience_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of audience definitions are required and must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:Audiences/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="GeographicArea_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of objects must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:GeographicAreas/u:*/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="Publications_UniqueLabelText">
<xs:annotation>
<xs:documentation xml:lang="en-us">The labels of objects must be unique for a given language.</xs:documentation>
</xs:annotation>
<xs:selector xpath="u:Dataset/u:Publications/u:Publication/u:Representation"/>
<xs:field xpath="u:Label"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="UniqueLabelRepresentation">
<xs:annotation>
<xs:documentation xml:lang="en-us">For each language/audience, the label representation of must be unique, i.e. no role should appear twice in the same language/audience.</xs:documentation>
</xs:annotation>
<xs:selector xpath=".//u:Representation"/>
<xs:field xpath="u:Label/@role"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
<xs:unique name="UniqueDetailRepresentation">
<xs:annotation>
<xs:documentation xml:lang="en-us">For each language/audience, the detail representation of must be unique, i.e. no role should appear twice in the same language/audience. NOTE: This rule may be joined with UniqueLabelRepresentation, because the values or role in Label and in Detail do not overlap.</xs:documentation>
</xs:annotation>
<xs:selector xpath=".//u:Representation"/>
<xs:field xpath="u:Detail/@role"/>
<xs:field xpath="u:Detail/@xml:lang"/>
<xs:field xpath="u:Detail/@xml:audience"/>
</xs:unique>
<xs:unique name="IPR_UniqueRepresentation">
<xs:annotation>
<xs:documentation xml:lang="en-us">For each language/audience, the label representation of must be unique, i.e. no statement role should appear twice in the same language/audience.</xs:documentation>
</xs:annotation>
<xs:selector xpath=".//u:IPRStatements/u:IPRStatement"/>
<xs:field xpath="u:Label/@role"/>
<xs:field xpath="u:Label/@xml:lang"/>
<xs:field xpath="u:Label/@xml:audience"/>
</xs:unique>
		<xs:unique name="AbstractObject_UniqueLabelRoleLangAudience2">
							<xs:annotation>
								<xs:documentation xml:lang="en-us">With any object representation, all Labels must have different role/language/audience values. Uniqueness is required only within each object representation, not in the entire dataset or file.

@NOTE FOR JACOB: Currently this does not work. It should prevent minimized code like: 
<Representation>
										<Label xml:lang="en">X</Label>
										<Label xml:lang="en">2nd</Label>
									</Representation>
which because of default values is:
<Representation>
										<Label role="full" xml:lang="en" audience="?">X</Label>
										<Label role="full" xml:lang="en" audience="?">2nd</Label>
									</Representation>
Older versions of Spy did have a problem with default values, and did not evaluate this constraint if attributes were missing. The newest version, however, does not even evaluate a testing constraint with only language in it, and I suspect something else is wrong. </xs:documentation>
							</xs:annotation>
							<xs:selector xpath="."/>
							<xs:field xpath="u:Label/@role"/>
							<xs:field xpath="u:Label/@xml:lang"/>
							<xs:field xpath="u:Label/@audience"/>
						</xs:unique>
-->
    <xs:unique name="AnyObjectKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of Global Uniqueness constraint. This is under discussion and will be settled before betas end. Applications should not rely on its presence or absence until it is settled. Removing it requires no changes in the schema, and existing instance documents will remain valid under such a new version. However, software consuming instance documents that relies on uniquenes may be in trouble if id values in fact are no longer unique within the document, but only within an object class (like specimen, character). - Note: A related constraint, AnyObjectURI, is defined on individual dataset objects.</xs:documentation>
      </xs:annotation>
      <xs:selector xpath=".//u:*"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:unique name="DatasetKey">
      <xs:selector xpath="u:Dataset"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="TechnicalOrAdministrativeContact_Keyref" refer="AgentKey">
      <xs:selector xpath="u:TechnicalMetadata/u:TechnicalContact | u:TechnicalMetadata/u:AdministrativeContact"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="TaxonNameKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of TaxonName-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:TaxonNames/u:TaxonName"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="TaxonName_Keyref" refer="TaxonNameKey">
      <xs:selector xpath=".//u:TaxonName"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="TaxonHierarchyKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of TaxonHierarchy-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:TaxonHierarchies/u:TaxonHierarchy"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:unique name="TaxonHierarchyNode_Key">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Currently we do not distinguish between inner and terminal nodes in this tree.</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:TaxonHierarchies/u:TaxonHierarchy/u:Nodes/u:Node"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="TaxonHierarchyNode_Keyref" refer="TaxonHierarchyNode_Key">
      <xs:selector xpath="u:Dataset/u:TaxonHierarchies/u:TaxonHierarchy/u:Nodes/u:Node/u:Parent"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="SpecimenKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of Specimen-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:Specimens/u:Specimen"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="Specimen_Keyref" refer="SpecimenKey">
      <xs:selector xpath=".//u:Specimen"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="DescriptiveConceptKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of DescriptiveConcept-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:DescriptiveConcepts/u:DescriptiveConcept"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="DescriptiveConcept_Keyref" refer="DescriptiveConceptKey">
      <xs:selector xpath=".//u:DescriptiveConcept |.//u:ModifierConcept |.//u:Scope/u:Part |.//u:Scope/u:Stage |.//u:Scope/u:Sex |.//u:Scope/u:OtherConcept"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="ConceptStateKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">All concept state (also known as "global states) id values must be unique in an entire project (i. e. not only within a concept).</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:DescriptiveConcepts/u:DescriptiveConcept/u:ConceptStates/u:StateDefinition"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="ConceptState_Keyref" refer="ConceptStateKey">
      <xs:selector xpath="u:Dataset/u:Characters/u:CategoricalCharacter/u:States/u:StateReference"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="ModifierKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of Modifier-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:DescriptiveConcepts/u:DescriptiveConcept/u:Modifiers/u:Modifier"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="ModifierConcept_Keyref" refer="ModifierKey">
      <xs:selector xpath="u:Dataset/u:CharacterTrees/u:CharacterTree/u:Nodes/u:Node/u:InheritableDefinitions/u:RecommendedModifiers/u:ModifierConcept"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="CharacterKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of Character-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:Characters/u:*"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:unique name="CharacterKey_Categorical">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Character-type-specific key, used in type-specific keyrefs.</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:Characters/u:CategoricalCharacter"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:unique name="CharacterKey_Quantitative">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Character-type-specific key, used in type-specific keyrefs.</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:Characters/u:QuantitativeCharacter"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:unique name="CharacterKey_Text">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Character-type-specific key, used in type-specific keyrefs.</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:Characters/u:TextCharacter"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:unique name="CharacterKey_Sequence">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Character-type-specific key, used in type-specific keyrefs.</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:Characters/u:SequenceCharacter"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:unique name="CharacterStateKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Contains all locally defined character states (= StateDefinition) plus those concept states actually referenced in a character (StateReference; here the ref attribute is automatically also used as a new within-character id). Note that state ids are required to be unique across all characters, not only within each character. In descriptions this constraint is currently redundant, because states are referenced within character references. However, this constraint simplifies application design, and occasionally (e. g., in dependency definitions) states are referenced without a character reference.

Note: the "*" at the end of the selector xpath refers to either StateReference (with @ref) or StateDefinition (with @id).</xs:documentation>
      </xs:annotation>
      <xs:selector xpath=".//u:StateDefinition"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <!-- The following is redundant after the decision to require all object ids to be unique within a document:
    <xs:unique name="CharacterStateKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Ensures that local as well as concept state keys are unique throughout the instance document. This is currently not used, but introduced to simplify possible future schema changes (enabling direct use of concept states in descriptions).</xs:documentation>
      </xs:annotation>
      <xs:selector xpath=".//u:StateDefinition"/>
      <xs:field xpath="@id"/>
    </xs:unique>
-->
    <xs:unique name="CharacterTree_Key">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">This identifies an entire character tree (i. e. not the nodes in the tree)</xs:documentation>
        <xs:documentation xml:lang="en-us">===== START of CharacterTree-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:CharacterTrees/u:CharacterTree"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <!--
		<xs:keyref name="CharacterTree_Keyref" refer="CharacterTree_Key">
			<xs:annotation>
				<xs:documentation xml:lang="en-us">(Currently no references to entire character trees exist in SDD 1.0).</xs:documentation>
			</xs:annotation>
			<xs:selector xpath="u:Dataset/u:X/u:X"/>
			<xs:field xpath="@ref"/>
		</xs:keyref>
-->
    <xs:unique name="CharacterTreeNode_Key">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Inner nodes ("Nodes/Node") have id-attribute and are referable, character leaves ("Nodes/Char") lack id-attribute and are not referable. ID-values must be unique across character trees (possibly in multiple datasets!).</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:CharacterTrees/u:CharacterTree/u:Nodes/u:Node"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="CharacterTreeNode_Keyref" refer="CharacterTreeNode_Key">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Inner nodes ("Nodes/Node") have id-attribute and are referable, character leaves ("Nodes/Char") lack id-attribute and are not referable.</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:CharacterTrees/u:CharacterTree/u:Nodes/u:Node/u:Parent|u:Dataset/u:CharacterTrees/u:CharacterTree/u:Nodes/u:Char/u:Parent"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="CharacterTreeNodeConcept_Keyref" refer="DescriptiveConceptKey">
      <xs:selector xpath="u:Dataset/u:CharacterTrees/u:CharacterTree/u:Nodes/u:Node/u:Concept"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="CharacterTreeCharacter_KeyRef" refer="CharacterKey">
      <xs:selector xpath="u:Dataset/u:CharacterTrees/u:CharacterTree/u:Nodes/u:Char"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="DescriptionKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of Description-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:CodedDescriptions/u:CodedDescription|u:Dataset/u:NaturalLanguageDescriptions/u:NaturalLanguageDescription">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">A joint key for CodedDescription or NaturalLanguageDescription elements.</xs:documentation>
        </xs:annotation>
      </xs:selector>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="CategoricalCharacter_Keyref" refer="CharacterKey_Categorical">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">References to the various derived character types require definitions of the same character type. This is achieved by corresponding key/keyref pairs for each character type.</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:CodedDescriptions/u:CodedDescription/u:SummaryData/u:Categorical | u:Dataset/u:CodedDescriptions/u:CodedDescription/u:SampleData/u:SamplingEvent/u:SamplingUnit/u:Categorical"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="QuantitativeCharacter_Keyref" refer="CharacterKey_Quantitative">
      <xs:selector xpath="u:Dataset/u:CodedDescriptions/u:CodedDescription/u:SummaryData/u:Quantitative | u:Dataset/u:CodedDescriptions/u:CodedDescription/u:SampleData/u:SamplingEvent/u:SamplingUnit/u:Quantitative"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="TextCharacter_Keyref" refer="CharacterKey_Text">
      <xs:selector xpath="u:Dataset/u:CodedDescriptions/u:CodedDescription/u:SummaryData/u:TextChar | u:Dataset/u:CodedDescriptions/u:CodedDescription/u:SampleData/u:SamplingEvent/u:SamplingUnit/u:TextChar"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="CharacterSequence_Keyref" refer="CharacterKey_Sequence">
      <xs:selector xpath="u:Dataset/u:CodedDescriptions/u:CodedDescription/u:SummaryData/u:Sequence | u:Dataset/u:CodedDescriptions/u:CodedDescription/u:SampleData/u:SamplingEvent/u:SamplingUnit/u:Sequence"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="BasedOnSample_Keyref" refer="SampleKey">
      <xs:selector xpath=".//u:BasedOnSample"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="CharacterState_Keyref" refer="CharacterStateKey">
      <xs:selector xpath=".//u:State | .//u:ToState | u:Dataset/u:Characters/u:CategoricalCharacter/u:Mappings/u:Mapping/u:From | u:Dataset/u:Characters/u:CategoricalCharacter/u:Mappings/u:Mapping/u:To">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Element name "State" is currently restricted to this type, but may later be used elsewhere for different purposes, requiring a more specific xpath. Currently State occurs in summary data, sample data, mapping and dependency definitions (OnlyApplicableIf, InapplicableIf).</xs:documentation>
        </xs:annotation>
      </xs:selector>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="Modifier_Keyref" refer="ModifierKey">
      <xs:selector xpath=".//u:Modifier"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="SampleKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of Sample-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:CodedDescriptions/u:CodedDescription/u:SampleData/u:SamplingEvent">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">A key to identify a specific sample. This is used when summary statistics are calculated from sample data that are also present in the dataset (compare the "BasedOnSample" element).</xs:documentation>
        </xs:annotation>
      </xs:selector>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:unique name="IdentificationKeyKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">This identifies an entire Identificationkey (i. e. not the nodes/steps in the key)</xs:documentation>
        <xs:documentation xml:lang="en-us">===== START of IdentificationKey-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:IdentificationKeys/u:IdentificationKey"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="IdentificationKey_Keyref" refer="IdentificationKeyKey">
      <xs:selector xpath="u:Dataset/u:IdentificationKeys/u:IdentificationKey/u:Leads/u:Result/u:Subkey"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="IdentificationKeyLeadKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Inner leads ("Leads/Lead") have id-attribute and are referable, result leads ("Leads/Result") may have id-attribute and are not referable. Results must be referable only in case of reticulation, but not in case of parent. ID-values must be unique across character trees (possibly in multiple datasets!).</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:IdentificationKeys/u:IdentificationKey/u:Leads/u:Lead"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:unique name="IdentificationKeyLeadKey_Reticulation">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Compare IdentificationKeyLeadKey, this one includes the Result@id nodes and is referenced for reticulation elements.</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:IdentificationKeys/u:IdentificationKey/u:Leads/u:Lead  | u:Dataset/u:IdentificationKeys/u:IdentificationKey/u:Leads/u:Result"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="IdentificationKeyLead_Keyref" refer="IdentificationKeyLeadKey">
      <xs:selector xpath="u:Dataset/u:IdentificationKeys/u:IdentificationKey/u:Leads/u:*/u:Parent"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:keyref name="IdentificationKeyLead_KeyrefReticulation" refer="IdentificationKeyLeadKey_Reticulation">
      <xs:selector xpath="u:Dataset/u:IdentificationKeys/u:IdentificationKey/u:Leads/u:Result/u:Reticulation"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="AgentKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of Agent-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:Agents/u:Agent"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="Agent_Keyref" refer="AgentKey">
      <xs:selector xpath=".//u:Agent"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="MediaObjectKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of MediaObject-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:MediaObjects/u:MediaObject"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="MediaObject_Keyref" refer="MediaObjectKey">
      <xs:selector xpath=".//u:MediaObject"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="AudienceKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of Audience-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:Audiences/u:Audience"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="Audience_Keyref" refer="AudienceKey">
      <xs:selector xpath=".//u:Audience"/>
      <xs:field xpath="@audience"/>
    </xs:keyref>
    <xs:unique name="GeographicAreaKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of GeographicArea-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:GeographicAreas/u:GeographicArea"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="GeographicArea_Keyref" refer="GeographicAreaKey">
      <xs:selector xpath=".//u:GeographicArea"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
    <xs:unique name="PublicationKey">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">===== START of Publication-related identity constraints ====</xs:documentation>
      </xs:annotation>
      <xs:selector xpath="u:Dataset/u:Publications/u:Publication"/>
      <xs:field xpath="@id"/>
    </xs:unique>
    <xs:keyref name="Citation_Keyref" refer="PublicationKey">
      <xs:selector xpath=".//u:Citation"/>
      <xs:field xpath="@ref"/>
    </xs:keyref>
  </xs:element>
  <xs:complexType name="Dataset">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Dataset itself is derived from Abstract object, as are the base types for which it contains collections.

The first elements (Repres., Links, RevisionData, Owner, IPRStatem.) are content metadata for the entire data set / data collection. If, e.g. in response to queries, data subsets are extractet from a larger base data set, these metadata are not required to be specific to each document, but may may describe the base set itself. Link uri should then refer to the base set using rel=BasedUpon, and the dataset-uri may contain a query URI (or be omitted).

If a history of the data collection
(revised or expanded in various
projects or at different institutions, aggregated from multiple sources)
is available, this may be reflected in the IPR statements and possibly in
the list of Owners.

Note: if a data set is an extract from a larger base set, it is recommended to use 'Link rel = BasedOn' to point to the complete data set. Note that this may enable indexing robots to index the entire base data set.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="OwnedAbstractObject">
        <xs:sequence>
          <xs:element name="Scope" type="ExtendedScopeSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The scope of the dataset

NOTE: This is the last metadata element of the dataset itself. The following elements contain object collections ('payload'):</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="TaxonNames" type="TaxonNameSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Taxon names used in the data set. Each object contains a name - either locally defined or representing an external resource defined in a linking mechanism and defines a local id attribute that may be referred to multiple times from within the data set.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="TaxonHierarchies" type="TaxonHierarchySet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Optional hierarchy (= tree, biology: taxonomy) of taxon classes defined above. A hierarchy may be incomplete, i. e. some TaxonName object may not be in the hierarchy. TaxonHierarchies may be locally defined or represent an external source.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Specimens" type="SpecimenSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Specimens (including ABCD.Units) are physical objects that have been collected or observed.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="TaxonOccurrences" type="VersionExtension" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(Extension point for future core ontology objects. This should include observations and organism interactions)</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="TaxonIdentifications" type="VersionExtension" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(Extension point for future core ontology objects)</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Geolocalisations" type="VersionExtension" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(Extension point for future core ontology objects. An occurrence may 
have multiple geolocalisations, especially later coordinate or grid estimates, adjustments for geo. area name changes etc. This is analogous to taxon identifications.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SDD-DescriptiveTerminology"/>
          <xs:group ref="SDD-DescriptiveData"/>
          <xs:element name="Agents" type="AgentSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Documentation of persons/organizations involved in the authoring, compiling, editing, etc. of the data set.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Publications" type="PublicationSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Publications used in the data set, defined through objects (= local or external link, see under Agents).</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="GeographicAreas" type="GeographicAreaSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Named geographical areas (continents, countries, cities, national parks, locally described places, etc.). An example of an external gazetteer referred to is the TDWG Geography standard.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="MediaObjects" type="MediaObjectSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Resource definitions containing links like URLs or actually embedding the resource (e. g. encoded images).</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Audiences" type="AudienceSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">An Audience is an extension of language (including dialect), with expertise (pupil, beginner, expert) and other parameters (policy makers, farmers, etc.)</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
        <xs:attributeGroup ref="language">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The language on dataset is required; if no language is known this should be explicitly stated (lang="und"). This value is inherited in all places where an xml:lang attribute is specified in the UBIF schema (on Label, Detail, etc.) if no other value is given there (i.e. this value must be interpreted as a dataset-wide default).</xs:documentation>
          </xs:annotation>
        </xs:attributeGroup>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
 <xs:annotation>
    <xs:documentation xml:lang="en-us">Unified Biosciences Information Framework (UBIF) XML schema. This schema provides core level extensions for first class object types.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Copyright © 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file UBIF_(c).xsd for authorship and licensing information.</xs:documentation>
  </xs:annotation>
  <xs:include schemaLocation="UBIF_CoreOntology.xsd"/>
  <xs:include schemaLocation="UBIF_LinneanCore.xsd"/>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Fundamental UBIF object types not imported from the schemata of other working groups:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="TechnicalMetadata">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Describes the providers and application/ script(s) that produced the current data set. The information provided here is intended to
a) Help with UDDI registration
b) facilitate debugging
@@ NOT CURRENTLY DONE: c) evaluate the quality and scope of archived data, especially whether the data contained in the document are complete or an excerpt from a larger data set.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Generator" type="DocumentGenerator">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Which tool did it? Metadata about the software (application, script, etc.) that provided or transformed the data.
Purpose: provide the ability to react to known deficits of generators, esp. where syntactically correct but semantically faulty data (misapplication of data elements, etc.) are generated.
</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="TechnicalContact" type="AgentString" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Who did it?
A technical contact is one to whom questions about accessibility of a provider or resource should be directed.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="AdministrativeContact" type="AgentString" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Who did it?
Administrative contacts are those to whom questions about data, IPR or restrictions on should be directed. The contact listed here are not necessarily those responsible for the content, especially if the dataset is provided by a different person/organization than those who have created it. For content contacts compare Dataset/RevisionData/ Creators. </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="Extensions" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="created" type="xs:dateTime" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">When was the current document or data stream created by the provider? Contains date and time, either as local time with timezone information or UTC (Universal time coordinates, recommended).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expires" type="xs:dateTime" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">After this date cached dataset data must be refreshed or considered archival-only. No guarantee is given that data do not change prior to this date: if the most current data are desired, a test for updates may be necessary.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="DocumentGenerator">
    <xs:attribute name="name" type="ShortString" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Name of the software application or package that generated this document. This may also be the name of a script that is not part of a larger application. In the case of large applications, the attribute 'routine' may provide additional detail. (~=atom:generator/text())</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="ShortString" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Version of the application that has generated this document (~=atom:generator/@version). This is not content version; compare RevisionData/Version.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="uri" type="xs:anyURI" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Optional globally unique name for a generator software (~=atom:generator/@uri).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="routine" type="ShortString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Optional string allowing a generating application to identify either one of multiple transforming routines (database code, xslt, etc.), or conditions under which a single routine may behave differently.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notes" type="LongString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Additional information about the generating application that is not part of the name or version. A copyright of the generating application may be is specified here, but this does not affect the content copyright of the data.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Taxon names (includes taxon in the biological as well as a more general sense):</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">(... these are defined in a separate LinneanCore file)</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Taxon class hierarchy (biology: taxon concepts):</xs:documentation>
  </xs:annotation>
  <xs:complexType name="TaxonHierarchyCore">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">TaxonHierarchy plus core level extensions.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="TaxonHierarchy">
        <xs:group ref="TaxonHierarchyCoreExtensions"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="TaxonHierarchyCoreExtensions">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Extensions of 
AbstractObject
specific to 
TaxonHierarchy</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Scope" type="TaxonomicScopeSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Scope of the taxon hierarchy, currently only citation 
and taxonomic scope 
(i.e. intended scope, 
not actual scope)</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="TaxonHierarchyType" type="TaxonHierarchyTypeEnum">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The taxon hierarchy supports taxonomic (order/family/genus etc.) and non-taxonomic (weed species, diseases, herb/shrub/tree) hierarchies. For many analytical purposes it is relevant whether a hierarchy is based on phylogenetic (= evolutionary) relatedness or whether it is an operational categorization.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Nodes" type="TaxonHierarchy_NodeSeq" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The tree structure of the taxon hierarchy is presented as an ordered list of nodes together with edges pointing to parent nodes. Inner nodes may have taxon name references or may be anonymous (esp. for phylogenetic analyses).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="SpecificExtension" minOccurs="0"/>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="TaxonHierarchy_NodeSeq">
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:sequence>
          <xs:element name="Node" type="TaxonHierarchyNode" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">An ordered list of nodes. The order defines the sequence of taxa at the same level. Both width- and breadth-first must be supported. The node/parent graph structure is limited to trees by means of identity constraints (unique/keyref).</xs:documentation>
            </xs:annotation>
            <xs:unique name="TaxonHierarchyNode_NoSelfReference">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">Ensures that Parent does not point to the id attribute of its own node. Note that cycles with a length of 2 still require external validation!</xs:documentation>
              </xs:annotation>
              <xs:selector xpath=". | u:Parent"/>
              <xs:field xpath="@id | @ref"/>
            </xs:unique>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TaxonHierarchyNode">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A node in a class hierarchy tree (biology: taxonomical hierarchy)

NOTE: part of the constraints on the tree are not yet validated:
Inner nodes may be anonymous, but terminal nodes must point to a taxon name.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Parent" type="TaxonHierarchyNodeRef" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ref. to an inner node of the current tree. Omitting this is interpreted as a reference to the root of the tree.</xs:documentation>
          <xs:documentation xml:lang="x-internal">Because every edge defines a new node, only few deviations from a true tree are possible. However, isolated cycles (node 1 with parent 2, node 2 with parent 1, not connected to root) can occur and require external validation to be prevented. 
Further indirect connection through multiple nodes referring to the same taxon name are possible. This may be prevented by appropriate xs:unique identity constraints, requiring in each taxon hierarchy, each name to occur only once.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="TaxonName" type="TaxonNameRef" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Reference to a taxon name. Inner nodes may be anonymous or identified as a higher taxon; terminal nodes should always point to a taxon name (requires external validation).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Synonyms" type="TaxonNameRefSeq" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">(The expression of synonyms may be essential for reports and to convey the concept of a taxon to information consumers.)</xs:documentation>
        </xs:annotation>
        <xs:unique name="TaxonHierarchyNode_UniqueSynTaxonNames">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">References to synonyms must be unique (i.e. the same name may not appear twice).</xs:documentation>
          </xs:annotation>
          <xs:selector xpath="u:TaxonName"/>
          <xs:field xpath="@ref"/>
        </xs:unique>
      </xs:element>
      <xs:group ref="Extensions" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="LocalInstanceID"/>
  </xs:complexType>
  <xs:complexType name="TaxonHierarchyNodeRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Refers to a node in a taxon hierarchy</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Specimens ('Unit' in ABCD, 'Object' in earlier versions of UBIF/SDD):</xs:documentation>
  </xs:annotation>
  <xs:complexType name="SpecimenCore">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Specimen plus core level extensions.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Specimen">
        <xs:group ref="SpecimenCoreExtensions"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="SpecimenCoreExtensions">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Extensions of 
AbstractObject
specific to 
Specimen</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:annotation>
        <xs:documentation xml:lang="en-us">@@ These are just the preliminary elements identified by SDD to be necessary as local extensions. 
A decision needs to be made, 
compare the DWC-based extensions presented in CoreExtensions_Unused! @@</xs:documentation>
      </xs:annotation>
      <xs:element name="TaxonName" type="TaxonNameRef" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Identification of specimen. The information may come from the service provider. If the service provider only provides a name, this must be compared with and if necessary added to the list of TaxonNames so that a TaxonName reference may be used here.
This may point to a higher taxon (family, order, or even "plantae") to indicate incomplete, broad identifications.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="IdentificationCertainty" type="IdentificationCertaintyEnum" default="IdentificationCertaintyUnknown" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Default is 'certain'; 'Abies cf. alba' would be recorded as 'uncertain'.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="IsPreservedInCollection" type="xs:boolean" default="true" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">False = object has not been collected and preserved (it may still be databased in an observation database and have an ExternalID!). The default for this element is true, i. e. if the element is missing the object has been collected/preserved.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Media (especially images, audio/video, but potentially also complex objects like html with images, pdf, etc.):</xs:documentation>
  </xs:annotation>
  <xs:complexType name="MediaObjectCore">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">MediaObject plus core level extensions.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="MediaObject">
        <xs:group ref="MediaObjectCoreExtensions"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="MediaObjectCoreExtensions">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Extensions of 
AbstractObject 
specific to 
MediaObject.
Note: the 'Caption' element is 
already covered in 
Representation/Detail 
role='caption' in the 
abstract object base type!</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Type" type="ResourceTypeEnum">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Type of media object, based on DCMI Type vocabulary 
(~= DC.Type, 1.1)</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice>
        <xs:element name="Source" type="URIRef">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">External source
referenced through
a href. Here media 
type is optional,
because resolution
usually will deliver it.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:sequence>
          <xs:element name="EncodedData" type="EncodedContent">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Optionally the full media object data may be embedded (as an alternative or in addition to defining a URI). Note: A resource like an image should be directly encoded, i.e. not wrapped into a MIME object first.

The data source may optionally be stored in the href attribute (in addition to EncodedData).</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:choice>
    </xs:sequence>
  </xs:group>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== For all objects in the core ontology, collections of type set are defined. These form the root-level collections in the Dataset object.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="TaxonNameSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="TaxonName" type="TaxonNameCore" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Biology: Object in a nomenclator</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TaxonHierarchySet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="TaxonHierarchy" type="TaxonHierarchyCore" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Biology: Taxonomic hierarchy, or arbitrary set of taxa.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SpecimenSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="Specimen" type="SpecimenCore" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Objects being observed or in a collection.
Specimens may be identified or
assigned to a taxon name as types.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AgentSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="Agent" type="Agent" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PublicationSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="Publication" type="Publication" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Printed or digital publication
(including database source)</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="GeographicAreaSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="GeographicArea" type="GeographicArea" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="MediaObjectSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="MediaObject" type="MediaObjectCore" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AudienceSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="Audience" type="AudienceCore" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
 <xs:annotation>
    <xs:documentation xml:lang="en-us">UBIF version of Linnean Core 0.2 (definitions inherited from LinneanCore 0.1.6, modified to correct problems and make use of UBIF common types, checked against TCS 1.0)</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Unfortunately, it proved not possible to directly use TCS types, partly because of the generous use of mixed content in TCS, which is generally avoided in UBIF, partly because the desire to reuse the UBIF publications/citation and agents types and objects (which in TCS are left undefined), and partly because of some minor problems detected in TCS. Note, however, that this structure remains fairly focussed on general name needs and does not attempt to include full nomenclature or concept-relationship information.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Copyright © 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file UBIF_(c).xsd for authorship and licensing information.</xs:documentation>
  </xs:annotation>
  <xs:include schemaLocation="UBIF_CoreOntology.xsd"/>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Taxon names ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Note: although 'taxon' may be used in a general sense as a named class, the extensions here cover primarily biological scientific (Linnean) names.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="TaxonNameCore">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">TaxonName plus core level extensions.

Note: Taxon names are not restricted to accepted names, it is also use to express Synonyms in the TaxonHierarchyNode type)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="TaxonName">
        <xs:sequence>
          <xs:group ref="TaxonNameCoreExtensions">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Extensions of AbstractObject
specific to TaxonName. 

Contains rank plus a structured form of taxonomic names (Genus/Higher taxon, rank, optional specific/infraspecific epithets, authors). Note that simply splitting into taxon name and authors does not work, because authors may be in the middle of the parts of the taxon name (e. g. in botanical autonyms). </xs:documentation>
            </xs:annotation>
          </xs:group>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="TaxonNameCoreExtensions">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Extensions of AbstractObject
specific to TaxonName. 

This may be further extended to support a structured form of taxonomic names (Genus/Higher taxon, rank, optional specific/infraspecific epithets, authors). However, note that simply splitting into taxon name and authors does not work, because authors may be in the middle of the parts of the taxon name (e. g. in botanical autonyms). Currently the development of the TDWG taxon names standard should be awaited first.

Note that Taxon names are not restricted to accepted names, it is also use to express Synonyms in the TaxonHierarchyNode type)</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="NomenclaturalCode" type="NomenclaturalCodesEnum" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The nomenclatural code governing the taxon name. Note that, e.g., a genus name may be validly used for different organisms under different codes.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Rank" type="TaxonomicRank" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">For biological taxonomic names: order, family, species, etc. Derived from an enumerated value list. This element needs to be interoperable; formatting often depends on specific ranks rather than on relative place in the hierarchy alone.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="CanonicalName" type="LinneanCanonicalTaxonName" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Canonical name enforcing strict inclusion of only nomenclatural information, i.e. not taxonomic hierarchy information with the exception of the necessary placements within Genus or Species. </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="CanonicalAuthorship" type="LinneanCanonicalTaxonAuthorship" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Canonical authorship of the name, optionally atomized</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="ConceptSuffix" type="CitationString" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">A part of the taxon name indicating either imprecise concept hints ('s. str.', 'p.p.', 's. l.', 'auct.', an informal or fomal according-to citation ('sec. Muell.', 'sensu Hagedorn, Sydowia 1998'). In the later case this may be made more precise by using the available attributes to add a local or uri reference to a publication.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Race" type="ShortString" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Race numbers, names, possibly other ranks not governed by a code (patho/bio/serovar).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="TaxonPlacement" type="TaxonNameRefSeq" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Additional hierarchical information which may be designed to be part of the name. Example: a name may be cited as "Cortinarius (subg. Phlegmacium) glaucopus s. l. (Cortinariaceae)". Here 'Cortinarius glaucopus' is canonical name, 's. l.' Concept suffix, and 'Phlegmacium' and 'Cortinariaceae' is additional hierarchical placement information.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="LinneanCanonicalTaxonName">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Canonical name of a taxon (normalized according to nomenclatural code rules, without non-required hierarchy elements like subgenus for a species, or more than one infraspecific epithet ('G. spex var. x  f. y').</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Simple" type="ShortString">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">A string containing the full canonical taxon name without authors.

The following name 'atomization' is optional:</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">(Choice 
between 
supra-
generic 
and genus, 
bi- or 
trinomial)</xs:documentation>
        </xs:annotation>
        <xs:element name="SupragenericName" type="ShortString">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Uninomial name of higher taxon down to (and excluding) the Genus.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:sequence>
          <xs:element name="Genus" type="TaxonString">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Genus itself (uninomial), or Genus part of bi- or trinomials as string (then optionally with a reference to the id of the exact Genus record).</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:choice minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(If present, this
creates a bi- or 
trinomial name. 
This is then a 
choice between 
infrageneric 
and specific/
infraspec. names)</xs:documentation>
            </xs:annotation>
            <xs:element name="InfragenericEpithet" type="ShortString">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">Infrageneric epithet is used *only* for infrageneric names itself. The choice to the left prevents using this  in combination with a species epithet; doing so would express taxonomic opinion that is redundant in a canonical name.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:sequence>
              <xs:element name="SpecificEpithet" type="TaxonString">
                <xs:annotation>
                  <xs:documentation xml:lang="en-us">Species epithet of specific (binomial) or infraspecific (trinomial) names as string. In the latter case the ref attribute may optionally refer to the id of the exact Species record (necessary for homonyms).</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="InfraspecificEpithet" type="ShortString" minOccurs="0">
                <xs:annotation>
                  <xs:documentation xml:lang="en-us">Infraspecific epithet of ranks governed by the code (subspecies down to subsubforma). If infraspecific epithet is missing, rank must be 'sp' (external validation required). Note: If multiple infraspecific epithets are present, all but the lowest ranking are redundant indications of hierarchy that is not part of a *canonical* name under the codes of nomenclature.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="CultivarNameGroup" type="ShortString" minOccurs="0">
                <xs:annotation>
                  <xs:documentation xml:lang="en-us"> The name of the Cultivar, Cultivar Group, grex, convar or graft chimera. Under the ICNCP. Just include here the string of the name. i.e. omitting single quotes around cultivar names, the word 'group' that denoting cultivar group (and which is language- dependent) and the '+'-sign in chimeras. These symbols are implicit in the rank of the name.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
          </xs:choice>
        </xs:sequence>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="LinneanCanonicalTaxonAuthorship">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">The Canonical citation (authorship of a taxon) includes only the authorship of the lowest ranking epitheton (to also include the authorship of the species for infraspecific taxa is not uncommon, but not recommended by the codes).</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Simple" type="LongString" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The full, code-appropriate author- team-plus-citation-string for the current name at this rank. Examples: 'L.'; '(L.) Smith &amp; Jones ex Brown, Green &amp; Black 1888'. Where atomized citation data exist, this text should be derived from them.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="BaseCitation" type="TaxonAuthorshipCitation" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The primary citation for the monomial or the lowest ranking epithet in bi- or trinomial names. For a recombined name this is the basionym citation, for a replacement/nom.nov. name the citation of the new, replacing name.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="BaseCitationBracketed" type="xs:boolean" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Indicates that brackets/parentheses are required around BaseCitation, i.e. the name is recombined or its status changed. Necessary because CombinationCitation may not have been recorded. Redundant if CombinationCitation is present, this should then be interpreted as 'true'.
In TCS 1.0 this is expressed as a choice between the 'Authorship' and 'BasionymAuthorship' elements.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="CombinationCitation" type="TaxonAuthorshipCitation" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The combining author(s) creating the new combination (= authors occurring after authors in brackets). Zoology often does not record this though the ICZN recommends that they should be included (Art.51G). Botany generally does and has priority rules to rule on homonymic combinations.
External validation: This element should not occur when BaseCitation is missing.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="TaxonAuthorshipCitation">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Combines a taxonomic authors with a publication citation (= publication plus location like page).</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Authors" type="AgentStringSeq">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Nomenclatural authors (i.e. excluding sensu/sec. authors)

Following TCS 1.0, sanctioning in fungi is expressed by treating the ':'-literal in a separate Agent element. Similarly, name-validation may be included and the 'ex'-literal treated the same way (note: bot./zoo. confusion exists whether validated or validating authors are 'ex-authors'). Overloading of the Agent element with these special semantics reduces the complexity of the model.
(Agent element seq. in instance documents is informative!)</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Citation" type="CitationString" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">String containing informal free-form publication text, optionally identified as an exact publication object plus location-attribute (page number etc.)</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Date" type="CompositeDate" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The actual publication date (usually only year, sometimes month relevant for taxonomic priority). Necessary if full Citation (element above) is unknown, or if the citation data referenced through uri are unable to differentiate between year-of and year-on (year publication claims to have been published in).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="AuthorTeamsDiffer" type="xs:boolean" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Flag to mark that taxon authors differ from authors of the publication in which the taxon was published (perhaps only in sequence). Machine-comparison of author teams is difficult: not only must the sanctioning and validation cases be handled, but also taxon authors are in botany usually expressed using standardized abbreviations, whereas publication authors (optionally added after 'in') should be spelled out.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
 <xs:annotation>
    <xs:documentation xml:lang="en-us">This file will be included into the UBIF/SDD integration schema 'SDD.xsd' (SDD uses the same namespace as UBIF).</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Copyright © 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file SDD_(c).xsd for authorship and licensing information.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Enumerations to support interoperability:</xs:documentation>
    <xs:documentation xml:lang="en-us">Internal formatting note: Annotations of individual enumerated values should be written as "short label" + " -- " + "detailed information" or "[abbreviation]" + " -- " + "short label" + " -- " + "detailed information". An xslt script transforms such schema annotations into a data document that can directly be used in user interfaces.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Please read: An important feature of this schema file is that these enumerations may be turned into data, many of them including extra specification data. Please see UBIF-EnumerationTools for further information. Using the data files in application development rather than hardcoding enumerations in code enables simple adaption to future versions of UBIF.</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="NatLangPhraseRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Enumerated value expressing the kind of phrase or "wording fragment" used to create natural language reports (especially object descriptions). These are currently highly constrained, but either additional values or free extensibility (by union of this type with xs:anyURI) are expected for future releases of UBIF.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Before">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[before] -- Phrase before contained elements; or single phrase -- Free-form text that is being output in natural language reports before the natural language phrases for the children (if any). Descriptive terms with children are, e. g., modifiers, statistical measures, or characters/concepts; terms without children are, e. g., characters states and status values.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="After">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[after] -- Phrase after contained elements -- Free-form text output in natural language reports for objects with children (= contained objects) after the wording for the children. In the case of a character in an object description this is the wording after all states, or numerical values (including the measurement unit if present).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Delim">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[delim.] -- Default delimiter phrase between child obj. -- Free-form text output in natural language reports between multiple child objects. Examples: ', ' (i. e. comma). Special delimiters may be defined for the delimiter in front of the last element and the case of exactly two child objects. Example: ', '.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LastDelim">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[delim.] -- Delimiter phrase between two last child obj. -- Free-form text output in natural language reports before the last child object (i.e. between the second-but-last and the last). Examples: en-US: ', or ', de: ' oder ' (note comma and leading/trailing blanks!). If missing, the default delimiter is used. If defined, the special 2-obj.-delimiter is preferred over this for the case of only two child objects.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Exactly2">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[bw. 2] -- Delimiter phrase between exactly 2 child obj. -- Free-form text output in natural language reports between children when there are exactly two children. If missing, the default 'delim' wording definitions will be used. Example: ' or ' in US-English.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CharacterTreeRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines the intended roles that a designer may assign to a character tree (list of enumerated values to support application interoperability). Note: no values for designing the terminology are given; in the use cases all character trees are available.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="DescriptionEditing">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">For description editing -- Setting this value in a character tree is a recommendation to applications with a user interface to offer this tree for editing the description data set (the application may, however, enable the user to select any character tree).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="InteractiveIdentification">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">For interactive identification -- Setting this value in a character tree is a recommendation to applications with a user interface to offer this tree for interactive identification.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="TerminologyReporting">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">For terminology reporting -- Setting this value in a character tree is a recommendation to applications to use this for creating a report of the character terminology. (Note that no TerminologyEditing value is defined; all character trees should be available when designing the terminology. However, the tree marked as TerminologyReporting may be used as the initial editing view.)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NaturalLanguageReporting">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">For natural language reporting -- Setting this value in a character tree is a recommendation to applications to offer this tree for natural language reporting.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Filtering">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">For filtering -- Setting this value in a character tree is a recommendation to applications to offer this tree for filtering purposes. Some trees are explicitly (separately) typed as being intended exclusively for filtering/subset definition; but many trees are useful for filtering purposes.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Management">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">For management purposes -- Setting this value in a character tree is a recommendation to applications to offer this tree not to normal identification or editing users, but only to users involved in managing data collection or terminology. An example of such trees are trees created to support concept nodes for modifier definition, dependency rules, or global states.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="RatingContextEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines the topic of a concept/character rating.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="ObservationConvenience">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Convenience -- How conveniently can be character be observed? This may includes a measure of cost of equipment and expendables (such as chemical reagents). Convenience should be rated relative to other methods required for identifications within a taxonomic group, i. e. if microscopic methods are always necessary in taxon group, microscopic characters may be considered convenient within this group. Also, a character may be convenient is one group, but inconvenient in another.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Availability">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Availability -- How available is the character or concept for identification? For example, ratings would be low if a character is available only during a short time in the life of an object, or only expressed with low frequency in populations.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Repeatability">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Repeatability -- How reliable and consistent are repeated measurements or scorings of the character by different observers and on different objects? This may include both variability of values (frequency of polymorphisms) and variability in how the observations are interpreted. It depends both on precision (quality of being reproducible) and accuracy (nearness to the true value).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CostEffectiveness">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Cost-Effectiveness -- How reliable and consistent are repeated scorings of the character by different observers and on different objects? This may include both variability of values (frequency of polymorphisms) and variability in how the observations are interpreted. It depends both on precision (quality of being reproducible) and accuracy (nearness to the true value).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PhylogeneticWeighting">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Phylogenetic weighting -- A weighting factor rating the relative weight of a character for the purpose of phylogenetic analysis.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RequiredExpertise">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Required expertise -- The user is expected to have this expertise level at least.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DataOriginEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines the origin of data that may have been entered, calculated, aggregated or inherited</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="OriginalData">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Original data, directly entered by a machine or human agent -- These are the original data all other cached data (Origin other than 'OriginalData') are based upon.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Calculated">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Calculated data, based on other data using a calculation rule -- Examples: a ratio calculated from other characters, a mean calculated from a sample that is available under SampleData/Sample (if a mean is calculated from data no longer available, it would be recorded as 'OriginalData').</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Mapped">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Mapped data, based on other data using a mapping definition -- Mapping examples are numeric to categorical, or from fine-grained categorical to coarse-grained categorical.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Aggregated">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Aggregated data, derived from data further down in the hierarchy -- This applies both to aggregating data from specimens or other individual to classes (taxa), as well as aggregating from lower classes/taxa to higher classes/taxa. (= e.g. 'Compile from below' in BioLink). In the case of descriptive summary data the relevant hierarchy is the taxon hierarchy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Inherited">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Inherited data, derived from data further up in the hierarchy -- In the case of descriptive summary data the relevant hierarchy is the taxon hierarchy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ModifierClassEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines a subset of possible modifier classes. Used only on those modifiers that need to be typed to achieve application interoperability (especially when modifier specifications add a value-based interpretation for a modifier, like frequency or certainty values). More values may be added to this enumeration in the future.</xs:documentation>
      <xs:documentation xml:lang="en-us">Technical note: The "Proportion values" mentioned in several annotation descriptions refer to Modifier/Specification/ProportionValueRange.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Frequency">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Frequency modifer --  Proportion values specify a frequency range.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Certainty">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Certainty modifer -- Proportion values specify a certainty range.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Seasonal">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Seasonal modifer -- Proportion values specify a season of the year. The proportion value 0 is interpreted as day 1, the proportion value 1 as day 365 of the year.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Diurnal">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Diurnal modifer -- This refers to parts of the day (24 h clock, i.e. including events that might strictly be called 'nocturnal'). Proportion values specify a time of the day. The proportion values 0 and 1 are both to be interpreted as midnight. Example: A modifier "in the morning" may be specified as '0.25-0.375'.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="TreatAsMisinterpretation">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Treat as misinterpretation -- The current modifier becomes one of a special class of misinterpretation modifiers. States to which such modifiers are added are known to be intentionally wrongly scored to accomodate known misunderstandings of the character under study. Example: dogwood bracts looking like petals, and petal scored as 'white (by misinterpretation)'. - With regard to (not misinterpreted) data, both frequency and certainty may be interpreted as 0 to 0, i. e. not occurring, certainly false.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OtherModifierClass">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Other modifier -- All other modifers for which specifications are not yet defined. Examples are developmental, absolute and relative spatial modifiers, or modifiers of degree.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="UnivarStatMeasureClassEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">When mapping numerical ranges to categorical states (as in a histogram), several methods which statistical measures are used for the mapping are possible. Using the central value compares a point with the mapping range, whereas using ranges or extremes results in a comparison of two kind of ranges for overlap. Only the central value method can guarantee an unambiguous partitioning into categories. However, the ranges or extremes methods may be desirable because of their improved error tolerance.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="CentralMeasure">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Central measure -- The first central measure encountered (mean, median, mode) is used as the basis of comparison. If none is found, but ranges or extremes are present, a central value is calculated based on the these.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Ranges">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ranges -- Any ranges that are not the extremes (quantile, percentile, confidence interval, mean plus/minus s.d., etc.) is attempted to use for comparison. If none is found, Extreme values are used.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Extremes">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Extremes -- The extreme range values (= minimum and maximum) are used as the basis of comparison.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="StateCollectionModelEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Used in descriptive data (not in terminology): Collections of states in instance documents may be ordered (sequence) or unordered (set), and may be connected with 'and', 'or', 'with', or 'between'. Since set/sequence and operators are dependent on each other, the two aspects are combined into a 'model' enumeration</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="OrSet">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Unordered set of states, combined with 'or' -- Multiple states scored for a character in a description form a set. The order of states has no special meaning and may be changed. In natural language output the states should be combined with 'or' to express that in individual objects (that belong to the class that is being described), the states may occur together or alone.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OrSeq">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ordered sequence of states, combined with 'or' -- Multiple states scored for a character in a description form a sequence, i. e. the state order carries some semantics and should be preserved in output. The sequence semantics is not explicitly defined, but intelligible to human consumers and presumably relates to some concept of relevance or importance. In natural language output the states should be combined with 'or' to express that in individual objects (that belong to the class that is being described), the states may occur together or alone.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="AndSet">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Unordered set of states, of states, combined with 'and' -- Multiple states scored for a character in a description form a set. The order of states has no special meaning and may be changed. In natural language output the states should be combined with 'and' to express that in any individual object (that belong to the class that is being described), the states will always occur together. Example: two colors that occur together in a pattern.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="AndSeq">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ordered sequence of states, combined with 'and' -- Multiple states scored for a character in a description form a sequence, i. e. the state order carries some semantics and should be preserved in output. The sequence semantics is not explicitly defined, but intelligable to human consumers and presumably relates to some concept of relevance or importance. In natural language output the states should be combined with 'and' to express that in any individual object (that belong to the class that is being described), the states will always occur together. Example: a black part with small red markings, is more appropriately described as 'black and red' than 'red and black'.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WithSeq">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Primary together with secondary states -- This is a special case of AndSeq, and in many circumstances (except natural language generation) may be treated as AndSeq. Example: "Green with brown" (often this may be two characters, e. g. base color and dot color). All states except for the first are considered secondary.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Between">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Intermediate value between states -- True value lying intermediate between (usually two) states. Example: "Between oval and elliptic" = "Oval to elliptic".</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MolecularSequenceTypeEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Currently limited to 'Nucleotide' and 'Protein', but future SDD versions may expand this after appropriate discussion. A distinction between nucleotide type-subtypes RNA/DNA is currently not considered necessary; the symbols U (RNA) and T (DNA) should be considered equal for the purpose of analysis.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Nucleotide">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Nucleotide sequence -- This includes both DNA and RNA sequences.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Protein">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Protein  sequence</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
 <xs:annotation>
    <xs:documentation xml:lang="en-us">Variant of the primary schema file to be used for exchanging and validating objects outside of the document context defined in the main schema. Any first class object defined in UBIF/SDD may occur here either as an immediate root element, or in any position inside the "Objects" collection. This schema may also be used when validating objects used as extensions of other schemata.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Copyright © 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file SDD_(c).xsd for authorship and licensing information.</xs:documentation>
  </xs:annotation>
  <xs:include schemaLocation="SDD.xsd"/>
  <xs:element name="Objects">
    <xs:complexType>
      <xs:choice maxOccurs="unbounded">
        <xs:any namespace="##any" processContents="strict"/>
      </xs:choice>
    </xs:complexType>
  </xs:element>
  <xs:element name="Specimen" type="SpecimenCore"/>
  <xs:element name="TaxonName" type="TaxonNameCore"/>
  <xs:element name="TaxonHierarchy" type="TaxonHierarchyCore"/>
  <xs:element name="DescriptiveConcept" type="DescriptiveConcept"/>
  <xs:element name="Modifier" type="ModifierDef"/>
  <xs:element name="CategoricalCharacter" type="CategoricalCharacter"/>
  <xs:element name="QuantitativeCharacter" type="QuantitativeCharacter"/>
  <xs:element name="TextCharacter" type="TextCharacter"/>
  <xs:element name="SequenceCharacter" type="MolecularSequenceCharacter"/>
  <xs:element name="CharacterTree" type="CharacterTree"/>
  <xs:element name="NaturalLanguageDescription" type="NaturalLanguageDescription"/>
  <xs:element name="CodedDescription" type="CodedDescription"/>
  <xs:element name="IdentificationKey" type="StoredKey"/>
  <xs:element name="Agent" type="Agent"/>
  <xs:element name="Publication" type="Publication"/>
  <xs:element name="GeographicArea" type="GeographicArea"/>
  <xs:element name="MediaObject" type="MediaObjectCore"/>
  <xs:element name="Audience" type="AudienceCore"/>
  <xs:element name="TechnicalMetadata" type="TechnicalMetadata"/>
 <xs:annotation>
    <xs:documentation xml:lang="en-us">This file will be included into the UBIF/SDD integration schema 'SDD.xsd' (SDD uses the same namespace as UBIF).</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Copyright © 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file SDD_(c).xsd for authorship and licensing information.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Due to problems with key/keyrefs when using two namespaces (see documentation on the SDD WIKI: http://wiki.tdwg.org/twiki/bin/view/SDD/UBIFDesignRequirements), the SDD schema is based on the UBIF namespace, and thus uses include rather than import!</xs:documentation>
  </xs:annotation>
  <xs:include schemaLocation="UBIF_CoreExtensions.xsd"/>
  <xs:include schemaLocation="SDD_EnumLib.xsd"/>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== UBIF insertion groups ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">The two SDD-groups are used inside the UBIF top-level Datasets/Dataset structure to define the object collections used by SDD</xs:documentation>
  </xs:annotation>
  <xs:group name="SDD-DescriptiveTerminology">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines the operational terminology (concepts, characters, states, etc.)
in which descriptions are expressed.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:annotation>
        <xs:documentation xml:lang="en-us">These terms 
are defined 
by biol. 
specialist(s) 
and used in 
coded/nat. 
lang. 
descriptions 
or identific.
keys.</xs:documentation>
      </xs:annotation>
      <xs:element name="DescriptiveConcepts" type="DescriptiveConceptSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Descriptive concepts (properties, object parts, observation methods, etc.) define an optional ontology for descriptions. In contrast to characters, concepts can not be scored in descriptions. - Reusable states and char. dependencies are expressed here as well. </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Characters" type="CharacterSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Depending on their type, characters define categorical states, quantitative measures, free-form text, etc. 
Characters are realized (or operationalized) concepts that are used in descriptions. In software, characters define variables that hold data in taxon descriptions. Example: 'leg' may be a concept, 'leg number (as integer number)' a character, '6' the character data in a description.
Characters are defined in an unordered flat list. These may be ordered or structured through CharacterTrees defined below.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="CharacterTrees" type="CharacterTreeSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Character trees arrange concepts and characters. They may also be used to define flat char. subsets for filtering purposes.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:group name="SDD-DescriptiveData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Describes individuals (specimens) or classes (taxa) using the terms defined in the operational terminology (concepts, characters, states, etc.).</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="NaturalLanguageDescriptions" type="NaturalLanguageDescriptionSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Authored or auto-generated free-form descriptions, which may be completely or partially marked-up with elements similar to those in coded descriptions.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="CodedDescriptions" type="CodedDescriptionSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Largely language-independent descriptions controlled by Terminology. Both coded and nat. lang. may describe either abstract classes (taxa, diseases, etc.) or physical objects (individual specimens).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="IdentificationKeys" type="IdentificationKeySet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Dichotomous or polytomous (multifurcating)
authored keys (incl. legacy data)</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== For all first-class objects in SDD, collections of type set are defined. These form root-level collections in the Dataset object.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="DescriptiveConceptSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">(The element 
sequence in 
instance 
documents 
is not 
informative!)</xs:documentation>
          </xs:annotation>
          <xs:element name="DescriptiveConcept" type="DescriptiveConcept" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CharacterSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:choice maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">(Hint: Choice is 
equivalent to class
polymorphism,
derived from same
base type.)
(Note: The 
element 
sequence in 
instance 
documents 
is not 
informative!)</xs:documentation>
          </xs:annotation>
          <xs:element name="CategoricalCharacter" type="CategoricalCharacter"/>
          <xs:element name="QuantitativeCharacter" type="QuantitativeCharacter"/>
          <xs:element name="TextCharacter" type="TextCharacter"/>
          <xs:element name="SequenceCharacter" type="MolecularSequenceCharacter"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CharacterTreeSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="CharacterTree" type="CharacterTree" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NaturalLanguageDescriptionSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="NaturalLanguageDescription" type="NaturalLanguageDescription" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Note: If all coded markup except the Text content is removed, the original natural language text description can be recovered without changes (lossless).</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CodedDescriptionSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="CodedDescription" type="CodedDescription" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Coded descriptions do have a label ('title', 'DELTA item name'). Where not available, the string value of the taxon name may be inserted here.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="IdentificationKeySet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="IdentificationKey" type="StoredKey" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(Note: Identification keys may also be created dynamically based on data in terminology and descriptions. These keys are intended to represent only manually authored keys, whether from capturing legacy data or newly designed.)</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== TERMINOLOGY START ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">DescriptiveConcepts, Characters and dependent objects (states, modifiers, statistical measures)</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">1. a) DescriptiveConcept definitions. Note: relations between concepts may be defined in the operational character tree. Independent ontologies of concepts may be created through Link rel=Subclass etc. Another plan for the future is to allow defining concepts relations inside characters.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="DescriptiveConcept">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">DescriptiveConcepts may be basic
properties (color, shape,
texture), structural types
(fruit types), methods
(naked eye, hand lens,
microscope) or other
hierarchical generalizations that can be applied to characters
(e. g., relative region: tip
versus base of structure)

Note that a number of ontological relations between concepts may be expressed using the general link structure of the base type (subclass, part of, etc.).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject">
        <xs:sequence>
          <xs:element name="Modifiers" type="ModifierSeq" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A set of modifier values of the same modifier concept. Examples: Certainty ('perhaps', 'probably', 'almost certainly'), frequency (usually, rarely, etc.), spatial (at base, at tip), seasonal (in spring, in winter), developmental (when young, senescent), manner, degree, intensity (strongly, weakly'), approximation (ca., roughly). Modifier concepts may be freely created. Some concepts, however, are expressed using a controlled vocabular in 'Modifier/ ModifierClass' to provide application interoperability.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="ConceptStates" type="ConceptStateSeq" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A set of state definitions tied to the part (e. g., for fruit: capsule, berry, nutlet, ...), property (e. g., for color: red, green, ..., for shape: round, ovate, ...), method, etc. To be used in descriptions, concept states must be referenced using a StateReference in a specific character first.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DescriptiveConceptRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Refers to a concept node</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DescriptiveConceptRefSeq">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">(A sequence of references to a descriptive concepts)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:sequence>
          <xs:element name="DescriptiveConcept" type="DescriptiveConceptRef" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Inner classes of DescriptiveConcept. ModifierSeq, ConceptStateSeq, and RecommendedMeasureSeq are second-class objects embedded in first class objects.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="DependencyRules">
    <xs:sequence>
      <xs:element name="OnlyApplicableIf" type="CharacterStateRefSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">If at least one state is defined in this rule, in a given description the characters below this concept node are inapplicable unless any of the listed controlling states is present.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="InapplicableIf" type="CharacterStateRefSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">If at least one state is defined in this rule, in a given description the characters below this concept node are inapplicable when any of the listed controlling states is present.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="ModifierSeq">
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Sequence of 
elements
should be 
preserved
(may be 
presentational
or semantical,
see attribute).</xs:documentation>
          </xs:annotation>
          <xs:element name="Modifier" type="ModifierDef" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Modifiers modify categorical states or statistical measures in descriptions. In nat. language reports, modifiers from the same modifier concept are combined with 'or', modifiers from different group are concatenated (example: 'frequently weakly or strongly ...'). Modifier order within a concept may be semantic or presentational (see attribute). 

Modifiers are defined for the entire project. To guide data entry, modifier sets may be recommended through Character tree node, InheritableDefinitions, RecommendedModifiers. 

Note: In the case of frequency and certainty, in addition to referring to the categorical values defined here, exact quantitative values may be expressed in description data.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="ordered" type="xs:boolean" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">= 'Modifiers are ranked'. If true, the sequence of modifier elements in instance documents is semantically meaningful (as in: 'weakly, moderately, 'strongly'). If false the sequence is intended for display purposes only.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ConceptStateSeq">
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:sequence>
          <xs:element name="StateDefinition" type="ConceptStateDef" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The definition of concept states is identical to the local definition of states within a character. Using concept states simplifies the management of terminology and improves data analysis (states from different characters can be compared if they refer to identical concept states).</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RecommendedMeasureSeq">
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:sequence>
          <xs:element name="StatisticalMeasure" type="UnivarStatMeasureElaboration" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">In addition to listing measures, these elaborations provide for improved report generation (wording, value formatting). 

Note: Statistical summary measures applicable to ordinal or nominal data (min, median, mode, etc.) are not supported; they can easily be calculated ad-hoc from the frequency distributions of categorical states which are supported.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">1. b) Character tree definitions, references (plus internal types)</xs:documentation>
  </xs:annotation>
  <xs:complexType name="CharacterTree">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines an entire character tree
(which may be a tree or a single tree node containing a flat list)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject">
        <xs:sequence>
          <xs:element name="Scope" type="TaxonomicScopeSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Scope of character tree, currently only taxonomic scope is supported.</xs:documentation>
            </xs:annotation>
            <xs:unique name="CharTreeScope_UniqueScopeRef">
              <xs:selector xpath="u:*"/>
              <xs:field xpath="@ref"/>
            </xs:unique>
          </xs:element>
          <xs:element name="DesignedFor" type="CharTree_DesignedForSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Usage of concept tree that is intended by its designers; constrained to a controlled vocabulary to support application interoperability. Trees without a role are not normally visible to consumers of descriptive data. Regardless of its role, all trees are visible when designing the terminology.</xs:documentation>
            </xs:annotation>
            <xs:unique name="CharacterTree_UniqueDesignedFor">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">For each tree, each enumerated Role value may be listed only once.</xs:documentation>
              </xs:annotation>
              <xs:selector xpath="u:Role"/>
              <xs:field xpath="."/>
            </xs:unique>
          </xs:element>
          <xs:element name="ShouldContainAllCharacters" type="xs:boolean" default="false" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">True if the intention of the designer of a concept tree is that all characters should be included in the tree. A terminology editing application may issues warnings about missing characters or directly offer inserting newly created characters in all such trees.</xs:documentation>
              <xs:documentation xml:lang="en-us">Not validated by xml schema; subject to external validation!</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Nodes" type="CharTree_NodeSeq">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The tree structure is 
presented as an 
ordered list of nodes 
together with edges 
pointing to parent 
nodes.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CharTree_NodeRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Refers to a node in the character tree</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CharTree_NodeSeq">
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:choice maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">An ordered list of nodes with optional concepts (inner or terminal) plus character references (terminal only). Order is significant for elements with the same Parent node reference; order of elements with different parents may be ignored. Both width- and breadth-first must be supported.
The node/parent structure is limited to trees by means of identity constraints (key/keyref).</xs:documentation>
          </xs:annotation>
          <xs:element name="Node" type="CharTree_Node" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Nodes optionally pointing 
to a descriptive concept.</xs:documentation>
            </xs:annotation>
            <xs:unique name="CharTreeNode_NoSelfReference">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">Ensures that Parent does not point to the id attribute of its own node. Note that cycles with a length of 2 still require external validation!</xs:documentation>
              </xs:annotation>
              <xs:selector xpath=". | u:Parent"/>
              <xs:field xpath="@id | @ref"/>
            </xs:unique>
          </xs:element>
          <xs:element name="CharNode" type="CharTree_Character" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Character references pointing to non-char. nodes in the tree. CharacterNodes are necessarily leaf nodes, because nothing can refer to them.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CharTree_AbstractNode">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Inner nodes (or terminal nodes if no characters follow)</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Parent" type="CharTree_NodeRef" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ref. to an inner, non-character node (Nodes/Node) of the current char. tree. Omitting this is interpreted as a reference to the root of the tree.</xs:documentation>
          <xs:documentation xml:lang="x-internal">Because every edge defines a new node, only few deviations from a true tree are possible. However, isolated cycles (node 1 with parent 2, node 2 with parent 1, not connected to root) can occur and require external validation to be prevented. </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="NaturalLanguageGroup" minOccurs="0"/>
      <xs:element name="DependencyRules" type="DependencyRules" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Dependency rules define whether in a given description a character may contain data or is expected to be inapplicable. This facilitates data validity checks and advises producers and consumers about expected presence of character data. The states listed in the following rules are controlling states, the controlled characters are all characters below this node. Rules for individual characters (rather than a set) can be defined in the terminal nodes. Rules are defined for a dataset, but evaluated within a given description. - This automatically applies to all characters below this node!</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="RecommendedModifiers" type="DescriptiveConceptRefSeq" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The modifiers contained in the listed modifier concepts are considered applicable to all characters placed in the current branch of the concept tree. In descriptions, all modifiers are principally valid in all characters. However, editing tools may desire to offer only these recommended modifiers for new data.
(External validation: Only concepts that do contain a list of modifiers in DescriptiveConcept/ Modifiers should be referenced here.) - This automatically applies to all characters below this node!</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="RecommendedMeasures" type="RecommendedMeasureSeq" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">A set of univariate statistical measures (e. g., mean, min, max, s. d., sample size) considered applicable to all quantitative (sic!) characters placed in the current branch of the concept tree.
In descriptions, all measures are valid in all quant. characters. However, editing tools may desire to offer only the recommended measures for new data. - This automatically applies to all characters below this node!</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="Extensions"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CharTree_Node">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Inner nodes (or terminal nodes if no characters follow).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CharTree_AbstractNode">
        <xs:sequence>
          <xs:element name="DescriptiveConcept" type="DescriptiveConceptRef" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Reference to a general descriptive concept ("leaf", "leg", "microscopical", "length"). Omitting a concept will result in an unlabeled node.
Note: Relations between concepts in the tree (part-of, kind-of, property-of) may be expressed inside DescriptiveConcept objects, using the generic Link element with rel=PartOf, SubclassOf, PropertyOf. This information may then be inherited in the char. tree.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attributeGroup ref="LocalInstanceID"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CharTree_Character">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A character reference, creating a terminal tree node (this has no id attribute, so it can never be an inner node)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CharTree_AbstractNode">
        <xs:sequence>
          <xs:element name="Character" type="CharacterRef">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Reference to a character, creating a terminal node ('leaf') in the tree.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Inner classes of CharacterTree and CharTree_Node:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="CharTree_DesignedForSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="Role" type="CharacterTreeRoleEnum" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Important roles are InteractiveIdentification, NaturalLanguageReporting, or Filtering.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">2. --- Character definitions (characters = data recording and analysis variables, depending on observed part, property, and observation or measurement methodology)</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">a) Abstract base type and derived types to be used in instance documents.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="AbstractCharacterDefinition" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines a character in the 
terminology. Abstract base 
type, one of the 
extensions below must 
be used in instance 
documents</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CategoricalCharacter">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Derived from AbstractCharacterDefinition to be used in instance documents (non-abstract type).

Categorical data include nominal and ordinal data (DELTA types UM/OM and NEXUS types). Other terms for categorical data in statistics are 'qualitative data' or 'attributes'. The term 'attribute' has been avoided in SDD because it has different definitions in statistics, programming, databases, DELTA, etc. Both 'qualitative' and 'attribute' are ambiguos as to whether ordinal/ ranked variables are in- or excluded.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharacterDefinition">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Extension of the 
common character 
properties with those
specific to categorical 
data (= 'states').</xs:documentation>
          </xs:annotation>
          <xs:element name="States" type="CharacterStateSeq">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Categorical values expressing either naturally discontinuous states (mostly related to counts) or categories defining a partioning of a continuous range. Examples: colors (blue, red) or shapes (round, ovate).

Note: In DELTA, separate char. have to be defined for quant./cat. data, but either type can be used as a text char. without definition. SDD does supports free-form notes on quant./cat. data, but requires a separate char for text replacing rather than extending other data. In cases where a long list of categories is supplemented by a free-form text (like: 'other, please specify'), this may be inconvenient. Considering the analytical problems (descriptions sharing some 'unconstrained text state' require other comparison functions than normal states) this seemed to be the cleanest solution. The relationship between quant., cat. and unconstrained text data for one char. concept (like tree height) can be expressed in character trees.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Mappings" type="CategoricalCharMappingSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Mappings between categorical states (e. g., subovate may be mapped to ovate to simplify identification choices).</xs:documentation>
            </xs:annotation>
            <xs:unique name="CategoricalStateMappings_UniqueFromPlusTo">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">Ensures that the combination of From and To is unique in this scope (one set of mappings).</xs:documentation>
              </xs:annotation>
              <xs:selector xpath="u:Mapping"/>
              <xs:field xpath="u:To/@ref"/>
              <xs:field xpath="u:From/@ref"/>
            </xs:unique>
          </xs:element>
          <xs:element name="Assumptions" type="CategoricalCharAssumptions" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Especially including a more detailed measurement scale.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QuantitativeCharacter">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Derived from AbstractCharacterDefinition to be used in instance documents (non-abstract type)

Quantitative data include data like the DELTA types IN/RN. They are not supported by NEXUS.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharacterDefinition">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Extension of the 
common character 
properties with those
specific to numerical
measurements</xs:documentation>
          </xs:annotation>
          <xs:element name="Assumptions" type="QuantitativeCharAssumptions" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Especially including a more detailed measurement scale.
---
Note: Unlike the states in categorical characters, the applicability of statistical measures to a character is not defined in the character. Any measure used in a description constitutes valid information. However, a list of recommended measures for sets of characters may be defined in concept nodes.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Mappings" type="QuantitativeCharMappingSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Mappings of numerical 
ranges to categ. states.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="MeasurementUnit" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A measurement unit (mm, inch, kg, °C, m/s, etc.) or dimensionless scaling factor (such as '%') applying to all values of this character. If a Default/MeasurementUnitPrefix is defined (see below), this must be entered without a prefix (e. g., 'm' instead of 'mm').
(Measurement units apply only to values plus those statistical measures not marked as IsDimensionless='true'.)</xs:documentation>
              <xs:documentation xml:lang="x-internal">Note: "International Standard ISO 31 (Quantities and units), 1992 may be relevant here, but seems to be not available online. Printed version: ISO Standards Handbook: Quantities and units. 3rd ed., International Organization for Standardization, Geneva, 1993, 345 p., ISBN 92-67-10185-4, 182.00 CHF.

A useful online resource is http://hem.fyristorg.com/ojarnef/fys/ metric-units-comp.txt</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:sequence>
                <xs:element name="Label" type="LabelText" maxOccurs="unbounded">
                  <xs:annotation>
                    <xs:documentation xml:lang="en-us">Language and culture-specific measurement unit label. Both role='abbrev' (e.g. 'l.', 'l', or 'L') and role='full' (en-us: 'liter', en-uk: 'litre') should be defined whenever possible. Note that UBIF text formatting applies (e. g., for 'ml/m<sup>2</sup>'). </xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:sequence>
              <xs:attribute name="precedesValue" type="xs:boolean" default="false">
                <xs:annotation>
                  <xs:documentation xml:lang="en-us">True indicates that unit should be presented before the value (as in 'pH 7.0'). Default is false.</xs:documentation>
                </xs:annotation>
              </xs:attribute>
            </xs:complexType>
          </xs:element>
          <xs:element name="Default" type="QuantitativeCharDefaults" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">These data (like measurement unit prefix, significant figures, precision) declared here are the default if no other information is given in a specific description.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="MolecularSequenceCharacter">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Derived from AbstractCharacterDefinition to be used in instance documents (non-abstract type)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharacterDefinition">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Extension of the 
common character 
properties with those
specific to sequences. 

Currently only two
kinds of molecular
sequences are 
supported. This type
should not be misused
for free-form text 
strings!</xs:documentation>
          </xs:annotation>
          <xs:element name="Assumptions" type="VersionExtension" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(Not yet used!)</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="SequenceType" type="MolecularSequenceTypeEnum">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Currently limited to 'Nucleotide' and 'Protein', but future SDD versions may expand this after appropriate discussion. The special nucleotide type RNA/DNA are currently not considered necessary. The symbols U (RNA) and T (DNA) should be considered equal for the purpose of analysis.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="SymbolLength" type="xs:integer" default="1" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The number of letters in each symbol. Nucleotides are always codes with 1-letter symbols, but proteins may use 1 or 3-letter codes (A or Ala for alanine). In NEXUS SymbolLength is implicit in the Token command.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="GapSymbol" type="ShortString" default="-" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A string identifying the 'gap' symbol used in aligned sequences. The gap symbol must always be SymbolLength long. A gap is a place where no data exist, but where a position must be filled because it is assumed that sequence symbols were inserted or deleted during evolution.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="EnableAmbiguitySymbols" type="xs:boolean" default="true" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Support Ambiguity symbols such as R, Y, S, W for nucleotides, or B,Z for proteins in the sequence string.

Information about some implicit current defaults relative to NEXUS 2 format:
RespectCase is false; MatchChar is inapplicable to SDD (would prevent descriptions with sequence to be freely combinable); NEXUS data using MatchChar need to be expanded.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TextCharacter">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Derived from AbstractCharacterDefinition to be used in instance documents (non-abstract type). In coded descriptions, these characters only support a Text element for unconstrained text.

For applications not capable to analyze unconstrained natural language, text data can not be used in identification.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharacterDefinition">
        <xs:group ref="SpecificExtension" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Note: The ColorRangeCharacter above is only an example of other derivations expected, like algorithmically described shapes, molecular sequences (genome/proteome), or molecular patterns (RFLP, AFLP, etc)</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">b) inner classes, one-time use within character definitions above</xs:documentation>
  </xs:annotation>
  <xs:complexType name="CategoricalCharMapping">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Inner class, used only within CategoricalCharacter</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="From" type="CharacterStateRef"/>
      <xs:element name="To" type="CharacterStateRef">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Both To and From should point to a different character than the current (not validated). No explicit character reference is required, since state references are unique within a dataset.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="SpecificExtension" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="CategoricalCharMappingSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Inner class, used only within CategoricalCharacter</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="Mapping" type="CategoricalCharMapping" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Each mapping defines a source and a destination state. Both From and To may point multiple times to the same state, but the combination From + To must be unique. Both state must be defined in the current character (validated through identity constraint!)</xs:documentation>
            </xs:annotation>
            <xs:unique name="CategoricalStateMapping_FromDifferentThanTo">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">Ensures that From is different than To, a state should never point to itself. NOTE: Cyclical mappings are not easily validated in schema: 'Mapping From ref="s1"  To ref="s2"' Plus 'Mapping From ref="s2"  To ref="s1"' requires external validation!</xs:documentation>
              </xs:annotation>
              <xs:selector xpath="u:From | u:To"/>
              <xs:field xpath="@ref"/>
            </xs:unique>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CategoricalCharAssumptions">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Inner class, used only within CategoricalCharacter</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="MeasurementScale" type="CategoricalMeasurementScaleEnum" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">An optional specification of the kind of categorical character variable. The available measurement scales are 'nominal', and 'ordinal'. The distinction between linear ordering and other kinds of ordering is made separately!</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="NaturallyContinuous" type="xs:boolean" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Any categorical variable can assume only a limited number of discrete values. Thus data recorded in a CategoricalCharacter are always discrete (= discontinous or meristic). However, the measured property may either be naturally discrete ('male/ female', 'aseptate/ uniseptate/ biseptate/muriform'), or it may be continuously varying and partioned into into discrete categories ('no/few/many hairs', 'orange to red'). Only in the latter case the between-operator can be used on neighboring states.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="SpecificExtension" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="QuantitativeCharMapping">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Inner class, used only within QuantitativeCharacter</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="From" type="ValueRangeWithClass">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">An inclusive range defined through two attributes ('lower', 'upper'), plus a 'valueclass' defining the preferred measure to base the mapping upon.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="ToState" type="CharacterStateRef" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The categorical state corresponding
to the range defined in From.
If missing: From defines a partioning into range categories; range labels may then be automatically created from lower/upper values.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="SpecificExtension" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="QuantitativeCharMappingSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Inner class, used only within QuantitativeCharacter</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="Mapping" type="QuantitativeCharMapping" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Each mapping defines a lower and an upper value to map numerical ranges to categorical states in the same character. The mechanism is related to DELTA Key States.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QuantitativeCharAssumptions">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Inner class, used only within QuantitativeCharacter</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="MeasurementScale" type="QuantitativeMeasurementScaleEnum" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">An optional specification of the kind of numerical character variable. The numeric scales are 'interval', and 'ratio'. Interval differs from Ratio that the 0-value is an arbitrary point (e.g. in °C/°F) so that ratios should not be calculated.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="ValuesAreInteger" type="xs:boolean" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">If true, an application may issue a warning if sample measurements are not integer. Note that most statistical measures are real values for integer data (min/max/TotalRange being exceptions).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Continuous" type="xs:boolean" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Data are continous if theoretically any value is possible with a sufficiently fine measurement method. They are discrete if only certain values are possible and gaps between values exist. The value must be false for ValuesAreInteger= true. It may also be false for real numeric values (esp. for ratio data based on counts).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="PlausibleRange" type="ValueRange" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">An inclusive range defined through two attributes into which all measured values and most statistics (mean, extremes, ranges, etc.) should fall. Only dimensionless statistics (variance, sample size) are not to be tested against the plausibility range. This does not define a schema constraint; applications may ignore this, enforce it strictly, or issue warnings when violated.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="CircularDataRange" type="ValueRange" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Circular data are a special kind of MeasurementScale='interval'. If this data element is present, lower and upper define the values joining the circle. Example: '0, 360' for compass values, '0, 24' for hours of day. Compare Zar 1984: 422ff.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="SpecificExtension" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="QuantitativeCharDefaults">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Inner class, used only within QuantitativeCharacter</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="MeasurementUnitPrefix" type="MeasurementUnitPrefixEnum" default="noprefix" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Default multiplication factor prefix. Specifying MeasurementUnit without a prefix and setting this enables overriding this default in individual values in summary ('MeasurementUnitPrefix' element) or sample data ('unitprefix' attribute).
[Subject to external validation!]</xs:documentation>
          <xs:documentation xml:lang="x-internal">External validation: if this is not set, no unitprefix attribute may be used in quantitative summary and sample data.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="SignificantFigures" type="xs:positiveInteger" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The number of figures in normal (i.e. not dimensionless) measures assumed to be significant for all data in this character. (In individual values in summary or sample data this can be overridden in the 'significant' attribute.)</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="DecimalPlaces" type="xs:positiveInteger" default="4" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The number of digits to the right of the decimal point. 3.142 is given to three decimal places, but has 4 significant figures. If both significant figures and decimal places are defined, significant figures override the decimal place definition.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="SpecificExtension" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">c) State definitions within CategoricalCharacter. Abstract base type and derived types to be used in instance documents. </xs:documentation>
  </xs:annotation>
  <xs:complexType name="CharacterLocalStateDef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Currently identical to AbstractVocabularyBase</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractVocabularyBase"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ConceptStateDef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Currently identical to AbstractVocabularyBase</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractVocabularyBase"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CharacterStateSeq">
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:choice maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">(The element 
sequence in 
instance 
documents 
is informative!)</xs:documentation>
          </xs:annotation>
          <xs:element name="StateDefinition" type="CharacterLocalStateDef">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Local definition of a state</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="StateReference" type="ConceptStateRef">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Reference to a concept state (as defined document-wide at a concept tree node); note that the ref-attribute serves here both as ref and as the equivalent of the StateDefinition/@id for the purpose of character data (i.e. states in descriptions) referencing the states within a character.

Desirable external validation: The combined set of locally defined states and inherited concepts states should have unique labels.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">d) Character and state references</xs:documentation>
  </xs:annotation>
  <xs:complexType name="CharacterRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Refers to a character (e. g., from within concept trees or from descriptions). It consists only of a reference to a Character definition id.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CharacterStateRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Refers to a character state (e. g., from descriptions). It consists only of a reference to a Character state definition id.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CharacterStateRefSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A collection of state references (CharacterStateRef type)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="State" type="CharacterStateRef" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ConceptStateRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Refers to a project-wide definition of a categorical state at a concept node</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">e) Modifiers cover expressions of certainty, frequency, manner, degree, etc. that can be added to existing character value or state data in descriptions.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="ModifierDef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">State or character modifier definitions (certainty, frequency, spatial, temporal, etc.)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractVocabularyBase">
        <xs:sequence>
          <xs:element name="ModifierClass" type="ModifierClassEnum" default="OtherModifierClass" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Modifier class, used where interoperable specifications are desirable:
1. Frequency or 2. Certainy (= ProportionRange defines frequency or certainty probabilites, resp.).
3. Seasonal or 4. Diurnal (ProportionRange defines time in year or 24 h day, resp.).
4. TreatAsMisinterpretation: The current modifier becomes one of a special class of misinterpretation modifiers. States to which such modifiers are added are known to be intentionally wrongly scored to accomodate known misunderstandings of the character under study. Example: dogwood bracts looking like petals, and petal scored as 'white (by misinterpretat.)'. - With regard to (not misinterpreted) data, both frequency and certainty may be interpreted as 0 to 0 = not occurring, certainly false.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="ProportionRange" type="ZeroToOneEstimateRange" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">An estimate of a probability range for verbal modifiers. The values for upper/lower estimate of different modifiers may overlap. The default values are 0-1, indicating that no estimate was possible.

(To do: specifications for spatial and temporal modifiers should be elaborated!)</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Modifier reference (single, and group with multiple) to be used in coded descriptions:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="ModifierRefWithData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Actual modification of a statement. Refers to a modifier of any type (frequency, certainty, spatial, temporal, etc.).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef">
        <xs:attribute name="lower" type="ZeroToOne" use="optional" default="0">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Lower value of a frequency or certainty range (values 0 to 1 inclusive). Note: to specify a single, exact value set both lower and upper attributes to this value!</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="upper" type="ZeroToOne" use="optional" default="1">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Upper value of a frequency or certainty range (values 0 to 1 inclusive). Note: to specify a single, exact value set both lower and upper attributes to this value!</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="ModifierRefWithDataGroup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Multiple modifier references, optionally with data.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:annotation>
        <xs:documentation xml:lang="en-us">(The element 
sequence in 
instance 
documents 
is informative!)</xs:documentation>
      </xs:annotation>
      <xs:element name="Modifier" type="ModifierRefWithData" minOccurs="0" maxOccurs="3">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">(Attrib. 'lower'/'upper' are intended for frequency/ certainty modifiers only.)
The restriction to 0-3 modifiers is a pragmatic one; multiple modifiers on a state exist, but 3 modifiers is already extraordinary. This may reduce the implementation cost, especially for editing applications.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Modifier reference extended with Text element, used in natural language markup:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="ModifierMarkupRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Actual modification of a statement for markup of natural language descriptions (with Text inside). Refers to a modifier of any type (frequency, certainty, spatial, temporal, etc.).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ModifierRefWithData">
        <xs:sequence>
          <xs:element name="Text" type="MarkupText"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">(Note on ModifierRef/ModifierRefMarkup: Although semantics for the lower/upper attributes are defined only for frequency and certainty modifiers, the schema allows are them in all statement modifications. Additional validation by other means than xml schema may be provided, and applications should use the lower/upper attributes only in modifiers of types than Certainty and Frequency. In other modifier types, the values may be discarded upon import. XML schema validation was attempted in SDD up to 1.0 beta 2, but this resulted in a complex system of multiple derived base types and was considered too complicated.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">f) Statistical measures: The base semantics and labels are already available through UBIF. At concepts node further elaboration may occur: a) wording and value formatting b) definition of recommended measure sets.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="UnivarStatMeasureElaboration">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"> A kind of local extension of the base definition of a statistical measure; used inside in concepts, adding, e. g., formatting information.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractVocabularyBase">
        <xs:sequence>
          <xs:choice>
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Properties describing machine-readable partial semantics for a statistical measure. Provided to support generic application code that continues to function if additional measures are defined.</xs:documentation>
            </xs:annotation>
            <xs:element name="Measure" type="UnivarSimpleStatMeasure">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">Simple statistical measures not requiring a parameter (mean, variance, sample size).</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:sequence>
              <xs:element name="PMeasure" type="UnivarParamStatMeasure">
                <xs:annotation>
                  <xs:documentation xml:lang="en-us">Statistical measures with a parameter value like confidence interval, percentile, etc.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="Parameter" type="xs:double">
                <xs:annotation>
                  <xs:documentation xml:lang="en-us">A default value for the parameter of the measure. Example: 0.95 for the upper limit and -0.95 for the lower limit of the 95% confidence interval.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:sequence>
          </xs:choice>
          <xs:element name="FormatPattern" type="NumericFormatPattern" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Format rules as used in the xslt format-number function. # = significant digits; 0 (zero) = signif. digits or insignif. leading/trailing zeros; '.' = decimal point, ',' = group separator. Note that xslt itself is using en-US culture, adjusting decimal and group separator to local culture has to be specified externally. 
Examples: "0.0#" formats 5 / 0.591 as 5.0 / 0.59. "#,###.#" formats 5000 / 0.59 as 5,000 / .6. (Rules for exponential formats or percent may be added in later versions of SDD!)</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ValueRangeWithClass">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">ValueRange extended with a specification for the kind of value (broad enumerated statistical concepts).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ValueRange">
        <xs:attribute name="valueclass" type="UnivarStatMeasureClassEnum" use="optional" default="CentralMeasure">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The type of statistical measure to which the mapping range (lower, upper value) refers. This may be a central value (mean, median), a range (quantile, confidence interval, etc.) or the extremes (minimum/ maximum). Currently only these three categories are defined.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== TERMINOLOGY END ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== TERMINOLOGY-BASED DATA ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">The following types are used in descriptions or identification key to code descriptive data by reference to characters, states, and modifiers defined in the Terminology.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">3. --- Character references in coded descriptions: SummaryData</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">a) abstract and non-abstract derived types used in coded descriptions</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Note: The non-abstract derived types are to be used in instance documents. The type names have been shortened to simplify instance documents, especially if an xsi:type would be used (Char xsi:type='CatSummaryData').</xs:documentation>
  </xs:annotation>
  <xs:complexType name="AbstractCharSummaryData" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Abstract base type. Used in CodedDescription/CodedData/Char to make statements for a single character in a class or specimen.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CharacterRef">
        <xs:sequence>
          <xs:group ref="Extensions" minOccurs="0"/>
          <xs:element name="BasedOnSample" type="SamplingEventRef" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">If origin='Calculated' and data are based on a specific sample that is present within the description, this sample (SampleData/Sample) may be identified here.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Ratings" type="RatingSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation source="http://www.diversitycampus.net/Projects/TDWG-SDD/docs/SDD_P_ID_Ratings.html" xml:lang="en-us">Meta information, rating the usefulness of characters for identification or other purposes. Intended to guide, e.g., a best-next character algorithm. This information is placed here because it depends on the taxonomic group and should be inherited down the taxonomic hierarchy.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="MediaObject" type="MediaObjectRef" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Media specific to the character and current object or taxon described.
Example: microscopic image of spore shape.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Note" type="LongStringL" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Public notes or comments on the entire character statement, i. e. status values, states, measures (depending on type), etc. together. Multiple languages are supported. Applications may, e. g. report the text in brackets after all other data.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Status" type="DataStatusData" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Data status values like data 'unavailable' or 'inapplicable'. This may have a free-form Note, but no modifiers.
Note: In specimen (unit/object) descriptions this may be treated as a strict alternative to categorical or numerical data and limited to 1 status value per character (external validation required). However, for classes/taxa (e. g., a genus) it is up to the aggregation/generalization process whether to create combined data and status values ("red, unknown, or not applicable") or not.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="origin" type="DataOriginEnum" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Provenance of values/states. The current data may be original data or may be cached information derived from other sources. The origin of the derivation may be a calculation, a mapping, an aggregation/generalization (class hierarchy, from below), or an inheritance (class hierarchy, from above).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CatSummaryData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Derived from AbstractCharSummaryData to be used for categorical (char. state) data in instance documents (non-abstract type) </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharSummaryData">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Type-specific
extension 
of the base 
character 
data type.</xs:documentation>
          </xs:annotation>
          <xs:element name="State" type="StateData" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">States are 'scored' in a description by referring to a state defined in the current character.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="statemodel" type="StateCollectionModelEnum" use="optional" default="OrSet">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Distinguishes different types of state collections. 'AndSet' and 'OrSet' define state distributions that are not explicitly ordered in instance documents. Applications may reorder states using the state order defined in Terminology or state frequency values/ranking. For the corresponding 'AndSeq'/'OrSeq' the sequences of states in instance documents defines the preferred order of states (distinguishing, e. g., between 'round or elliptic' and 'elliptic or round'). WithSeq expresses a specially worded form of 'AndSeq'. With 'Between' the scored states form a range around the true value ('orange' to 'red').</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QuantSummaryData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Derived from AbstractCharSummaryData to be used for numerical (statistical measures) data in instance documents (non-abstract type) </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharSummaryData">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Type-specific
extension 
of the base 
character 
data type.</xs:documentation>
          </xs:annotation>
          <xs:group ref="ModifierRefWithDataGroup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Modification of all statistical measures collectively. Note: A character may occur multiple times in a description with different modifiers ('in winter/summer', 'at base/tip', etc.) or origins (e. g. from samples).</xs:documentation>
            </xs:annotation>
          </xs:group>
          <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Summary statistics (univariate statistical measures) like distribution parameters, sample size, etc. Two alternative types (with/without parameter) may occur in any sequence. 

(Hint: Choice is 
equivalent to class
polymorphism,
derived from same
base type.)

(The element 
sequence in 
instance 
documents 
is not 
informative 
and processors 
may reorder it.)</xs:documentation>
            </xs:annotation>
            <xs:element name="Measure" type="UnivarSimpleStatMeasureData">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">Simple measures like mean, variance, or sample size.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="PMeasure" type="UnivarParamStatMeasureData">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">Statistical measures like confidence interval or percentile, expressed using an additional parameter 'par'.
---
The 'type'-attributes in both types point directly to enumerations in UBIF (UnivarStatMeasureEnum / WithParam). An elaboration for measure definitions is supported at concept nodes, but optional.
---
Note: The 'significant' attribute overrides the information in Character/Default/SignificantFigures
---
Note: Individual measures have no separate Modifiers/Notes. However, a numerical character may occur multiple times in coded descriptions, e. g., to separately express width at base and at center.</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:choice>
          <xs:element name="MeasurementUnitPrefix" type="MeasurementUnitPrefixEnum" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Setting this overrides Character/ Default/MeasurementUnitPrefix. [Subject to external validation: this element should only be usable if a default prefix has been defined for the current character; else MeasurementUnit itself may already contain a scaling factor. Note: The measurement unit itself may not be changed in individual descriptions; it is not possible to use inch and cm in a character.</xs:documentation>
              <xs:documentation xml:lang="en-us">External validation: if this is not set, not unitprefix attribute may be used in quantitative summary and sample data.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="MolecularSequenceData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Derived from AbstractCharSummaryData to be used for letter-sequence data (especially nucleotide and protein sequences) </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharSummaryData">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Type-specific
extension 
of the base 
character 
data type.</xs:documentation>
          </xs:annotation>
          <xs:element name="Sequence" type="LongString">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A sequence of symbols expressed through letters in a string. A symbol may be expressed through one or multiple letters (e.g. A or Ala for the amino acid alanine), according to the character definition.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="FreeFormTextData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Derived from AbstractCharSummaryData to be used for unconstrained text ("Text-fields")</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharSummaryData">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Type-specific
extension 
of the base 
character 
data type.</xs:documentation>
          </xs:annotation>
          <xs:group ref="ModifierRefWithDataGroup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Modification of all statistical measures collectively. Note: A character may occur multiple times in a description with different modifiers ('in winter/summer', 'at base/tip', etc.) or origins (e. g. from samples).</xs:documentation>
            </xs:annotation>
          </xs:group>
          <xs:element name="Content" type="LongStringL" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Free-form text</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">b) types used inside the CharSummaryData-derived types</xs:documentation>
  </xs:annotation>
  <xs:complexType name="StateData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A categorical state including frequency, state modifier, and Notes</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CharacterStateRef">
        <xs:sequence>
          <xs:group ref="ModifierRefWithDataGroup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Modifiers modifying 
single categorical 
states</xs:documentation>
            </xs:annotation>
          </xs:group>
          <xs:element name="Note" type="LongStringL" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Public notes or comments,
for multiple languages.
Applications may, e. g.,
report the text in brackets
after the character state.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DataStatusData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Similar to StateData, but for status values like 'inapplicable' or 'data unavailable'). This support free-form text notes, but no modifiers!</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="DataStatus">
        <xs:sequence>
          <xs:element name="Note" type="LongStringL" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Public notes or comments,
for multiple languages.
Applications may, e. g.,
report the text in brackets
after the status value wording.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">c) A collection of summary character data, containing a choice of derived character data types (polymorphic structure, choice options are equivalent to use of base type plus xsi:type).</xs:documentation>
  </xs:annotation>
  <xs:complexType name="SummaryDataSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A collection of character summary data elements (all of which are derived from CharSummaryData abstractType</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:choice maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Unordered list.
(Hint: Choice is 
equivalent to class 
polymorphism, all
are derived from 
same base type.)</xs:documentation>
          </xs:annotation>
          <xs:element name="Categorical" type="CatSummaryData"/>
          <xs:element name="Quantitative" type="QuantSummaryData">
            <xs:unique name="QuantSummaryData_UniqueMeasureType">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">Within a given quantitative character data element, the same measure (e.g. mean, min, sample size) may not be used twice.</xs:documentation>
              </xs:annotation>
              <xs:selector xpath="u:PMeasure | u:Measure"/>
              <xs:field xpath="@type"/>
            </xs:unique>
          </xs:element>
          <xs:element name="Sequence" type="MolecularSequenceData"/>
          <xs:element name="TextChar" type="FreeFormTextData"/>
          <xs:element name="Text" type="FreeFormTextData"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">4. --- Character references in coded descriptions: SampleData</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">a) abstract and non-abstract derived types used in sample data</xs:documentation>
  </xs:annotation>
  <xs:complexType name="AbstractCharSampleData" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Abstract base type. Used in CodedDescription/SampleData/
Sample/SamplingUnit.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CharacterRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CatSampleData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Derived from abstract CharSampleData to be used for categorical (char. state) data in instance documents (non-abstract type) </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharSampleData">
        <xs:sequence>
          <xs:element name="State" type="StateData" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">States are 'scored' in a description by referring to a state in the character definition. All notes and modifiers are applicable to this element.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QuantSampleData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Derived from abstract CharSampleData to be used for numerical data in instance documents (non-abstract type) in coded descriptions (Sample/ SamplingUnit). Attribute value (xs: double) is for directly measured/observed values. Not for statistical measures; these cannot occur in sampling units!</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharSampleData">
        <xs:sequence>
          <xs:element name="Note" type="LongStringL" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Public notes or comments,
for multiple languages.
Applications may, e. g.,
report the text in brackets
after the value.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
        <xs:attribute name="value" type="xs:double" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">A single value of a single measurement for a character in a sampling unit. This may not be used for ranges, minimum, mean, etc., which cannot possibly occur on sampling units.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="significant" type="xs:positiveInteger" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Significant figures. 1.300 has 4 significant figures, 72000 may have 2, 3, or more significant figures.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="unitprefix" type="MeasurementUnitPrefixEnum" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Multiplication factor prefix overriding 
the default defining for the character.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">5. --- Character references in coded descriptions: SampleData</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">a) abstract and non-abstract derived types used in natural language descriptions. Lacking multiple inheritance mechanisms in xml schema, these Markup versions have been derived independently. They are designed to be closely related to corresponding types in the coded description, however.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="AbstractCharacterMarkup" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Abstract base type. Used in NaturalLanguageDescriptions.

Note: although Text and DataStatus scoring is common to all derived types, it can not be defined here. The markup of natural language should follow the original text sequence and type derivation would impose an xml schema sequence constraint.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CharacterRef">
        <xs:attribute name="parsed" type="xs:boolean" use="optional" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Signal whether parsing is finished for entire character with all child nodes.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CategoricalMarkup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Extends the abstract CharacterMarkup for use with categorical (char. state) data</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharacterMarkup">
        <xs:choice maxOccurs="unbounded">
          <xs:element name="Status" type="DataStatusMarkup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Status values like 'inapplicable' or 'data unavailable'). This supports free-form text notes, but no modifiers!</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Modifier" type="ModifierMarkupRef"/>
          <xs:element name="State" type="StateMarkup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Character state data permitting Text elements within.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Note" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Comments or notes about a character that are not covered otherwise. When converting NLD to coded descriptions, this will become a character note.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Text" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Any text within a char. that has not yet been identified as one of the following elements.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="QuantitativeMarkup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Extends the abstract CharacterMarkup for use with numerical (statistical measures) data as well as a list of sample measurement values.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharacterMarkup">
        <xs:choice maxOccurs="unbounded">
          <xs:element name="Status" type="DataStatusMarkup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Data status like '-' (= inapplicable) or '?' (= data unavailable). It may have an associated Note, but no modifiers.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Modifier" type="ModifierMarkupRef"/>
          <xs:element name="Measure" type="MeasureMarkup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A univariate statistical measures like mean, variance, or sample size.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="PMeasure" type="PMeasureMarkup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A univariate statistical measures like confidence interval or percentile, expressed using an additional parameter.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Value" type="ValueMarkup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The value is stored in an attribute of type double. The original text of the value may follow inside in the optional Text element. Note that the string in text will usually use a different number format than the English format required by xml.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Note" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Comments or notes about a character that are not covered otherwise. When converting NLD to coded descriptions, this will become a character note.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Text" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Any text within a char. that has not yet been identified as one of the following elements.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="FreeFormTextMarkup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us"># Extends the abstract CharacterMarkup to reference free-form text as equivalent to a "text character"</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractCharacterMarkup">
        <xs:choice maxOccurs="unbounded">
          <xs:element name="Status" type="DataStatusMarkup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Status values like 'inapplicable' or 'data unavailable'). This supports free-form text notes, but no modifiers!</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Note" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Comments or notes about a character that are not covered otherwise. When converting NLD to coded descriptions, this will become a character note.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Text" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Any text within a char. that has not yet been identified as one of the following elements.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">("ColorRangeMarkup" (color polygon measurement data) or "SequenceMarkup" (molecular or other sequences) are not supported at the moment, since the author do not expect to find them in natural language descriptions. If necessary, these types will be added.)</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">b) The following NLD type refers to concept nodes and has no corresponding types in SummaryData/SampleData:</xs:documentation>
  </xs:annotation>
  <xs:group name="MarkupGroup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Used in ConceptMarkup 
and root of NLD (without 
a ref to concept). (Note: 
Modeling through class 
derivation alone would 
require multiple 
inheritance.)</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:annotation>
        <xs:documentation xml:lang="en-us">1. Group must 
be unbounded 
(not possible 
on a choice
after a group).

2. The element 
sequence in 
instance 
documents 
is informative!</xs:documentation>
      </xs:annotation>
      <xs:element name="Text" type="MarkupText">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Text may refer to a text character (ref attribute present) or to parts not yet identified (ref attribute missing).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Concept" type="ConceptMarkup">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Markup of concepts above the character level, e. g., organism parts or methodological sections.
Concepts may contain further concepts.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice>
        <xs:annotation>
          <xs:documentation xml:lang="en-us">(Hint: Choice is 
equivalent to class
polymorphism,
derived from same
base type.)</xs:documentation>
        </xs:annotation>
        <xs:element name="TextChar" type="FreeFormTextMarkup">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Free-form text in a description may correspond to a free-form text character.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="Categorical" type="CategoricalMarkup">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">(Note: In most cases initially the states are recognized, but character markup
can always be deduced from the associations between char. and states defined in the terminology.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="Quantitative" type="QuantitativeMarkup"/>
      </xs:choice>
    </xs:choice>
  </xs:group>
  <xs:complexType name="NaturalLanguageMarkup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">The root of natural language markup is identical to ConceptMarkup, except that the concept ref attribute is prohibited.</xs:documentation>
    </xs:annotation>
    <xs:group ref="MarkupGroup" maxOccurs="unbounded"/>
    <xs:attribute name="parsed" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">(Set to true when all 
content parsing is finished)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ConceptMarkup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Used in NaturalLanguageDescriptions. Refers to concepts (i. e. nodes defined in concept trees)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="DescriptiveConceptRef">
        <xs:group ref="MarkupGroup" maxOccurs="unbounded"/>
        <xs:attribute name="parsed" type="xs:boolean" use="optional" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Signal whether parsing is finished for entire concept with all child nodes.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">c) types used inside the CharacterMarkup types</xs:documentation>
  </xs:annotation>
  <xs:complexType name="MarkupText">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Formatted text with some additional optional attributes, used for Text and Note elements inside the NaturalLanguageDescription container.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="LongStringL">
        <xs:attribute name="parsed" type="xs:boolean" use="optional" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Markup of legacy text will often be incremental. This attribute may be set to true after markup of a text block is completed, signaling consumers that all information has been captured in SDD statements and the remaining legacy text need not be analyzed by natural language processing.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="newparagraph" type="xs:boolean" use="optional" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Where natural language descriptions consist of multiple paragraphs, this attribute can optionally mark the beginning of a new paragraph.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="pagenumber" type="ShortString" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">If the description has a paginated (digital or printed) source, the page number (arabic, roman letters or numerals) may optionally be recorded. (Other publishing artifacts like header/footer text may be placed in attribute extensions from other namespaces.)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="DataStatusMarkup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Variant of DataStatusData to be used inside the NaturalLanguageDescription markup container.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="DataStatus">
        <xs:choice maxOccurs="unbounded">
          <xs:element name="Note" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Additional information regarding the data status</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Text" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The text in the natural language description representing the status information itself</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="StateMarkup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Variant of StateData to be used inside the NaturalLanguageDescription markup container.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CharacterStateRef">
        <xs:choice maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">(The 
element 
sequence in 
instance 
documents 
is informative!)</xs:documentation>
          </xs:annotation>
          <xs:element name="Modifier" type="ModifierMarkupRef"/>
          <xs:element name="Note" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Text related to a specific state that is not covered by either the state definition or modifiers. When converting NLD to coded descriptions, this will become a character state note (free-form text).</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Text" type="MarkupText"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ValueMarkup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">For single values (singleton observation or values in a sample).</xs:documentation>
    </xs:annotation>
    <xs:choice maxOccurs="unbounded">
      <xs:element name="Note" type="MarkupText">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Text commenting on a sample value.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Text" type="MarkupText">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ultimately this should contain only the value itself.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
    <xs:attribute name="value" type="xs:double" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">A single value of a single measurement for a character in a sampling unit. This may not be used for ranges, minimum, mean, etc., which cannot possibly occur on sampling units.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="MeasureMarkup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">(Used inside Quantitative markup)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="UnivarSimpleStatMeasureData">
        <xs:sequence>
          <xs:element name="Text" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The text representing the statistical measure in the original natural language description. In English this will often be identical with the content of the value attribute. However, trailing zeros ('1.20'), exponents ('10&lt;sup&gt;2&lt;/sup&gt;) and local-specific grouping and fractional delimiters (German '1.998,55' is English '1,998.55') require a separation of issues.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PMeasureMarkup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">(Used inside Quantitative markup)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="UnivarParamStatMeasureData">
        <xs:sequence>
          <xs:element name="Text" type="MarkupText">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The text representing the statistical measure in the original natural language description. In English this will often be identical with the content of the value attribute. However, trailing zeros ('1.20'), exponents ('10&lt;sup&gt;2&lt;/sup&gt;) and local-specific grouping and fractional delimiters (German '1.998,55' is English '1,998.55') require a separation of issues.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== TERMINOLOGY-BASED DATA END ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== DESCRIPTIONS START ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Descriptions are either natural language with optional markup or coded descriptions. Both are derived from the same base type:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="AbstractDescription" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Abstract base type for NaturalLanguageDescription
and CodedDescription.

The id attribute is currently not used in keyrefs from within this schema. However, it is considered generally useful to uniquely identify descriptions in federated situations.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject">
        <xs:sequence>
          <xs:element name="Scope" type="DescriptionScopeSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The scope of the description (= 'subject' of descriptive statements).
Applications creating new data may want to make scope specifications required, but legacy data may contain only an informal description label (e. g., DELTA 'item name'; here as Repr./Label).</xs:documentation>
            </xs:annotation>
            <xs:unique name="DescrScope_UniqueScopeRef">
              <xs:selector xpath="u:*"/>
              <xs:field xpath="@ref"/>
            </xs:unique>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DescriptionScopeSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Extension of Scope base classes for descriptive concepts</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="ExtendedScopeSet">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Extension of base type with specific, descriptive scopes.

Notes on base elements (Tax.-Cit.) in the context of a description scope:
Repeated taxa: in addition to reasons stated in base type, these may also indicate descriptions of interactions between multiple organisms (e.g. disease symptoms).
Specimen: If a single specimen is given, this is the description of it, if multiple specimens are given these are interpreted as "representative or studied specimens". Note: Since Specimen may include media objects, it is possible to describe, e. g., images of specimen.
GeographicArea: Descriptions may be specific to a geographic region. A taxon may have different morphology, molecular markers, etc. in different regions.</xs:documentation>
          </xs:annotation>
          <xs:element name="Part" type="DescriptiveConceptRef" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A description may cover only parts an organism, ('inflorescence', 'roots').</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Stage" type="DescriptiveConceptRef" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Developmental concepts ('larval stage', 'adult', etc.)</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Sex" type="SexStatusEnum" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(male, female, etc. ##To be discussed: should we use the UBIF sex enumeration here?)</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="OtherConcept" type="DescriptiveConceptRef" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Other concepts that may define the scope of a description</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="NaturalLanguageDescription">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Descriptions entered as free-form text with optional (and potentially incomplete) markup referring to concepts (= char. tree nodes), characters, and states as defined in the terminology.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractDescription">
        <xs:sequence>
          <xs:element name="NaturalLanguageData" type="NaturalLanguageMarkup">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The full, unchanged original wording of a natural language description is retained inisde the Text elements. Descriptive concept, character, or state markup may be added (partial or complete) without changing the original wording sequence.

In contrast to CodedDescriptions, no uniqueness constraints are defined. For example, states may occur multiple times within a character (e. g., if differing in regard to modifiers but other states occur between them).</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CodedDescription">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Coded description data are highly controlled by the vocabulary and structures defined in the Terminology, using references to characters, states, modifiers, numerical values for measurements. They also support a limited amount of free-form text (in Notes or Annotation only). Separating data and terminology allows rearranging and refactoring the terminology, multilingual support through central terminology translations, and multiple hierarchical views. 

Coded descriptions must fulfill more rigorous consistency requirements than natural language descriptions and are more suitable for analysis. Furthermore, language-dependent annotations are minimized so that data can be easily reorganized and translated into multiple languages.

Note: Representation/MediaObject of entire description may contain media like images that are not specific to a character (else add them to character elements below).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractDescription">
        <xs:sequence>
          <xs:element name="SummaryData" type="SummaryDataSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Summary data for aggregated or summarized data (using statistical measures, state distributions, etc.). The element is optional to support descriptions containing only sample data or media objects.
Note: Characters are NOT required to have unique ref attributes! Data for one character may be recorded with different modifications (in spring/autumn, at tip/base).
(The element sequence in instance documents is not informativeand may be changedat any time)</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="SampleData" type="SamplingEventSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Raw sample data are recorded here. The analysed and generalized (e. g. using statistical measures) results are normally also reflected under SummaryData (with origin = 'calculated' and BasedOnSample referring to a sample ID.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">A special subtype of CodedDescription are original sampling data, which are organized into referrable SamplingEvent containers:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="SamplingEventSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Collection of Sampling events</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">(The sequence
of Sample elements in 
instance documents 
is not informative
and may be changed
at any time!)</xs:documentation>
          </xs:annotation>
          <xs:element name="SamplingEvent" type="SamplingEvent" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A container for direct ('raw') measurement results in a study. All sampling observations are assumed to be made under identical conditions. Descriptions may contain an unlimited number of Samples.
(Attribute random declares random sampling, if false sample may or may not be biased.)</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SamplingEvent">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A container for a sample data, with repeated sampling units, each of which may record multiple characters that are observed together.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractEvent">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Representation 
element in base 
type may contain 
a short label or 
description of 
sampling 
circumstances
(not required).</xs:documentation>
          </xs:annotation>
          <xs:element name="SamplingUnit" type="SamplingUnitDataSet" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A sampling unit may be an individual organism, a leaf of a tree, a piece of tissue, etc. In each sampling unit multiple characters may have been observed together ('paired observations'). Example: 'leaf shape, length, and width' of a single leaf). Value frequencies (e. g., '2.3': observed 4 x) are not supported; they are useful when only a single character variable is supported, but complicate paired observations unnecessarily. Char. values with a frequency should be entered in repeated SamplingUnits.

(The sequence of SamplingUnit elements in instance documents should be preserved. Although it has no strictly defined semantics, it may be relevant if data entry is compared with the source.)</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="randomized" type="xs:boolean" use="optional" default="false">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">If true, the sample is a random or randomized sample. If false, the sample may or may not be biased.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SamplingUnitDataSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">(This is equivalent to the SummaryDataSet - the sample data structure has the intermediate event for which no equivalent exists in summary data!)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:choice maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Multiple paired 
observations 
(character data). 

(Hint: Choice is 
equivalent to class
polymorphism, all
derived from same
base type.)</xs:documentation>
          </xs:annotation>
          <xs:element name="Categorical" type="CatSampleData"/>
          <xs:element name="Quantitative" type="QuantSampleData"/>
          <xs:element name="TextChar" type="FreeFormTextData"/>
          <xs:element name="Text" type="FreeFormTextData"/>
          <xs:element name="Sequence" type="MolecularSequenceData"/>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SamplingEventRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Refers to a specific SampleData/SamplingEvent in a CodedDescription.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== DESCRIPTIONS END ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== IDENTIFICATION KEYS START ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Stored identification keys (esp. manually designed as opposed to automatically generated) are stored in a separate section:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="StoredKey">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines a stored identification key (dichotomous or multifurcating key) that has been digitized from printed publications or manually created to express expert knowledge that would not be available in dynamically created dichotomous keys (using Ratings from terminology and a 'find next best character' to minimize the average search tree).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject">
        <xs:sequence>
          <xs:element name="Scope" type="DescriptionScopeSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(Scope includes 
source citation 
for published 
keys.)</xs:documentation>
            </xs:annotation>
            <xs:unique name="StoredKeyScope_UniqueScopeRef">
              <xs:selector xpath="u:*"/>
              <xs:field xpath="@ref"/>
            </xs:unique>
          </xs:element>
          <xs:element name="Question" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Optionally the first question for the root leads (for question-answer-style keys).</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:choice maxOccurs="unbounded">
                <xs:annotation>
                  <xs:documentation>Either a text
statement or
a media object
must be present.
Best practice:
provide text in 
addition to media.</xs:documentation>
                </xs:annotation>
                <xs:element name="Text" type="LongStringL">
                  <xs:annotation>
                    <xs:documentation xml:lang="en-us">If the user agrees with the statement (expressed as free-form text in Label role='full'), the node will be followed. Statements may be accompanied by multiple media objects (icon, selector). In picture keys label text may be used as title or alt-text of images.</xs:documentation>
                  </xs:annotation>
                </xs:element>
                <xs:element name="MediaObject" type="MediaObjectRef">
                  <xs:annotation>
                    <xs:documentation xml:lang="en-us">Media specific to the characters or taxa in the current lead statement.</xs:documentation>
                  </xs:annotation>
                </xs:element>
              </xs:choice>
            </xs:complexType>
          </xs:element>
          <xs:element name="Leads" type="StoredKey_LeadSeq">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The tree structure of the stored identification key is presented as an ordered list of statement nodes together with edges pointing to parent nodes.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:group ref="SpecificExtension" minOccurs="0"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="StoredKey_LeadSeq">
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:choice maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">An ordered list of inner leads (nodes) and result leads (terminal nodes, leaves). The order defines the sequence of lead/result statements. Both width- and breadth-first must be supported. The node/parent graph structure is limited to trees by means of identity constraints (key/keyref).</xs:documentation>
          </xs:annotation>
          <xs:element name="Lead">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Nodes of the 
identification key, 
describing a choice
(text + optional
illustration).
Inner nodes may
contain a question
for the following
leads; terminal
nodes lead to 
one of a taxon,
subkey, or a
secondary 
reticulation.</xs:documentation>
            </xs:annotation>
            <xs:complexType>
              <xs:complexContent>
                <xs:extension base="StoredKeyNode"/>
              </xs:complexContent>
            </xs:complexType>
            <xs:unique name="StoredKeyNode_NoSelfReference">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">Ensures that Parent does not point to the id attribute of its own node. Note that cycles with a length of "2" still require external validation!</xs:documentation>
              </xs:annotation>
              <xs:selector xpath=". | u:Parent"/>
              <xs:field xpath="@id | @ref"/>
            </xs:unique>
          </xs:element>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="StoredKeyNode">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">An node in a stored identification key, containing the lead statement to follow and optionally either a next question answered by the following statements, or taxon/subkey results.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Parent" type="StoredKeyNodeRef" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ref. to an inner node of the current tree. Omitting this is interpreted as a reference to the root of the tree.</xs:documentation>
          <xs:documentation xml:lang="x-internal">Because every edge defines a new node, only few deviations from a true tree are possible. However, isolated cycles (node "1" having parent "2", node "2" having parent "1", not connected to root) can occur and require external validation to be prevented. </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Either a text
statement or
a media object
must be present.
Best practice:
provide text in 
addition to media.</xs:documentation>
        </xs:annotation>
        <xs:element name="Statement" type="LongStringL">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">If the user agrees with the statement (expressed as free-form text in Label role='full'), the node will be followed. Statements may be accompanied by multiple media objects (icon, selector). In picture keys label text may be used as title or alt-text of images.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="MediaObject" type="MediaObjectRichRef">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Media specific to the characters or taxa in the current lead statement.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
      <xs:sequence>
        <xs:element name="CodedStatements" minOccurs="0">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Currently only extension point for next version! - Intended for: "Statements in coded terminology that are equivalent to the Statement text. This information may be used to switch between stored identification keys and interactive identification (multiple entry keys). Statements like 'calyx black or petals white or cream (but not yellow)' can be expressed."</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:sequence>
              <xs:any namespace="##targetNamespace"/>
            </xs:sequence>
          </xs:complexType>
        </xs:element>
      </xs:sequence>
      <xs:choice>
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Choice =
only one 
option 
may be 
used</xs:documentation>
        </xs:annotation>
        <xs:element name="Question" minOccurs="0">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Optional question, answered by Statements in Leads below this node (for question-answer-style keys). In most key styles the question is empty (using only alternative statements).</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:choice maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Either a text
statement or
a media object
must be present.
Best practice:
provide text in 
addition to media.</xs:documentation>
              </xs:annotation>
              <xs:element name="Text" type="LongStringL">
                <xs:annotation>
                  <xs:documentation xml:lang="en-us">If the user agrees with the statement (expressed as free-form text in Label role='full'), the node will be followed. Statements may be accompanied by multiple media objects (icon, selector). In picture keys label text may be used as title or alt-text of images.</xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="MediaObject" type="MediaObjectRef">
                <xs:annotation>
                  <xs:documentation xml:lang="en-us">Media specific to the characters or taxa in the current lead statement.</xs:documentation>
                </xs:annotation>
              </xs:element>
            </xs:choice>
          </xs:complexType>
        </xs:element>
        <xs:element name="TaxonName" type="TaxonNameRef">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Refers to a taxon/class name</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="Subkey" type="StoredKeyRef">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Refers to an entire stored identification key, supporting a main/subkey division.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="Reticulation">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Refers to an arbitrary identification key node within the current or other keys, creating reticulations in key (id attributes of key nodes must be unique across all keys). Note: very rarely, reticulations in keys do refer to result nodes!</xs:documentation>
            <xs:documentation xml:lang="en-us">Example for reticulation to result node: key to sections in "Phoma manual" (Boerema &amp; al.)</xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:complexContent>
              <xs:extension base="StoredKeyNodeRef">
                <xs:attribute name="leadspecific" type="xs:boolean" default="false">
                  <xs:annotation>
                    <xs:documentation xml:lang="en-us">Normally, a reticulation - although pointing to a lead-specific id value - is assumed to point to the couplet in general. Very rarely keys point to specific leads directly; this can be specified by setting this to true.</xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:extension>
            </xs:complexContent>
          </xs:complexType>
        </xs:element>
        <xs:choice>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Choice =
only one 
option 
may be 
used</xs:documentation>
          </xs:annotation>
        </xs:choice>
      </xs:choice>
      <xs:group ref="Extensions"/>
    </xs:sequence>
    <xs:attributeGroup ref="LocalInstanceID"/>
  </xs:complexType>
  <xs:complexType name="StoredKeyRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Refers to an entire stored identification key (e. g., if a key is referenced as a subkey from within another key)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="StoredKeyNodeRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Refers to a node in a stored key (e. g., for reticulating keys)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== IDENTIFICATION KEYS END ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Other basic types used by SDD (compare also the types used by UBIF) ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Character rating (equivalent to DELTA wheight, reliability, etc., but characters are scored taxon specific in descriptions rather than for all taxa)</xs:documentation>
  </xs:annotation>
  <xs:complexType name="Rating">
    <xs:annotation>
      <xs:documentation source="http://www.diversitycampus.net/Projects/TDWG-SDD/docs/SDD_P_ID_Ratings.html" xml:lang="en-us">A rating of 1 (low) to 5 (high), with 3 as central value, the topic that is being rated, plus an optional indication whether inherited (= calculated based on related definitions) or defined directly.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="rating" type="Rating1to5Enum" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">A value from 1 (low) to 5 (high)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="context" type="RatingContextEnum" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Use case: topics such as ObservationConvenience, Availability, ScoringRepeatability</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="RatingSet">
    <xs:annotation>
      <xs:documentation source="http://www.diversitycampus.net/Projects/TDWG-SDD/docs/SDD_P_ID_Ratings.html" xml:lang="en-us">A collection of ratings to rate characters for conveniency, etc. This is especially relevant during interactive identification to rank the remaining characters for discriminative power and convenience.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="Rating" type="Rating" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A rating of 1 (low) to 5 (high), with 3 as central value, the topic that is being rated, plus an optional indication whether inherited (= calculated based on related definitions) or defined directly.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Special types for natural language wordings:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="AbstractVocabularyBase" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Base of modifiers, stat. meas. elaborations, and categorical character states (both referrable concept and local character state definitions).

Any use of a modifier or character state in descriptions is a reference to an object derived from this class.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractObject">
        <xs:group ref="NaturalLanguageGroup" minOccurs="0"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="NaturalLanguageGroup">
    <xs:sequence>
      <xs:element name="NaturalLanguage" type="NaturalLanguagePhraseSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Defines text phrases (before, after, and between elements) used to create natural language reports.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="NatLangPhraseString">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A text element used to define wordings for natural language output. Currently the type only adds a role attribute. Further attributes may be required if the handling of leading and trailing blanks should not work in an interoperability context (e. g., attributes like BlankBefore / BlankAfter of type BooleanTripleState?).</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="LongStringL">
        <xs:attribute name="role" type="NatLangPhraseRoleEnum" default="Before">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The kind of natural language phrase. Enumerated values: 'single', 'before', 'after', 'delim', etc.; see annotations in enumeration for further information.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="StringFormattingTypeEnum" use="optional" default="html">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The kind of formatting used in the string. In contrast to most other text strings (defaulting to 'inline'), the default for natural language phrases is 'html', i.e. inline as well as block-level elements are supported in entity-escaped form. Use of xhtml ("br/" instead of "br") is highly recommend, but not validated. Using escaped 'html' requires double-escaping for gt, lt (but not amp) character entities, since all occurrences of gt and lt will be converted prior to presentation.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="NaturalLanguagePhraseSet">
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="Phrase" type="NatLangPhraseString" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Phrases with roles like 'before', 'after', etc. for multiple languages/ audiences may be defined. Using a very simple grammar, the concatenation of these phrases yields a simple natural language description.

External validation: for each lang./audience, each role should occur only once.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
 <xs:annotation>
    <xs:documentation xml:lang="en-us">Unified Biosciences Information Framework (UBIF) XML schema. This part provides a fundamental abstract bioscience object with a pattern for object-id, object representation, and object linking and referencing (simple direct text, document-internal cross-references, global guid references, or nested use of full object type).</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Copyright © 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file UBIF_(c).xsd for authorship and licensing information.</xs:documentation>
  </xs:annotation>
  <xs:include schemaLocation="UBIF_TypeLib.xsd"/>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== All fundamental UBIF object types are derived from the following base type:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="AbstractObjectOrEventBase" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Abstract base type for all knowledge- domain specific first class object classes (= object types) in UBIF, containing generic representation, linking, text annotation, and element/attribute extension mechanisms.

Although not all first-class objects require an id-attribute for local references, it may be required because of xs:key identity constraints defined in many UBIF-based schema (including SDD). This is a limitation of xml schema: It is not possible to make IDs optional, but require those present to be unique and the target of keyrefs pointing to these.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Representation" type="Representation" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Language/audience-specific object- representations intended for human consumers, consisting of free-form text or media, capturing the essence of the object semantics (see also further annotations on updating and language independence).</xs:documentation>
          <xs:documentation xml:lang="en-us">*Updating:* Object representations may be updated using link information. This should occur automatically (without human control) only after a human decided that the semantic management of an external object provider can be fully trusted.</xs:documentation>
          <xs:documentation xml:lang="en-us">*Language independence:* Publication references are sometimes erroneously considered language independent, ignoring the transcription regularly occuring when citing publications from non-latin character sets (Cyrillic, Greek, Chinese, etc.). Scientific taxon names are fixed in both language and character set and usable in all languages and cultures (recommended: xml:lang=x-neutral).</xs:documentation>
        </xs:annotation>
        <xs:unique name="AbstractObjEvBase_MediaRole">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The combination of ref and role attributes must be unique within each (in most cases ref alone should be unique, but it may make sense to define the same resource as 'primary' and 'diagnostic').</xs:documentation>
          </xs:annotation>
          <xs:selector xpath="u:MediaObject"/>
          <xs:field xpath="@ref"/>
          <xs:field xpath="@role"/>
        </xs:unique>
      </xs:element>
      <xs:element name="Links" type="LinkSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Generic and untyped, uri-based relationships present on all objects in the object core ontology</xs:documentation>
        </xs:annotation>
        <xs:unique name="AbstractObjEvtBase_UniqueURIs">
          <xs:selector xpath="u:*"/>
          <xs:field xpath="@uri"/>
        </xs:unique>
      </xs:element>
      <xs:group ref="Extensions" minOccurs="0"/>
    </xs:sequence>
    <xs:attributeGroup ref="LocalInstanceID"/>
    <xs:attribute name="uri" type="xs:anyURI">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Optionally a uri of the current object itself. In the case of resolvable URIs, the identity of the object should be interpreted strictly, i.e. resulting in equivalent information in the same format. Compare Link rel=Alternate, BasedOn, SubclassOf, etc. for further methods refer to more abstract forms of concept identifiers. Note that the URL itself offers no guidance whether  a URL is resolvable: knowledge of resolution methods may be general (url), widespread (doi, lsid), or restricted to special services.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="AbstractObject" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">AbstractObject with restriction: representation is required.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="AbstractObjectOrEventBase">
        <xs:sequence>
          <xs:element name="Representation" type="RepresentationReqrd">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Language/audience-specific object- representations intended for human consumers, consisting of free-form text or media, capturing the essence of the object semantics (see also further annotations on updating and language independence).</xs:documentation>
              <xs:documentation xml:lang="en-us">*Updating:* Object representations may be updated using link information. This should occur automatically (without human control) only after a human decided that the semantic management of an external object provider can be fully trusted.</xs:documentation>
              <xs:documentation xml:lang="en-us">*Language independence:* Publication references are sometimes erroneously considered language independent, ignoring the transcription regularly occuring when citing publications from non-latin character sets (Cyrillic, Greek, Chinese, etc.). Scientific taxon names are fixed in both language and character set and usable in all languages and cultures (recommended: xml:lang=x-neutral).</xs:documentation>
            </xs:annotation>
            <xs:unique name="AbstractObject_MediaRole">
              <xs:annotation>
                <xs:documentation xml:lang="en-us">The combination of ref and role attributes must be unique within each (in most cases ref alone should be unique, but it may make sense to define the same resource as 'primary' and 'diagnostic').</xs:documentation>
              </xs:annotation>
              <xs:selector xpath="u:MediaObject"/>
              <xs:field xpath="@ref"/>
              <xs:field xpath="@role"/>
            </xs:unique>
          </xs:element>
          <xs:element name="Links" type="LinkSet" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Generic and untyped, uri-based relationships present on all objects in the object core ontology</xs:documentation>
            </xs:annotation>
            <xs:unique name="AbstractObject_UniqueURIs">
              <xs:selector xpath="u:*"/>
              <xs:field xpath="@uri"/>
            </xs:unique>
          </xs:element>
          <xs:group ref="Extensions" minOccurs="0"/>
        </xs:sequence>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AbstractEvent" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Basic object type (representation not required), plus event data (date/time span, geo-location as geographic area).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractObjectOrEventBase">
        <xs:sequence>
          <xs:element name="DateTime" type="CompositeDateTime" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Date and time when event occurred; single point, or start of span.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="DateTimeSpanEnd" type="CompositeDateTime" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">The end of a time span if event timing is recorded as such.
Both date/times may be incomplete in ways not expressible in xs:datetime, e.g. the day and year may be known, but month unknown.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="GeographicArea" type="GeographicAreaRef" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A reference to a geographic area at which the event occurred.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Coordinates" type="GeographicalCoordinates" minOccurs="0">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A point on earth at which the event occurred.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Instance Identifiers are used for linking within a document (within a data set or between data sets):</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">--- Each object may have an instance ID by which exactly this digital representation may be referred to within instance documents. It is recommended to use semantically neutral ids. Temporary (repeated queries may result in documents having different ids), provider-local, and global identifier schemes are acceptable, but the consumer does not need to persist the id/ref values (i.e. always treats them as temporary). If instead of ref the resolvable uri-attribute is used, the retrieval of data should result in exactly the same representation.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">--- The id attribute is optional. When it is missing, no document-local reference to an object instance is possible. The object may still be referenced through a uri-reference (Link) if it contains a Link rel="current" element. References should not attempt to point to URIs defined through a Link rel="about" element.</xs:documentation>
  </xs:annotation>
  <xs:attributeGroup name="LocalInstanceID">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">An instance identifier identifies a specific representation. This value is used when referencing an object (using 'ref'-attributes). It may be a value unique only within a dataset and derived object type, or within elements of the dataset, or a global id such as a uri.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="id" type="LocalInstanceID" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">ID for internal cross-referencing within document, unique only within object-type. This is non-persistent data: consuming applications may discard or rewrite values after resolving all references to it.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="debuglabel" type="LongString" use="optional">
      <xs:annotation>
        <xs:documentation source="http://www.diversitycampus.net/Projects/TDWG-SDD/docs/SDD_I_KeyKeyref.html" xml:lang="en-us">Debuglabel is intended to simplify debugging by adding a human-readable equivalent to the primary identity value. Values may be discarded or updated at any time and should not normally be included in exports by applications; they may be generated using xslt (based on labels, abbreviations, xpath+label, etc.).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other" processContents="lax"/>
  </xs:attributeGroup>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">General Note: The use of attribute groups instead of globally defined and referred attributes is a work-around for problems occurring with attribute definitions in included library schemata. Normally one would use global attributes by ref; this however causes problems when attempting to use a library with no target namespace in multiple namespaces (chameleon pattern). Spy 2004.4 says, e. g., "... attributes need to be qualified because your schema uses attributeForm = qualified or global attributes. You must specify a prefix for your schema namespace."</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">--- Local (referring to id) or uri-based attribute groups used for referencing:</xs:documentation>
  </xs:annotation>
  <xs:attributeGroup name="LocalRefOptional">
    <xs:attribute name="ref" type="u:LocalInstanceRef" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Refers to an id attribute in an instance of the corresponding object type. Existence of referenced object within xml document is usually guaranteed by identity constraints (= referential integrity).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="debuglabel" type="u:LongString" use="optional">
      <xs:annotation>
        <xs:documentation source="http://www.diversitycampus.net/Projects/TDWG-SDD/docs/SDD_I_KeyKeyref.html" xml:lang="en-us">Debuglabel is intended to simplify debugging by adding a human-readable equivalent to the ref value. Values would normally be those from the corresponding debugkey. They may be discarded or updated at any time and should not normally be included in exports by applications.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other" processContents="lax"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="LocalRefRequired">
    <xs:attribute name="ref" type="LocalInstanceRef" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Refers to an id attribute in an instance of the corresponding object type. Existence of referenced object within xml document is usually guaranteed by identity constraints (= referential integrity).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="debuglabel" type="LongString" use="optional">
      <xs:annotation>
        <xs:documentation source="http://www.diversitycampus.net/Projects/TDWG-SDD/docs/SDD_I_KeyKeyref.html" xml:lang="en-us">Debuglabel is intended to simplify debugging by adding a human-readable equivalent to the ref value. Values would normally be those from the corresponding debugkey. They may be discarded or updated at any time and should not normally be included in exports by applications.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other" processContents="lax"/>
  </xs:attributeGroup>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- URI references: URIs are primarily identifiers; they may - but are not required to - allow data retrieval. URIs should not change. Recommended URI schemata for linking to related objects or abstract/ conceptual objects (like character concepts) are: 1) Conventional URLs (persistent URLs = purls are recommended). URLs may be a query like "http://x.y.fr/p/au=smith?yr=1998".
2) DOI, digital object identifier (used by the publishing industry). Example: doi:10.47198/923347' 3) Perhaps also LSID. 

Ideally, URIs should remain unchanged to enable data comparisons. Social reasons may prevent this, especially where authors working at organisation are not allowed to use the organisations DNS address after they stop working there. Other options (sci. societies, GBIF) should then be investigated. Further, the path within the URI of the organisation should be constructed so that uniqueness can be expected for social reasons, especially by including a personal or team-name. Example: http://xyz.de/g.hage/ coelomycetes, but not. xyz.de/plants.</xs:documentation>
  </xs:annotation>
  <xs:attributeGroup name="URIRefOptional">
    <xs:attribute name="href" type="xs:anyURI" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">External reference using a retrievable uri (url, doi, lsid, etc.)
(~=html and atom: link/@href)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="label" type="u:LongString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">If href attribute is used, this preserves a short human readable text, capturing the semantics of the href uri reference (which may be temporarily or permanently not resolvable). In some contexts, this may be required through external validation If href is used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="ResourceMediaType" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Media type of object to which href is pointing, e. g., text/html, application/rss+xml. etc. (~= html and atom:link/@type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:attributeGroup name="URIRefRequired">
    <xs:attribute name="href" type="xs:anyURI" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">External reference using a uri 
(url, doi, lsid, etc.)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="label" type="LongString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">If href attribute is used, this preserves a short human-readable text, capturing the semantics of the uri reference (uri may be temporarily or permanently not resolvable). (Using 'label' as attribute name was rejected because unrelated to xlink:label!)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="ResourceMediaType" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Media type of object to which href is pointing, e. g., text/html, application/rss+xml. etc. (~= html and atom:link/@type)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:attributeGroup>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== References to objects should use either the ref (pointer to an id in same document) or href (= pointer to a uri) attribute. The name of element name should differ from the object name, to allow designs that offer a choice of providing a full object or an object reference (xml schema can not use different attributes content to detect the type!)</xs:documentation>
  </xs:annotation>
  <xs:complexType name="AbstractRef" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Base type for all reference types (derived by restriction)</xs:documentation>
    </xs:annotation>
    <xs:attributeGroup ref="LocalRefOptional"/>
    <xs:attributeGroup ref="URIRefOptional"/>
  </xs:complexType>
  <xs:complexType name="AbstractLocalRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Local, within-document reference.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="AbstractRef">
        <xs:attribute name="href" type="xs:anyURI" use="prohibited"/>
        <xs:attribute name="label" type="u:LongString" use="prohibited"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AbstractLongStringPlusRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A required human readable string (label, title, name) as free-format, long-length string in the attribute 'literal'; plus optional local ref / global href attributes. Used where strings/names are often ambiguous, but may occasionally be identified as an object (e.g. publication, genus names, or taxon authors).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractRef">
        <xs:attribute name="literal" type="LongString" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Whereas the label attribute contains a label (= name, title) of the resource referenced by href, literal contains an unchanging literal text that is interpreted or explained by the href. Example: an author may be given in the publication as "L. Smith", the href may point to http/x.y.net/au/l-n-smith-NY, and the label of this agent/person object may be "Dr. L. N. Smith (New York)". Similar cases of literla plus optional href/label occur for publication citations or taxon names.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AbstractShortStringPlusRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A required human readable string (label, title, name) as free-format, limited-length string in the attribute 'literal'; plus optional local ref / global href attributes. Like Like AbstractLongStringPlusRef, except that the literal may only be a ShortString.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="AbstractLongStringPlusRef">
        <xs:attribute name="literal" type="ShortString" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Whereas the label attribute contains a label (= name, title) of the resource referenced by href, literal contains an unchanging literal text that is interpreted or explained by the href. Example: an author may be given in the publication as "L. Smith", the href may point to http/x.y.net/au/l-n-smith-NY, and the label of this agent/person object may be "Dr. L. N. Smith (New York)". Similar cases of literla plus optional href/label occur for publication citations or taxon names.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="URIRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Global href reference to a URI (used in derivations for specific resources types but also directly, i.e. non-abstract).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="AbstractRef">
        <xs:attribute name="href" type="xs:anyURI" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">External reference using a retrievable uri (url, doi, lsid, etc.)
(~=html and atom: link/@href)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ref" type="u:LocalInstanceRef" use="prohibited"/>
        <xs:attribute name="debuglabel" type="u:LongString" use="prohibited"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- derived types based on URIRef</xs:documentation>
  </xs:annotation>
  <xs:complexType name="Link">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Object linking mechanism
used on entire data sets 
as well as all first class 
object types!</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="URIRef">
        <xs:attribute name="rel" type="LinkingRelEnum" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">General semantics of link, currently constrained by an enumeration ('Current', 'Alternate', 'Meta', 'BasedOn', 'SimilarTo', etc.). (~= html and atom: rel, both with different vocabularies; related to xlink:arcrole; see second annotation)</xs:documentation>
            <xs:documentation xml:lang="en-us">URI for html link/@rel: http://www.w3.org/TR/html401/types.html#type-links
URI for atom link/@rel: http://www.atomenabled.org/developers/syndication/#link. XLink uses arcrole for semantics of the link, and role for semantics of the resource. Xlink: arcrole thus seems to be related to rel, whereas the expressiveness of role may be as simple as the resource media type (and thus role ~ html:type/atom:type; compare e.g. RDDL).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="length" type="xs:nonNegativeInteger" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Expected length of linked resource in bytes. Being approximate, it enables consumers to make a choice whether to follow a link or not, but is not to be used for verification. The value 0 should be interpreted as unknown length (~=atom:link/@length).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attributeGroup ref="optional_language">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The language of the resource referenced by href (~=atom:link/@hreflang).</xs:documentation>
          </xs:annotation>
        </xs:attributeGroup>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="LinkSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A collection of Link elements</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="Link" type="Link" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Defines links to alternate repres. of the same object (e. g., other version, provider, format, level of detail) as well as generic relationships (metadata, license, subclass, superclass, etc.) by means of a URI. Similar to xhtml header/link, but with different values for the 'rel' attribute. - The format of data obtained when resolving links is undefined; we need to investigate whether xlink:role or xhtml:type/media mechanisms need to be added in future UBIF versions.
(Seq. of elements not informative)</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- binary file encoding:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="EncodedContent">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Base-64 encoded data (usually a binary resource file like an image) plus a MIME content type attribute.
The binary data itself should be directly encoded, not wrapped in an additional MIME container.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="xs:base64Binary">
        <xs:attribute name="href" type="xs:anyURI" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Optionally a reference (source) for the encoded data.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="ResourceMediaType" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Media type of object to which href is pointing, e. g., text/html, application/rss+xml. etc. In this context the attribute 'type' may be used without href, because it contains the MIME type of encoded data. Note that filename information for the encoded content is lacking (and some systems do not use file extensions to communicate file type at all), so type will usually be required. (~=atom:content/@type)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Components used in the Representation part of the general AbstractObject type:</xs:documentation>
  </xs:annotation>
  <xs:group name="RepresentationGroup">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">This group may occur 
multiple times, i.e. Label, 
Detail, MediaObject may 
each occur multiple times, 
in any sequence.</xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element name="Label" type="LabelText">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Language/audience specific labels providing a text directly presentable to human consumers. Intended to be unique (not validated!) to preserve object semantics if machine- readable links (URIs) break. Text optionally UBIF-text formatted (e. g., for subscripts), length limited (see second annotation). 
Example (full label for a publication): "Smith 1998. Flora of Erehwon, Z- Publ.".</xs:documentation>
          <xs:documentation xml:lang="en-us">TECHNICAL NOTE: Text length limiting is irrelevant to some applications, using xml documents or in memory storage. However, in many databases unlimited length text slows operation and such text may not be sortable. The shorter label text roles (in contrast to those found in Detail) are therefore currently limited to 255 characters (the exact value being irrelevant, the intend should be to provide ample space about twice the expected length) to simplify implementations using mainstream relational database. In-memory applications like JAVA do not require knowledge of string lengths, but these application do care about length of numeric types, which are similarly optimized (using xs:int/double instead of xs:decimal).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Detail" type="DetailText">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Additional free-form text without length limitation, optionally UBIF-text formatted.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="MediaObject" type="MediaObjectRichRef">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Object representation through image/audio/video/mixed media/text resource. May be language-dependent or not.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="Representation">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Language/audience specific object representation for human consumers, using free-form text labels, descriptions, images, etc.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Alt">
        <xs:group ref="RepresentationGroup" minOccurs="0" maxOccurs="unbounded"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RepresentationReqrd">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Representation type, with at least one Representation element required (restriction)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="Representation">
        <xs:group ref="RepresentationGroup" maxOccurs="unbounded"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SimpleRepresentation">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Like Representation, but without Detail, and without Label role (may be treated as if Label role were fixed to 'full').</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Alt">
        <xs:choice maxOccurs="unbounded">
          <xs:element name="Label" type="ShortStringL">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Language/audience specific labels providing a text directly presentable to human consumers.
In comparison to LabelText elements (having an additional 'role' attribute) this may be interpreted as role='full'.</xs:documentation>
              <xs:documentation xml:lang="en-us">Text length limiting is irrelevant to some applications, using xml documents or in memory storage. However, in many databases unlimited length text slows operation and such text may not be sortable. The shorter label text roles (in contrast to those found in Detail) have therefore a length limit to simplify database implementations.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="MediaObject" type="MediaObjectRichRef">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Object representation through image/audio/video/mixed media/text resource. May be language-dependent or not.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:choice>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="LabelText">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">ShortStringL extended with LabelRoleEnum 'role' attribute.

Content is free form text that (usually uniquely) represent the object to human consumers. Such labels are often essential to preserve semantics if machine-readable links/IDs break. 

Content text may optionally be UBIF-formatted. 

In an LSID-based interaction, the 'title' metadata item may be considered a label with role='full'.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="ShortStringL">
        <xs:attribute name="role" type="LabelRoleEnum" use="optional" default="Full">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The kind of label text. Example values: 'full' (default, includes 'title'), 'short', 'abbrev', 'token', 'sort'. See enumeration annotation for further information.
Note: uniqueness of labels is not conveyed and must be tested by consumers.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="DetailText">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">LongStringL extended with a DetailRoleEnum 'role' attribute.</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="LongStringL">
        <xs:attribute name="role" type="DetailRoleEnum" default="Description">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The representation-role of the long free-form text. Important values are 'description' (incl. abstract) and 'caption'. See also the annotations on enumerated values.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">--- Note: Earlier UBIF versions had specific label types of various complexity (SimpleLabel, Label, LabelWithDetail, RichMediaLabel, etc.) for different objects. This caused a significant additional complexity in the design. The new model accepts that some objects may offer a number of representation choices that may rarely or never be used.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== In contrast to most reference types (defined in UBIF_CoreOntology or schemata defining derived object types), GeographicArea and MediaObject references are already defined here. Media files such as still images are used as part of representation. This is especially important for structural, character or state concepts but even audio or video have customarily title image representing them in the form of a fully informative image or an icon.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="GeographicAreaRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines an element with a ref attribute pointing to a geographic area object (GeographicAreas/GeographicArea)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="MediaObjectRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines an element with a ref attribute pointing to a MediaObject (MediaObjects/MediaObject)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="MediaObjectRichRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">MediaObjectRef plus optional role and language attributes</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef">
        <xs:attribute name="role" type="MediaRepresentationRoleEnum" use="optional" default="UnknownMediaRole">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The role the media object has in relation to the current object (icon, primary, secondary use, etc.). See enumeration annotation for further information.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Public objects carrying an id also generally provide for developer annotations/comments (undefined language), version extensions for future versions of UBIF, and custom extensions (= "application annotations").</xs:documentation>
  </xs:annotation>
  <xs:complexType name="VersionExtension">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">To allow fully forward compatible extensions of UBIF-compatible schemata, an extension container for the target namespace is provided for the use by the designers of the schema.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:any namespace="##targetNamespace" processContents="lax" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Elements from the UBIF namespace itself.</xs:documentation>
        </xs:annotation>
      </xs:any>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="Extensions">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">(NextVersion, Extensions)</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="NextVersionBase" type="VersionExtension" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Extension mechanism in own namespace to implement forward compatibility in a new version of the standard (i. e. old applications can process newer data versions; compare backwards compatibility using optional elements anywhere).</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Extension mechanism enabling any number of elements from other namespaces. Extensions may be application-specific or shared in a community; their version and scope is implicit in the namespace used. - The content or extension elements is not further validated against a schema by validating xml processors (process=lax). - Compare also the frequently available extension through attributes from other namespaces. - Recommendation: UBIF applications importing and exporting data may implement loss-less round-tripping of data. To achieve this, all imported extension elements and attributes that are unknown to the application should be persisted (stored) and exported unchanged., but in any order (if order matters to an extension, the sequence must be enclosed in another extension element).</xs:documentation>
        </xs:annotation>
      </xs:any>
    </xs:sequence>
  </xs:group>
  <xs:group name="SpecificExtension">
    <xs:annotation>
      <xs:documentation>Version (same ns) extension at the most specific point in a type derivation</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="NextVersion" type="VersionExtension" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">(additional NextVersion extension point to support extensions both in base type and in specific type. Element name must be different from base next version)</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Collection base types:</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">w3c schema provides no internal method to inform software whether the sequence of elements that may occur multiple time (i.e. sequence of members in a collection) bears any significance or not. By default all processors should preserve sequence. However, for many purposes (editing, sorted reporting, data integration from multiple sources) it is important to know whether a sequence carries semantics or not. The following base types express this for those parts of the schema where collections are expressed within container elements.</xs:documentation>
  </xs:annotation>
  <xs:complexType name="CollectionContainer" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Base type for seq (= sequence), set, or alt (= alternatives)</xs:documentation>
    </xs:annotation>
  </xs:complexType>
  <xs:complexType name="Set" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Elements form a set, each element may occur only once and order may be changed at any time.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CollectionContainer"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Seq" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Elements form a sequence, order carries semantics.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CollectionContainer"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="Alt" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Elements form a set of alternatives, i.e. order does not matter and processes will normally select only one member (e.g. for a given language)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CollectionContainer"/>
    </xs:complexContent>
  </xs:complexType>
 <xs:annotation>
    <xs:documentation xml:lang="en-us">Unified Biosciences Information Framework (UBIF) XML schema. This schema provides a core ontology of first class object types and references derived from the common abstract base type.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Copyright © 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file UBIF_(c).xsd for authorship and licensing information.</xs:documentation>
  </xs:annotation>
  <xs:include schemaLocation="UBIF_BasePattern.xsd"/>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Fundamental UBIF object types derived from the abstract type defined in UBIF object pattern (these already use elements from the core ontology!):</xs:documentation>
  </xs:annotation>
  <xs:complexType name="VersionedAbstractObject" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Adds RevisionData to AbstractObject</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractObject">
        <xs:group ref="RevisionData"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="OwnedAbstractObject" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Adds OwnerAndIPR and RevisionData to AbstractObject</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject">
        <xs:group ref="OwnerAndIPRStatements"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TaxonomicScopeSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Scope expressions limited to taxon name and publication citation.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="TaxonName" type="TaxonNameRef" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Refers to taxon names = names for classes of individuals. Multiple taxon names may express ambiguities or an operational grouping for which no higher taxon name exists (e. g., species from a geographical region).</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="Citation" type="Citation" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Source citation(s) for the object for which a scope is defined. If no Citation is given it is assumed that the compiler or editor of the data is the original source of information.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ExtendedScopeSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Scope expressed as taxon name, publication citation, plus specimen or geographical scope.

(Design note: The sequence of repeated scope elements, any of which may be missing may lead to empty elements using this type. However, the alternative design of a repeated choice, which may guarantee at least one scope, was rejected because it is not extensible.)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="TaxonomicScopeSet">
        <xs:sequence>
          <xs:element name="Specimen" type="SpecimenRef" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Refers to an individual physical object, which may be a collected and preserved object or an observation. Specimens may be derived from other specimens (a microscopic preparation, a picture derived from an observation). Conflicts may occur between the taxon names defined in scope and taxon names from Specimen identifications; these need to be resolved manually.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="GeographicArea" type="GeographicAreaRef" minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Descriptions may be specific to a geographic region. A taxon may have different morphology, molecular markers, etc. in different regions.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== The core ontology itself:</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Taxon names (includes taxon in the biological as well as a more general sense):</xs:documentation>
  </xs:annotation>
  <xs:complexType name="TaxonName">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Object type limited to taxon names (in the biological as well as a more general sense).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TaxonNameRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines an element with a ref attribute pointing to a TaxonName (in biology: Class = Taxon)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TaxonNameRefSeq">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A collection of TaxonNameRef type elements</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:sequence>
          <xs:element name="TaxonName" type="TaxonNameRef" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">Reference to a class name (in biology =  taxon name) defined in TaxonNames</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TaxonString">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A name string expressing the taxon as a literal, optionally plus references pointing to TaxonName objects (local ref or uri). Used, e.g., for genus parts in species names (multiple homonymic genus names may exist in same or different nomenclatural codes)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractShortStringPlusRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Taxon class hierarchy (biology: taxon concepts):</xs:documentation>
  </xs:annotation>
  <xs:complexType name="TaxonHierarchy">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Object type limited to class hierarchies (taxonomies)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TaxonHierarchyRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines an element with a ref attribute pointing to a TaxonHierarchy.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Specimens ('Unit' in ABCD, 'Object' in earlier versions of UBIF/SDD):</xs:documentation>
  </xs:annotation>
  <xs:complexType name="Specimen">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Object type limited physical objects that are collected, described, or observed (collected objects may be preserved permanently in a specimen collection).

Provides either a simple free-form descriptive label ('so-and-so in freezer 14, with tag 1233'), or links to an external collection specimen.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="SpecimenRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines an element with a ref attribute pointing to a Specimen object.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Publications, references, and citations:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="Publication">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Used for *references* to resources like publications, laboratory notes, speeches, etc. Provides either a simple free-form text, or a connection to an external resource.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="PublicationRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines an element with a ref attribute pointing to a Publication (Publications/Publication)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">--- The following types build on the Publication infrastructure:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="Citation">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Extending PublicationRef with location detail like page number within that publication. Citation is used without 'Ref'-suffix, which is considered implicit.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="PublicationRef">
        <xs:attribute name="location" type="ShortString" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Location within publication where the cited data can be found: Page, table, figure number, database record, html document bookmark, etc. This is not the page range of the entire article! 
If interpreted data differ from data in the cited source, it may occasionally be desirable to document this here. Example: location = "p. 3, sub Ustilago" if accepted genus in dataset is 'Microbotryum'.</xs:documentation>
            <xs:documentation xml:lang="x-internal">(Internal Note: equivalent to ABCD: ReferenceDetail; a term that was rejected in an SDD meeting.)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CitationString">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A name string expressing the publication as a literal, optionally plus references pointing to TaxonName objects (local ref or uri). Used, e.g., for genus parts in species names (multiple homonymic genus names may exist in same or different nomenclatural codes)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractShortStringPlusRef">
        <xs:attribute name="location" type="ShortString" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Location within publication where the cited data can be found: Page, table, figure number, database record, html document bookmark, etc. This is not the page range of the entire article! 
If interpreted data differ from data in the cited source, it may occasionally be desirable to document this here. Example: location = "p. 3, sub Ustilago" if accepted genus in dataset is 'Microbotryum'.</xs:documentation>
            <xs:documentation xml:lang="x-internal">(Internal Note: equivalent to ABCD: ReferenceDetail; a term that was rejected in an SDD meeting.)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Media (especially images, audio/video, but potentially also complex objects like html with images, pdf, etc.):</xs:documentation>
  </xs:annotation>
  <xs:complexType name="MediaObject">
    <xs:complexContent>
      <xs:extension base="OwnedAbstractObject">
        <xs:attributeGroup ref="optional_language"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">MediaObjectRef: In contrast to most reference types MediaObject references have already been defined in the abstract BasePattern schema, they are used in the base types Representation component.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Geography:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="GeographicArea">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Used for resources like geographical names or places. Provides either
a simple free-form text, or a
connection to an external resource.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">GeographicAreaRef: In contrast to most reference types GeographicArea references have already been defined in the abstract BasePattern schema, they are used in the base event type.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Agents (persons, organization, software agent):</xs:documentation>
  </xs:annotation>
  <xs:complexType name="Agent">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Used for Agent documentation (an Agent is a person, project, organization, or software agent). Currently used for authors, editors, contributors, and translators. Ideally it connects to an outside definition or documentation of the Agent.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AgentRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines an element with a required ref attribute pointing to an Agent (Agents/Agent)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractLocalRef"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">--- The following types build on the Agent infrastructure:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="AgentString">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A name string expressing the agent as a literal, optionally enriched (email, address), optionally plus references pointing to Agent objects (local ref or uri), used for authors, editors, collectors, etc., whenever the identity of an Agent often cannot be associated with an Agent without doubt (example: 2 authors J. Smith may be different persons, but 'J. Smith' and 'J. M. Smith' may be the same person)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AbstractShortStringPlusRef">
        <xs:attribute name="email" type="ShortString" use="optional"/>
        <xs:attribute name="phone" type="ShortString" use="optional"/>
        <xs:attribute name="address" type="ShortString" use="optional"/>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AgentStringSeq">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A collection (seq) of AgentStrings</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:sequence>
          <xs:element name="Agent" type="AgentString" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">A name string (in xml-element content) expressing the agent as a literal, optionally enriched (email, address), optionally plus exact identity with defined Agent objects (local ref or uri attributes). 

This is used for authors, editors, collectors, etc., when the identity of an Agent may remain uncertain.
Example: Two authors 'J. Smith' may be different persons, but 'J. Smith' and 'J. M. Smith' may be the same person. (The sequence of elements in instance documents is informative!)</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RichAgentRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Extension of AgentRef with a role attribute and three attributes recording object-specific contributions.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="AgentRef">
        <xs:attribute name="role" type="AgentRoleEnum" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">(constrained to enumerated values)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="firstcontribution" type="xs:dateTime" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The first time an agent (creator or contributor) has edited/made a contribution to an object. If a creator has contributed both as an author and later as an editor of data, two references in these two roles will exist and the contribution dates will be recorded separately.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="lastcontribution" type="xs:dateTime" use="optional"/>
        <xs:attribute name="contributioncount" type="xs:integer" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">The number of contributions by a specific agent (editing, revising, adding to an object).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CreatorRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Restriction of RichAgentRef to Creator roles only.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="RichAgentRef">
        <xs:attribute name="role" type="AgentCreatorRoleEnum" use="required"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CreatorRefSeq">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Collection (sequence) 
of Agent elements of 
type CreatorRef (Technical note: this and the similar type ContributorRefSeq, etc. could be viewed as a restriction of the base type "RichAgentRefSeq". This was valid under Xerces and xmlspy 2004. Xmlspy 2005, however, rejects this so that this has been disabled.)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:sequence>
          <xs:element name="Agent" type="CreatorRef" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(The sequence of elements in instance documents should be preserved. Within each role it is mandatory. Different roles may, however, be reported in separate sequences.)</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="CreatorContributorRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Restriction of RichAgentRef to either Creator or Contributor (but not Owner) roles.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="RichAgentRef">
        <xs:attribute name="role" type="AgentCreatorContribRoleEnum" use="required"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ContributorRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Restriction of RichAgentRef to Contributor roles only.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="RichAgentRef">
        <xs:attribute name="role" type="AgentContributorRoleEnum" use="required"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ContributorRefSeq">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Collection (sequence) 
of Agent elements of 
type ContributorRef</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:sequence>
          <xs:element name="Agent" type="ContributorRef" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(The sequence of elements in instance documents should be preserved. Within each role it is mandatory. Different roles may, however, be reported in separate sequences.)</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="OwnerRef">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Restriction of RichAgentRef to Owner roles only (contribution attributes prohibited).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="RichAgentRef">
        <xs:attribute name="role" type="AgentOwnerRoleEnum" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">See http://www.loc.gov/ marc.relators/own</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="firstcontribution" type="xs:dateTime" use="prohibited"/>
        <xs:attribute name="lastcontribution" type="xs:dateTime" use="prohibited"/>
        <xs:attribute name="contributioncount" type="xs:integer" use="prohibited"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="OwnerRefSeq">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Collection (sequence) 
of Agent elements of 
type OwnerRef</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Seq">
        <xs:sequence>
          <xs:element name="Agent" type="OwnerRef" maxOccurs="unbounded">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">(The sequence of elements in instance documents should be preserved. Within each role it is mandatory. Different roles may, however, be reported in separate sequences.)</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Statements are a special form of complex text expressions</xs:documentation>
  </xs:annotation>
  <xs:complexType name="IPRStatement">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Language/audience-specific IPR Statement (= role, Label, Details, URI)

Desirable external validation in this context: either a Label or a Detail text should be present.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="RepresentationReqrd">
        <xs:sequence>
          <xs:group ref="Extensions"/>
        </xs:sequence>
        <xs:attribute name="role" type="IRPStatementRoleEnum" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Role of statement (Copyright, Licence, Disclaimer, Acknowl., etc.)</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="href" type="xs:anyURI" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">An optional resource on the net providing details on the IPR statement (in addition to, or as an alternative to the details text).</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="IPRStatementSet">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Set of IPR statements. 

(Internal validation on element using this: each role value should occur only once.)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Set">
        <xs:sequence>
          <xs:element name="IPRStatement" type="IPRStatement" maxOccurs="unbounded"/>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:group name="OwnerAndIPRStatements">
    <xs:sequence>
      <xs:element name="Owners" type="OwnerRefSeq" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Entities having legal possession of the data content. Owners are defined for a data set, but usually not for individual objects (except media objects). </xs:documentation>
        </xs:annotation>
        <xs:unique name="Owners_UniqueRefAndRole">
          <xs:selector xpath="u:Agent"/>
          <xs:field xpath="@ref"/>
          <xs:field xpath="@role"/>
        </xs:unique>
      </xs:element>
      <xs:element name="IPRStatements" type="IPRStatementSet" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Copyright, terms of use, license and other IPR-related statements like disclaimer or acknowledgement. Giving a copyright statement and a (if possible public) licence is highly recommended! (~= DC.Rights)</xs:documentation>
        </xs:annotation>
        <xs:unique name="IPRStatmt_UniqueRole">
          <xs:selector xpath="u:IPRStatement"/>
          <xs:field xpath="@role"/>
        </xs:unique>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">--- Note: A modeling problem is that in instance documents Agents within a role are usually ordered (sequence), but different roles not (authors+editors = editors+authors). UBIF 1.0 until beta 14 (available on WIKI!), attempted to solve the problem by introducing a 2-layer collection with Creators/AgentRole[@role='aut']/Agent[@ref]. This has now been abandoned to reduce complexity.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">--- types related to Agent references:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="RevisionData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">RevisionData (creators, dates, revision) for the entire data set or individual objects.</xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="Creators" type="CreatorRefSeq">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">If RevisionData exist 
at all, at least one
creator(author or 
editor) is required.
(~= DC.Creators)</xs:documentation>
        </xs:annotation>
        <xs:unique name="Creators_UniqueRefAndRole">
          <xs:selector xpath="u:Agent"/>
          <xs:field xpath="@ref"/>
          <xs:field xpath="@role"/>
        </xs:unique>
      </xs:element>
      <xs:element name="Contributors" type="ContributorRefSeq" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">General contributors,
or translators.
(~= DC.Contributors)</xs:documentation>
        </xs:annotation>
        <xs:unique name="Contributors_UniqueRefAndRole">
          <xs:selector xpath="u:Agent"/>
          <xs:field xpath="@ref"/>
          <xs:field xpath="@role"/>
        </xs:unique>
      </xs:element>
      <xs:element name="DateCreated" type="xs:dateTime" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Date/time when the intellectual content (project, term, description, etc.) was created. Applications may initially set this to the system date for new data objects, but authors must be able to change it to an earlier date if necessary. If for legacy data this is imprecisely known, it may be missing here. Earlier versions in other data formats should then be mentioned in the copyright or acknowl. statements.
(~= DC.Date.Created)</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="DateModified" type="xs:dateTime" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Date/time of the last modification of the immediate object. If no information is available, the field should not be filled with the export date/time (for this see TechnicalMetadata/ @created). (~= DC.Date.Modified)</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="RevisionStatus" type="RevisionStatus" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Intended to be a rough estimate by authors/editors rather than exact statements. RevisionStatus expresses correctness of data already entered and an estimate of completeness relative to the stated scope (e. g. taxonomic or geographic scopes in the data set metadata). If the goal is to describe the frequent species of a taxonomic group, revision status may be 'FullyRevised' even if many species are missing.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="Version" type="Version" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Number and date of current version, where citable version management exists.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:group ref="Extensions"/>
    </xs:sequence>
  </xs:complexType>
  <xs:group name="RevisionData">
    <xs:sequence>
      <xs:element name="RevisionData" type="RevisionData" minOccurs="0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">(= Creators, Contributors, Date Created/Modified, Version, RevisionStatus)</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:group>
  <xs:complexType name="Version">
    <xs:attribute name="major" type="xs:nonNegativeInteger">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">The major version number ('1' in 1.2)
of the object content.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minor" type="ShortString">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">An optional minor version number
('2' in 1.2). Note that this must be string to support versions like '1.01'</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="revision" type="ShortString">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">An optional revision (or maintenance) version number
('4' in 1.2.4)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="modifier" type="ShortString">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Unconstrained text specifying status, stage, release type, build number, etc.; e. g., '.7265', ''beta', 'alpha', 'rc/release candidate 2', 'internal'. release status is assumed if empty/missing.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="issued" type="xs:dateTime">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Citable 'publication date' of the current version (comp. RevisionData/ DateCreated and DateModified for version-independent dates). The value must be missing if the current version is not yet published! (~= DC.Date.issued; http://purl.org/dc/terms/issued).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">--- (About group above (do not place this in group-annotation, to avoid displaying whenever group is used): An optional RevisionData element provided as a group to simplify reuse (esp. where restrictions are being used).)</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Audience definitions</xs:documentation>
  </xs:annotation>
  <xs:complexType name="Audience" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Audiences are an extension of language/culture codes, to capture expertise and other factors (= registers within a language). Examples: "Students", "General public", "Custom officers", "Farmers".</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="VersionedAbstractObject"/>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="AudienceCore">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">An Audience is a combination of an enumerated expertise category (pupil, beginner, expert) and a free-form scope definition. As a result, multiple audiences can be defined for the same expertise, distinguished only by their label.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="Audience">
        <xs:sequence>
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Properties describing
machine-readable
partial semantics for
an audience definition.</xs:documentation>
          </xs:annotation>
          <xs:element name="ExpertiseLevel" type="ExpertiseLevelEnum">
            <xs:annotation>
              <xs:documentation xml:lang="en-us">ExpertiseLevel is restricted to values from 0-5. These categories allow to communicate expected expertise between different applications using UBIF. Recommended interpretations:
0 = expertise level undefined
1 = elementary school (year 1 to 6);
2 = middle school (year 7 to 10);
3 = high school (year 11 above) and general public (trying to avoid any specialized terminology or jargon);
4 = university students or (partly) trained personnel (using terminology, but avoiding or explaining problematic terminology);
5 = experts (using the full range of terminology).</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">(AudienceIdentifier is defined in UBIF_ObjectTypePattern because audience is already used in the labels of the fundamental object type.)</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">(Note: It would be possible to remodel all object types using the same restriction plus extension in two steps. Using type-specific instance identifiers may be desirable when mapping the schema to programming languages. However, for the first release of UBIF this has ONLY been done here!)</xs:documentation>
  </xs:annotation>
 <xs:annotation>
    <xs:documentation xml:lang="en-us">Unified Biosciences Information Framework (UBIF) XML schema. This part provides controlled vocabularies (= enumerated values) both specific to biosciences and for general topics required in the context of biosciences data. See the main UBIF.xsd file for complete information, copyright and licensing.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Copyright © 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file UBIF_(c).xsd for authorship and licensing information.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Enumerations to support interoperability ===</xs:documentation>
    <xs:documentation xml:lang="en-us">Internal formatting note: Annotations of individual enumerated values should be written as "short label" + " -- " + "detailed information" or "[abbreviation]" + " -- " + "short label" + " -- " + "detailed information". Abbreviation must be enclosed in square brackets []. Additional specification information may be given for some enumerations in xs:appinfo. An xslt script transforms such schema annotations into a data document that can directly be used in user interfaces.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">An important feature of this schema file is that these enumerations may be turned into data, many of them including extra specification data. Please see UBIF-EnumerationTools for further information. Using the data files in application development rather than hardcoding enumerations in code enables simple adaption to future versions of UBIF.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- a) Generic enumerations</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="RevisionStatusEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Controlled vocabulary expressing the revision status as assessed by creators or editors or objects. It may apply to an entire data set as well as to individual objects (a specimen, a taxon name, a description, etc.). Exact semantics are defined only for the first and the last two categories. The semantics of the intermediate levels (1 to 5) may be chosen freely by the user (and associated with the actual, project dependend workflow, e.g. 'draft', 'review', 'approved', 'stable'). The added semantics should, however, conserve the order of revision status values. If, for example, three revision steps are planned (2 intermediate, reaching FullyRevised on third), it is recommended to use RevisionLevel2, RevisionLevel4, FullyRevised.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Unrevised">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Unrevised -- The data have been input, but no separate revision was performed.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RevisionLevel1">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Revision level 1 of 5 -- For example, in a collection less than ca. 20 % of the data are revised, or on a single object only a plausibility check has been performed.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RevisionLevel2">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Revision level 2 of 5 -- For example, in a collection ca. 41-60 % of the data are revised, or on a single object the data are compared carefully with the source.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RevisionLevel3">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Revision level 3 of 5 -- For example, ca. 41-60 % of the data are revised.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RevisionLevel4">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Revision level 4 of 5 -- For example, ca. 61-80 % of the data are revised.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="RevisionLevel5">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Revision level 5 of 5 -- For example, more than 80% revised (but not yet completed).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FullyRevised">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Revision completed -- The data are completely revised given the available time and the goals set for the project. This does not necessarily imply that the data are complete and perfectly revised in a scientific sense.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Deprecated">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Deprecated -- An object concept should no longer be used, but is not deleted because external data depend on it. This revision status applies, e.g. to definitions in shared descriptive terminologies.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ExpertiseLevelEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Controlled vocabulary expressing the expertise exprected or required from human consumers of data or services. Values are restricted to integer values from 0 to 5. 0 is defined as unspecified level, and 1 to 5 indicates expertise from schoolchildren to taxonomic expert. See the description of the values for recommendations for interpreting and choosing the expert level.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="ExpertiseLevel0">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">0 = Unspecified expertise level -- Use this if the expertise level of can not be assessed (e. g. when exporting data) or is considered irrelevant.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ExpertiseLevel1">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">1 = Elementary school (year 1 to 6)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ExpertiseLevel2">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">2 = Middle school (year 7 to 10)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ExpertiseLevel3">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">3 = High school (year 11 above) and general public -- When addressing this level specialized terminology or jargon should be avoided.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ExpertiseLevel4">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">4 = University students or (partly) trained staff -- This level uses specialized terminology, but avoids or explains problematic terms.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ExpertiseLevel5">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">5 = Experts -- This level uses the full range of terminology</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ResourceTypeEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">This enumeration is identical with the DCMI Type Vocabulary (http: //dublincore.org/documents/dcmi-terms/, as of 6/2004), except that an additional type "Other" has been added. Its purpose is to provide a framework of broad media or resource type terms, without the technical detail provided by the large number of MIME types. The annotations are largely based on those from the DublinCore metadata initiative vocabulary.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Collection">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Collection -- A collection is an aggregation of items. The term collection means that the resource is described as a group; its parts may be separately described and navigated.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Dataset">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Dataset -- A dataset is information encoded in a defined structure (for example, lists, tables, and databases), intended to be useful for direct machine processing.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Event">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Event -- An event is a non-persistent, time-based occurrence. Metadata for an event provides descriptive information that is the basis for discovery of the purpose, location, duration, responsible agents, and links to related events and resources. The resource of type event may not be retrievable if the described instantiation has expired or is yet to occur. Examples - exhibition, web-cast, conference, workshop, open-day, performance, battle, trial, wedding, tea-party, conflagration.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Image">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Image -- An image is a primarily symbolic visual representation other than text. For example - images and photographs of physical objects, paintings, prints, drawings, other images and graphics, animations and moving pictures, film, diagrams, maps, musical notation. Note that image may include both electronic and physical representations.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="InteractiveResource">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Interactive Resource -- An interactive resource is a resource which requires interaction from the user to be understood, executed, or experienced. For example - forms on web pages, applets, multimedia learning objects, chat services, virtual reality.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MovingImage">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Moving Image (Video) -- A series of visual representations that, when shown in succession, impart an impression of motion. Examples of moving images are: animations, movies, television programs, videos, zoetropes, or visual output from a simulation. Comment: Instances of the type "Moving Image" must also be describable as instances of the broader type "Image".</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PhysicalObject">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Physical Object -- An inanimate, three-dimensional object or substance. For example -- a computer, the great pyramid, a sculpture. Note that digital representations of, or surrogates for, these things should use Image, Text or one of the other types.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Service">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Service -- A service is a system that provides one or more functions of value to the end-user. Examples include: a photocopying service, a banking service, an authentication service, interlibrary loans, a Z39.50 or Web server.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Software">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Software -- Software is a computer program in source or compiled form which may be available for installation non-transiently on another machine. For software which exists only to create an interactive environment, use interactive instead.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Sound">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Sound -- A sound is a resource whose content is primarily intended to be rendered as audio. For example - a music playback file format, an audio compact disc, and recorded speech or sounds.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="StillImage">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Still Image -- A static visual representation. Examples of still images are: paintings, drawings, graphic designs, plans and maps. Comment: Recommended best practice is to assign the type "Text" to images of textual materials. Instances of the type "Still Image" must also be describable as instances of the broader type "Image".</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Text">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Text -- A text is a resource whose content is primarily words for reading. For example - books, letters, dissertations, poems, newspapers, articles, archives of mailing lists. Note that facsimiles or images of texts are still of the genre text. Text may contain embedded still image illustrations, e. g., formatted html pages.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Other">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Other -- Use this category if the resource does not seem to fit into any of the categories provided above.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TelephoneDeviceEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Kind of phone number: voice, fax, mobile, pager, modem. These enumerated values are identical with vCard 3.0 flags (several of which can be added to a single phone number; to represent this in the UBIF interface duplicate the phone number itself!)</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Voice">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">voice phone number</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Fax">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">fax number</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Mobile">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">mobile phone number</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Modem">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">modem number</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Pager">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">pager number</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="Rating1to5Enum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Enumeration restricted to integer values from 1 to 5, indicating an arbitrary rating (meaning, e. g., 1 = disagree strongly, 2 = rather disagree, 3 = neutral or undecided, 4 = rather agree, 5 = agree strongly). This enumeration is of limited usefulness and could be replaced by an restriction on integer, but using the enumeration the semantics of agreement/disagreement or positive/negative rating can be communicated in a culture-neutral way (in German 1 is generally considered best and 5 worst, in English 1 worst, 5 best...).</xs:documentation>
      <xs:documentation xml:lang="de">Aufzählung von ganzzahligen Werten zwischen 0 u. 5 für beliebige Bewertungsskalen. Beispiel für Interpretation der 5 Werte: 1 = ablehnend, 2 = eher ablehnend, 3 =neutral oder unentschieden, 4 = eher zustimmend, 5 = zustimmend)</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Rating0of5">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[0] -- Rating "0" -- Undecided (not yet rated).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Rating1of5">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[1] -- Rating "1" -- For example, "disagree strongly", or "very poor".</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Rating2of5">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[2] -- Rating "2" -- For example, "rather disagree", or "poor".</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Rating3of5">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[3] -- Rating "3" -- For example, "neutral", "average", "undecided".</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Rating4of5">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[4] -- Rating "4" -- For example, "rather agree", or "good".</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Rating5of5">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[5] -- Rating "5" -- For example, "agree strongly", or "very good".</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TextDirectionalityEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Values are ltr (left to right), rtl (right to left). Compare CSS2 and the XHTML 2.0 bi-directional text module. Note: A future UBIF version may also include lro/rlo = left-right-overide/right-left-overide, if this is found to be necessary.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="ltr">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[ltr] -- left-to-right text direction (e.g., English)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rtl">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[rtl] -- right-to-left text direction (e.g., Arabic)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="StringFormattingTypeEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Controlled vocabulary expressing whether and which kind of inline formatting may be contained in a text literal (plain, inline-entity-encoded, html-level-entity-encoded). In the absence of an attribute providing further specification, most UBIF text elements may contain "inline" entity-escaped formatting! (Other standards: ~=atom:title/@type)</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="plain">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[plain] -- plain, unformatted text -- The element contains plain text with no entity escaped html. The entire text will contain the same format, i.e. it can contain not superscript, subscript or italicized parts. Example: "Mg2Cl &gt; 10mMol" (xml-entities like greater-than are still entity escaped!). Other standards: atom:title/@type=text.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="inline">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[inline] -- formatted text using selected html inline elements -- The element contains html formatting from an enumerated list of html inline formatting commands: strong, em, b, i, sub, sup, br. Other html commands (including inline formatting like a and img) are not recognized. Example: "Mg&lt;sub&gt;2&lt;/sub&gt;Cl &gt; 10mMol". Note: the constrained list of formats enables processors with limited implementation cost to render the formatting in other formats than the html-family.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="html">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[html] -- formatted text using xhtml elements -- The element contains xhtml formatting commands for both inline and block level (paragraph, ordered list, etc.). Since content is entity-escaped, no validation occurs, but using xhtml is recommended and processors may reject non-xml content. Example: "Mg&lt;sub&gt;2&lt;/sub&gt;Cl &gt; 10mMol". Other standards: atom:title/@type=html. Note: atom provides a value "xhtml", in which case the element content is directly full xhtml (i.e. contains mixed content). Such mixed content formatting was provided in early proposals of UBIF, but was rejected because it created significantly increased implementation cost in applications, including xslt in general and xml-database conversions. See EncodedFormattingProposal.zip for further information.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MeasurementUnitPrefixEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Multiplication factor prefixes used in the scientific SI system (T, G, M, k, h, c, m, µ, n, p, f, a).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Tera">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[T] -- tera -- Prefix of measurement units, denoting 10 to the power of 12. Example: TW, terawatt.</xs:documentation>
          <xs:documentation xml:lang="de">[T] -- Tera -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 10 hoch 12.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>10E12</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Giga">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[G] -- giga -- Prefix of measurement units, denoting 10 to the power of 9. Example: GV, gigavolt.</xs:documentation>
          <xs:documentation xml:lang="de">[G] -- Giga -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 10 hoch 9.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>10E9</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Mega">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[M] -- mega -- Prefix of measurement units, denoting 10 to the power of 6. Example: MW, megawatt.</xs:documentation>
          <xs:documentation xml:lang="de">[M] -- Mega  -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 10 hoch 6.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>10E6</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="kilo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[k] -- kilo -- Prefix of measurement units, denoting 1000. Example: kg, kilogram.</xs:documentation>
          <xs:documentation xml:lang="de">[k] -- Kilo -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 1000.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>1000</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="hecto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[h] -- hecto -- Prefix of measurement units, denoting 100. Example: hPa, hectopascal.</xs:documentation>
          <xs:documentation xml:lang="de">[h] -- Hekto -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 100.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>100</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="deca">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[da] -- deca -- Prefix of measurement units, denoting 10. Example: daL, decaliter.</xs:documentation>
          <xs:documentation xml:lang="de">[da] -- Deka -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 10.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>10</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="noprefix">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[-] -- (none) -- No prefix, denoting factor or 1. Example: g, gram.</xs:documentation>
          <xs:documentation xml:lang="de">[-] -- (keine) -- Kein Prefix, entspricht einem Faktor von 1.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>1</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="deci">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[d] -- deci -- Prefix of measurement units, denoting a factor of 0.1. Example: dm, decimeter.</xs:documentation>
          <xs:documentation xml:lang="de">[d] -- Dezi -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 0.1.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>0.1</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="centi">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[c] -- centi -- Prefix of measurement units, denoting a factor of 0.01. Example: cm, centimeter.</xs:documentation>
          <xs:documentation xml:lang="de">[c] -- Centi -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 0.01.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>0.01</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="milli">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[m] -- milli -- Prefix of measurement units, denoting 10 to the power of -3. Example: mg, milligram.</xs:documentation>
          <xs:documentation xml:lang="de">[m] -- Milli -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 10 hoch -3.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>10E-3</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="micro">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[µ] -- micro -- Prefix of measurement units, denoting 10 to the power of -6. Example: µg, microgram.</xs:documentation>
          <xs:documentation xml:lang="de">[µ] -- Mikro -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 10 hoch -6.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>10E-6</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="nano">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[n] -- nano -- Prefix of measurement units, denoting 10 to the power of -9. Example: ng, nanogram.</xs:documentation>
          <xs:documentation xml:lang="de">[n] -- Nano -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 10 hoch -9.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>10E-9</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="pico">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[p] -- pico -- Prefix of measurement units, denoting 10 to the power of -12. Example: pmol, picomol.</xs:documentation>
          <xs:documentation xml:lang="de">[p] -- Piko -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 10 hoch -12.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>10E-12</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="femto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[f] -- femto -- Prefix of measurement units, denoting 10 to the power of -15. Example: fm, femtometer.</xs:documentation>
          <xs:documentation xml:lang="de">[f] -- Femto -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 10 hoch -15.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>10E-15</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="atto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[a] -- atto -- Prefix of measurement units, denoting 10 to the power of -18. Example: attotesla.</xs:documentation>
          <xs:documentation xml:lang="de">[a] -- Atto -- Prefix wissenschaftlicher Maßeinheiten, entspricht einem Faktor von 10 hoch -18.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:Factor>10E-18</ues:Factor>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- b) Statistical and data analysis categories</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="StatisticalMeasurementScaleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">In statistical analysis it is often vital to know some basic properties of the values that are being analyzed. Some of these properties can be summarized in the form of a measurement scale. Higher scales can always be analyzed under the assumptions of a lower scale (ordinal data can be analyzed as nominal, ratio as interval).</xs:documentation>
      <xs:documentation xml:lang="x-internal">In principal it would be desirable to define values in small enumerations, and then the supersets as:  xs:union memberTypes="QuantitativeMeasurementScaleEnum CategoricalMeasurementScaleEnum"/. Compare other comments for restriction-problems Xerces has with this.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Nominal">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">nominal -- unordered categorical states (DELTA character type 'UM')</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Ordinal">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">ordinal -- ordered categorical states (DELTA character type 'OM'). Unless a separate tree defines more specific ordering, the order is assumed to be linear in the sequence in which the categories are enumerated in their definition.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Interval">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">interval -- real numeric (= floating point) values, where 0 is an arbitrarily defined point. As a consequence, ratios are undefined and only the intervals between values can be analyzed. Example: Temperature in °C or °F.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Ratio">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">ratio -- real numeric (= floating point) values (DELTA: type 'RN'), where 0 is an objective point and ratios can thus be analyzed. Example: length measurements. Most measures belong into this category and it is acceptable to assume the 'ratio' scale when importing DELTA legacy data.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="QuantitativeMeasurementScaleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Those values from StatisticalMeasurementScaleEnum addressing numerical data ('ratio' and 'interval').  
Note: Occasionally "integer" or "cardinal" (versus real numbers) are also considered part of the measurement scale. This should be avoided because: a) All combinations of interval/ratio and discrete/continous are possible. b) The important distinction is whether a measurement is based on a continuous or discrete scale. Although in most cases this is equivalent with integer versus real numbers, it is not necessarily so. An ANOVA will report false significance not only when values come from "1, 2, 3 and 4", but also when they come from "1.2, 2.4, 3.6 and 4.8".</xs:documentation>
    </xs:annotation>
    <xs:restriction base="StatisticalMeasurementScaleEnum">
      <xs:enumeration value="Interval"/>
      <xs:enumeration value="Ratio"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="CategoricalMeasurementScaleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Those values from StatisticalMeasurementScaleEnum addressing categorical data ('nominal' and 'ordinal').</xs:documentation>
    </xs:annotation>
    <xs:restriction base="StatisticalMeasurementScaleEnum">
      <xs:enumeration value="Nominal"/>
      <xs:enumeration value="Ordinal"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DataStatusEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Status values (examples: "unavailable", "not applicable") identify standardized reasons why data are missing. Alternative names for this information are 'coding status', 'missing data indicators',  'special states', 'Null-values'. The annotation labels of the values can be freely changed as long as the semantics are preserved.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="ToBeChecked">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[!] -- To be checked -- Explicit indicator to revisit data later. This may occur when data are missing (known to exist, but not at hand for entering) or together with data (check  entered data against additional information source).</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:BasicStatus>ToBeCoded</ues:BasicStatus>
              <ues:InformationInSource>ProbablyExists</ues:InformationInSource>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ToBeIgnored">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[ø] -- Not to be recorded (a decision was made not enter data) -- (No DELTA equivalent exists. Implemented in Lucid 3 as "scope out".)</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:BasicStatus>NotToBeCoded</ues:BasicStatus>
              <ues:InformationInSource>ProbablyExists</ues:InformationInSource>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NotApplicable">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[-] -- Not applicable (data are assumed to be impossible to exist) -- The character has been studied, but is not applicable. Example are situations where the character cannot possibly exists (e. g. leaf-tip in a leaf-less plant) or where the method is unable to measure the current situation (e. g. a growth rate if available space is used before the time defined in the method). In the first situation it may be desirable to create a character dependency definition, making the scoring of individual characters no longer necessary. (Note: the DELTA equivalent is the '-'-state.)</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:BasicStatus>CannotBeCoded</ues:BasicStatus>
              <ues:InformationInSource>CannotExist</ues:InformationInSource>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DataUnavailable">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[?] -- Data unavailable (could not be obtained despite that an effort was made) -- The character has been studied and information has been searched, but not found. Use this to indicate that coding attempts should stop, perhaps until the next major revision. If data are currently unavailable, but attempts should continue, use '# = to be checked' instead. Compare also "not interpretable" if information found that is not interpretable. (Note: the DELTA equivalent is normally the 'U', but 'U' may also be used differently.)</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:BasicStatus>CannotBeCoded</ues:BasicStatus>
              <ues:InformationInSource>DoesNotExist</ues:InformationInSource>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NotInterpretable">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[#] -- Not interpretable (data known to exist, but interpretation considered too uncertain). -- The character has been studied and information has been found, but is impossible to score because the information is not interpretable under the current terminology. Using this status value warns collaborators that some information has already been studied (a specific annotation text accompanying the status value is recommend). Examples for using 'not interpretable': terms used in the source are undefined and cannot be guessed, the information in the source is contradictory, the color of a specimen is deteriorated so much that the original color can no longer be guessed. Note that in some cases an alternative to not coding at all may be to use certainty modifiers like 'perhaps' to make a tentative statement. (Note: no DELTA equivalent exists.)</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:BasicStatus>CannotBeCoded</ues:BasicStatus>
              <ues:InformationInSource>Exists</ues:InformationInSource>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DataWithheld">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[§] -- Data withheld (exist in source of current document, but private or confidential). --  (Note: no DELTA equivalent exists.)</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:BasicStatus>CodedSuccessfully</ues:BasicStatus>
              <ues:InformationInSource>Exists</ues:InformationInSource>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Statistical methods</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="UnivarAnyStatMeasureEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Enumerated list of univariate statistical methods. The list is intended to be more complete than normally necessary at least in biological morphometrics. If you still miss some measures, please request additions in a future version of this schema. Note: No satisfying external ontology for statistical methods could be found; the statistics section of MathML 2.0 (statistics.xsd) seems rather incomplete!</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="ObserverEstLower">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[-] -- Lower range limit (human estimate) -- Free estimate made by human observer for the lower range limit (no statistical sampling and calculation was used). This method is appropriate when it is known that the values are derived from experience with the described objects (perhaps from memory) or from scanning a sample of objects and measuring those objects considered 'typical'. This method is not appropriate for single measurements or for calculations based on statistical methods (which provide exact 'statistical estimates'). Compare also the 'UnknownMethod'-methods that are provided for legacy data.</xs:documentation>
          <xs:documentation xml:lang="de">[-] -- Untere Grenze (Schätzwert, ohne Berechnung) -- Freie Schätzung ohne Verwendung statistischer Probenahme und Berechnung.</xs:documentation>
          <xs:appinfo>
            <ues:Specification debuglabel="### This and the following methods cover non-statistical methods that are frequently encountered in taxonomic publications. They are specified with MethodClass = ObserverEstimate or UnknownMethod. Most other methods are implicitly derived from a generalized hypothetical 'StatisticalEstimate' method. ">
              <ues:StatMethodClass>ObserverEstimate</ues:StatMethodClass>
              <ues:ReportingClass>LowerRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ObserverEstUpper">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[+] -- Upper range limit (human estimate) -- Free estimate made by human observer for the upper range limit (no statistical sampling and calculation was used). This method is appropriate when it is known that the values are derived from experience with the described objects (perhaps from memory) or from scanning a sample of objects and measuring those objects considered 'typical'. This method is not appropriate for single measurements or for calculations based on statistical methods (which provide exact 'statistical estimates'). Compare also the 'UnknownMethod'-methods that are provided for legacy data.</xs:documentation>
          <xs:documentation xml:lang="de">[+] -- Obere Grenze (Schätzwert, ohne Berechnung) -- Freie Schätzung ohne Verwendung statistischer Probenahme und Berechnung.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>ObserverEstimate</ues:StatMethodClass>
              <ues:ReportingClass>UpperRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ObserverEstCentral">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[centr.] -- Central or typical value (human estimate) -- Free estimate made by human observer for a single central or typical value (no statistical sampling and calculation was used). This method is appropriate when it is known that the values are derived from experience with the described objects (perhaps from memory) or from scanning a sample of objects and measuring those objects considered 'typical'. It is not appropriate for single measurements nor for calculations based on statistical methods (which provide exact 'statistical estimates'). Compare also the 'UnknownMethod'-methods that are provided for legacy data.</xs:documentation>
          <xs:documentation xml:lang="en-us">[centr.] -- Mittlerer oder typischer Wert (Schätzwert, ohne Berechnung) -- Freie Schätzung ohne Verwendung statistischer Probenahme und Berechnung.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>ObserverEstimate</ues:StatMethodClass>
              <ues:ReportingClass>CentralMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UMethLower">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[-(?)] -- Lower range limit (legacy data, stat. meth. unknown) -- Lower range limit obtained by an unknown method (e. g. human observer estimate or some kind of statistical estimate). The range may, e. g., be mean plus/minus standard deviation, or a range estimate. 'Unknown' is important for legacy data where the statistical measure used is not known. If it is known that a measure is a human observer estimate rather than a defined value, the 'ObserverEstimate' methods should be used instead.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>UnknownMethod</ues:StatMethodClass>
              <ues:ReportingClass>LowerRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UMethUpper">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[+(?)] -- Upper range limit (legacy data, stat. meth. unknown) -- Upper range limit obtained by an unknown method (e. g. human observer estimate or some kind of statistical estimate). The range may, e. g., be mean plus/minus standard deviation, or a range estimate. 'Unknown' is important for legacy data where the statistical measure used is not known. If it is known that a measure is a human observer estimate rather than a defined value, the 'ObserverEstimate' methods should be used instead.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>UnknownMethod</ues:StatMethodClass>
              <ues:ReportingClass>UpperRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UMethCentral">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[centr.(?)] -- Central or typical value (legacy data, stat. meth. unknown) -- Central or typical value obtained by an unknown method (e. g. human observer estimate or some kind of statistical estimate). The central value may, e. g., be a single measurement, median, or arithmetic mean. 'Unknown' is important for legacy data where the statistical measure used is not known. If it is known that a measure is a human observer estimate rather than a defined value, the 'ObserverEstimate' methods should be used instead.</xs:documentation>
          <xs:documentation xml:lang="de">[Mittl.(?)] -- Mittlerer/typischer Wert (genaue Definition unbekannt)</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>UnknownMethod</ues:StatMethodClass>
              <ues:ReportingClass>CentralMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Min">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Min] -- Minimum value -- Absolute smallest value</xs:documentation>
          <xs:documentation xml:lang="de">[Min] -- Minimum -- Der kleinste beobachtete Wert</xs:documentation>
          <xs:appinfo>
            <ues:Specification debuglabel="### Minimum/maximum are generally semantically identical, regardless whether human observer estimates or statistical estimates have been used. They are therefore only provided as statistical estimates, and it is suggested that human estimates of minimum or maximum are treated as statistical estimates with unknown sample size. ">
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>LowerExtreme</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Max">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Max] -- Maximum value -- Absolute largest value</xs:documentation>
          <xs:documentation xml:lang="de">[Max] -- Maximum -- Der größte beobachtete Wert</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>UpperExtreme</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Mean">
        <xs:annotation>
          <xs:documentation source="http://encyclopedia.thefreedictionary.com/Arithmetic%20mean" xml:lang="en-us">[µ] -- Mean (= average) -- This is the normal, arithmetic mean.</xs:documentation>
          <xs:documentation xml:lang="de">[µ] -- Mittelwert -- Dies ist der normale, arithmetische Mittelwert.</xs:documentation>
          <xs:appinfo>
            <ues:Specification debuglabel="### This and the following are central measures: ">
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>CentralMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="HMean">
        <xs:annotation>
          <xs:documentation source="http://encyclopedia.thefreedictionary.com/harmonic%20mean" xml:lang="en-us">[hµ] -- Harmonic mean -- The harmonic mean (reciprocal of the arithmetic mean of reciprocals) is rarely used. Recommendation: if nothing specific is said about a "mean", it can safely be assumed to be an arithmetic mean.</xs:documentation>
          <xs:documentation xml:lang="de">[hµ] -- Harmonischer Mittelwert -- Der harmonische Mittelwert (Inverses des Mittelwert der inverses Werte) wird nur selten verwendet. Empfehlung: wenn keine genauere Angabe zu einem Mittelwert gemacht wird kann man davon ausgehen, dass es sich um den arithmetischen Mittelwert handelt.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>CentralMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="GeoMean">
        <xs:annotation>
          <xs:documentation source="http://encyclopedia.thefreedictionary.com/geometric%20mean" xml:lang="en-us">[gµ] -- Geometric mean -- The geometric mean (antilog of mean of logarithms) is relatively rarely used. Recommendation: if nothing specific is said about a "mean", it can safely be assumed to be an arithmetic mean.</xs:documentation>
          <xs:documentation xml:lang="de">[gµ] -- Geometrischer Mittelwert -- Der geometrische Mittelwert (Umkehrlogarithmus des Mittelwertes der logarithmierten Werte) wird nur sehr selten verwendet. Empfehlung: Wenn keine genauere Angabe zu einem Mittelwert gemacht wird kann man davon ausgehen, dass es sich um den arithmetischen Mittelwert handelt.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>CentralMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Mode">
        <xs:annotation>
          <xs:documentation source="http://encyclopedia.thefreedictionary.com/Mode" xml:lang="en-us">[mode] -- Mode -- The value or value class with the highest frequency (most frequently occurring). Applicable only to unimodal distributions.</xs:documentation>
          <xs:documentation xml:lang="de">[mod.] -- Modus</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>CentralMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Median">
        <xs:annotation>
          <xs:documentation source="http://encyclopedia.thefreedictionary.com/Median" xml:lang="en-us">[med.] -- Median -- The median is the 50 % percentile, i.e. 50% of the sampled values are smaller and the rest is larger than this value.</xs:documentation>
          <xs:documentation xml:lang="de">[med.] -- Median (Zentralwert) -- Der Median ist das 50% Quantil, d.h. 50% der Werte sind kleiner, und ebenso viele größer als dieser Wert.</xs:documentation>
          <xs:appinfo>
            <ues:Specification debuglabel="Note that the median is identical to a percentile with measure parameter 50%. Since percentiles have been split into upper and lower range limits, this is not possible, however. ">
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>CentralMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="InterqMean">
        <xs:annotation>
          <xs:documentation source="http://encyclopedia.thefreedictionary.com/interquartile%20mean" xml:lang="en-us">[IQM] -- Interquartile mean (= average) -- A truncated arithmetic mean, calculated only from those values that lie between 25 and 75% of sample values. This reduces the dependency of the mean on outliers and measurement errors.</xs:documentation>
          <xs:documentation xml:lang="de">[IQM] -- Interquartilsmittelwert -- Der arithmentische Mittelwert berechnet auf der Basis der in das symmetrische Intervall um den Median (= 50% der Beobachtungen) fallenden Werten.</xs:documentation>
          <xs:appinfo>
            <ues:Specification debuglabel="### End of central measures. ">
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>CentralMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Var">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Var.] -- Variance (sample, df = n-1) -- Variance based on a sample; calculated with n-1 (n = sample size) degrees of freedom. This is the "normal" variance used in almost all cases. A variance is a standard deviation squared.</xs:documentation>
          <xs:documentation xml:lang="de">[Var.] -- Varianz (Stichprobe, Freiheitsgrade = n-1) -- Streuung der Werte in einer Stichprobe, berechnet mit n-1 Freiheitsgraden (n = Stichprobenumfang). Dies ist die "normale" Varianz die in fast allen Fällen verwendet wird.</xs:documentation>
          <xs:appinfo>
            <ues:Specification debuglabel="### This and the following are variance measures. Note that most are dimensionless with the exception of the interquartile range. NOTE: Although not entirely true (the dimension of the variance is the square of the measurement unit), for practical purposes it may be treated as dimensionless. ">
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>true</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="VarP">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Var. (pop.)] -- Variance (population; df = n; rarely applicable!) -- Variance of population, calculated with n (= sample size) degrees of freedom. Use this if the entire population of objects has been studied. Normally conclusions about the population are based on a sample that has been studied; in this case the "normal" variance with df = n-1 is appropriate.</xs:documentation>
          <xs:documentation xml:lang="de">[Var./G] -- Varianz (Grundgesamtheit, n Freiheitsgrade) -- Varianz einer Grundgesamtheit, berechnet mit n (= Stichprobenumfang) Freiheitsgraden. In den meisten Fällen macht man Rückschlüsse auf die Grundgesamtheit anhand einer Stichprobe; in diesem Fall ist die "normale" Standardabweichung mit n-1 Freiheitsgraden zu verwenden.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalParameter</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>true</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SD">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[s.d.] -- Standard deviation (sample) -- Standard deviation based on a sample, calculated with n-1 (n = sample size) degrees of freedom. This is the "normal" standard deviation used in almost all cases.</xs:documentation>
          <xs:documentation xml:lang="de">[Std.Abw.] -- Standardabweichung (Stichprobe, Freiheitsgrade = n-1) -- Standardabweichung einer Stichprobe, berechnet mit n-1 Freiheitsgraden (n = Stichprobenumfang). Dies ist die "normale" Standardabweichung die in fast allen Fällen verwendet wird.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SDP">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[s.d. (pop.)] -- Standard deviation (population; df = n; rarely applicable!) -- Standard deviation based on the entire population; calculated with n (= sample size) degrees of freedom. Use this if the entire population of objects has been studied. Normally conclusions about the population are based on a sample that has been studied; in this case the "normal" std. dev. with df = n-1 is appropriate.</xs:documentation>
          <xs:documentation xml:lang="de">[Std.Abw./G] -- Standardabweichung (Grundgesamtheit; n Freiheitsgrade) -- Standardabweichung einer Grundgesamtheit; berechnet mit n (= Stichprobenumfang) Freiheitsgraden. In den meisten Fällen macht man Rückschlüsse auf die Grundgesamtheit anhand einer Stichprobe; in diesem Fall ist die "normale" Standardabweichung mit n-1 Freiheitsgraden zu verwenden.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalParameter</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MeanDev">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[m.d.] -- Mean deviation -- The mean of the absolute differences from the arithmetic mean of values. The absolute differences are the positive, unsquared differences from the mean.</xs:documentation>
          <xs:documentation xml:lang="de">[Mittl.Abw.] -- Mittlere Abweichung.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalParameter</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MeanDevMode">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[m.d.m.] -- Mean deviation from median -- The mean of the absolute differences from the median of values. The absolute differences are the positive, unsquared differences from the mode.</xs:documentation>
          <xs:documentation xml:lang="de">[Mittl.Abw.] -- Mittlere Abweichung vom Median.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalParameter</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CV">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[CV] -- Coefficient of variation (sample) -- Standard deviation (based on a sample), divided by the mean. The values entered should not be expressed as percent, but converted to a true value (use '0.3' for 30%). According to Sokal &amp; Rohlf 1981:59 this is a biased estimate, which may be corrected, compare 'CVC'.</xs:documentation>
          <xs:documentation xml:lang="de">[VK] -- Varianzkoeffizient (Stichprobe, Freiheitsgrade = n-1) -- Standardabweichung einer Stichprobe (n-1 Freiheitsgrade) geteilt durch den Mittelwert.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>true</ues:IsDimensionless>
              <ues:ValueIsPercentage>true</ues:ValueIsPercentage>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CVC">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[CVC] -- Corrected coefficient of variation (sample) -- Corrected coefficient corrected by (1 + (1/4n)). Compare, e. g., Sokal &amp; Rohlf 1981:59'.</xs:documentation>
          <xs:documentation xml:lang="de">[VK] -- Korrigierter Varianzkoeffizient (Stichprobe, Freiheitsgrade = n-1) -- Varianzkoeffizient korrigiert mit (1 + (1/4n)). Vergleiche Sokal &amp; Rohlf 1981:59'.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>true</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="TotalRange">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[TR] -- Total range -- The maximum value minus the minimum value. Also often called "Range" without further qualification like 'absolute', 'total'. This measure can normally be computed automatically based on minimum and maximum. It will be manually entered, if minimum and maximum are not separately cited in a publication.</xs:documentation>
          <xs:documentation xml:lang="de">[TR] -- Gesamtdifferenz -- Maximum minus Minimum.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="InterqRange">
        <xs:annotation>
          <xs:documentation source="http://encyclopedia.thefreedictionary.com/interquartile%20range" xml:lang="en-us">[IQR] -- Interquartile range -- This is the length of a symmetric interval around median, containing 50% of observations.</xs:documentation>
          <xs:documentation xml:lang="de">[QD] -- Quartilsdifferenz -- Dies ist die Länge eines symmetrischen Intervalls um den Median welches 50% der Beobachtungen enthält.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SEMean">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[s.e.] -- Standard error of mean -- The standard error of mean is defined as: "std. dev. / square root(n)" (with n = sample size)</xs:documentation>
          <xs:documentation xml:lang="de">[SF] -- Standardfehler (Mittelwert)</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>VarianceMeasure</ues:ReportingClass>
              <ues:IsDimensionless>true</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SEVar">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[s.e.(var.)] -- Standard error of variance (of multiple samples) -- This is not a variance measure of the mean, but a measure of the variance of the variance estimates.</xs:documentation>
          <xs:documentation xml:lang="de">[SF (var.)] -- Standardfehler der Varianz (bei multiple samples) -- Der Standardfehler der Varianz kann nur bei mehreren Stichproben bestimmt werden. Dies ist kein Streuungsmaß für den Mittelwert, sondern ein Maß für die Streuung der Varianzschätzungen!</xs:documentation>
          <xs:appinfo>
            <ues:Specification debuglabel="(ReportingClass = Other because not variance measure of mean!) ">
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>Other</ues:ReportingClass>
              <ues:IsDimensionless>true</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Skew">
        <xs:annotation>
          <xs:documentation source="http://encyclopedia.thefreedictionary.com/skewness" xml:lang="en-us">[Skw.] -- Skewness -- Coefficient of skewness of a distribution, a measure of the degree of asymmetry of a distribution around its mean: &lt;0 if mode &lt; median, =0 if symmetric, &gt; 0 if mode &gt; median.</xs:documentation>
          <xs:documentation xml:lang="de">[Sch.] -- Schiefe -- Schiefe der Verteilung: &lt;0 wenn Modus &lt; Median, =0 wenn symmetrisch, &gt; 0 wenn Modus &gt; Median.</xs:documentation>
          <xs:appinfo>
            <ues:Specification debuglabel="### This and the following are other distribution measures (other than range, central, variance): ">
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>Other</ues:ReportingClass>
              <ues:IsDimensionless>true</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Kurt">
        <xs:annotation>
          <xs:documentation source="http://encyclopedia.thefreedictionary.com/kurtosis" xml:lang="en-us">[Kurt.] -- Kurtosis -- Coefficient of kurtosis of distribution, a measure of the "peakedness" of a distribution.  A normal distribution has a value of 0.263, larger values indicate wider, smaller narrower distributions.</xs:documentation>
          <xs:documentation xml:lang="de">[Kurt.] -- Kurtosis -- Exzess (Kurtosis) der Verteilung. Eine Normalverteilung hat einen Wert von 0,263, größere Werte zeigen zu breite, kleinere Werte zu schmale Verteilungen an.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>Other</ues:ReportingClass>
              <ues:IsDimensionless>true</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="N">
        <xs:annotation>
          <!-- the sequence of de and en is purposefully swapped here to make clear that it is not informative! -->
          <xs:documentation xml:lang="de">[n] -- Stichprobenumfang -- Die Anzahl der Beobachtungen auf denen die angegebenen statistischen Maße (Mittelwert, Standardabweichung, etc.) beruhen.</xs:documentation>
          <xs:documentation xml:lang="en-us">[n] -- Sample size -- The number of objects studied and on which the other reported statistical measures (mean, standard deviation, etc.) are based.</xs:documentation>
          <xs:appinfo>
            <ues:Specification debuglabel="### Sample size is in a class of its own! ">
              <ues:StatMethodClass>StatisticalParameter</ues:StatMethodClass>
              <ues:ReportingClass>SampleSize</ues:ReportingClass>
              <ues:IsDimensionless>true</ues:IsDimensionless>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ConfIntervalLower">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[-CI{ParameterValue}] -- Lower limit of {ParameterValue}% confidence interval for mean. -- The confidence interval is defined as a range into which the true mean of the distribution falls with a certain probability. The parameter expresses the confidence level in percent. Typical values are: 99.9% (= 0.05% from left!), 99% (= 0.5% from left), 95% (= 2.5% from left), 90% (= 5% from left).</xs:documentation>
          <xs:documentation xml:lang="de">[-CI{ParameterValue}] -- Untere Grenze des {ParameterValue}%-Konfidenzintervalls für den Mittelwert</xs:documentation>
          <xs:appinfo>
            <ues:Specification debuglabel="This and the following are statistical range measures:">
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>LowerRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
              <ues:ParameterIsPercentage>true</ues:ParameterIsPercentage>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ConfIntervalUpper">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[+CI{ParameterValue}] -- Upper limit of {ParameterValue}% confidence interval for mean. -- The confidence interval is defined as a range into which the true mean of the distribution falls with a certain probability. The probability is expressed in percent in a parameter called; typical values are: 99.9 (= 99.95% from left!), 99 (= 99.5% from left), 95 (= 97.5% from left), 90 (= 95% from left).</xs:documentation>
          <xs:documentation xml:lang="de">[+CI{ParameterValue}] -- Obere Grenze des {ParameterValue}%-Konfidenzintervalls für den Mittelwert</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>UpperRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
              <ues:ParameterIsPercentage>true</ues:ParameterIsPercentage>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PercLower">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[-P{ParameterValue}] -- {ParameterValue}% percentile -- The {ParameterValue}% percentile is defined such that {ParameterValue}% of the observations are smaller than this value. Typical parameter values are 2.5, 5, 10, 15, 20, 25 (= 1st quartile), 30. Do not use 50; use the 'Median' measure instead!</xs:documentation>
          <xs:documentation xml:lang="de">[-P{ParameterValue}] -- {ParameterValue}% Quantil -- Das {ParameterValue}%Quantil ist der Wert der größer oder gleich {ParameterValue}% der Beobachtungen ist.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>LowerRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
              <ues:ParameterIsPercentage>true</ues:ParameterIsPercentage>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PercUpper">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[+P{ParameterValue}] -- {ParameterValue}% percentile -- The {ParameterValue}% percentile is defined such that {ParameterValue}% of the observations are smaller than this value. Typical parameter values are 70, 75 (= 3rd quartile), 80, 90, 95, 97.5. Do not use 50; use the 'Median' measure instead!</xs:documentation>
          <xs:documentation xml:lang="de">[+P{ParameterValue}] -- {ParameterValue}% Quantil -- Das {ParameterValue}%Quantil ist der Wert der größer oder gleich {ParameterValue}% der Beobachtungen ist.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>UpperRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
              <ues:ParameterIsPercentage>true</ues:ParameterIsPercentage>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="TrimMean">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[+TM{ParameterValue}] -- {ParameterValue}% trim mean -- The arithmetic mean of the symmetric {ParameterValue}% interior portion of a set of data values.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>UpperRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
              <ues:ParameterIsPercentage>true</ues:ParameterIsPercentage>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SDRangeLower">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[µ - {ParameterValue} s.d.] -- Mean minus {ParameterValue} stand. deviation(s) -- Lower limit of a range calculated as mean minus standard deviations. The parameter ParameterValue (here {ParameterValue}) defines a factor with which the s.d. is multiplied before it is substracted from the mean. Typical parameter values are 1 or 2.</xs:documentation>
          <xs:documentation xml:lang="de">[µ - {ParameterValue} Std.abw.] -- Mittelwert minus {ParameterValue} Standardabweichung(en).</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>LowerRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
              <ues:ParameterIsPercentage>false</ues:ParameterIsPercentage>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SDRangeUpper">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[µ + {ParameterValue} s.d.] -- Mean plus {ParameterValue} stand. deviation(s) -- Upper limit of a range calculated as mean plus standard deviations. The parameter ParameterValue (here {ParameterValue}) defines a factor with which the s.d. is multiplied before it is added to the mean. Typical parameter values are 1 or 2.</xs:documentation>
          <xs:documentation xml:lang="de">[µ + {ParameterValue} Std.abw.] -- Mittelwert plus {ParameterValue} Standardabweichung(en).</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>UpperRange</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
              <ues:ParameterIsPercentage>false</ues:ParameterIsPercentage>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MinOC">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Min\{ParameterValue} s.d.] -- Minimum; outlier corrected ({ParameterValue} std. dev.) -- Absolute minimum value of sample, excluding outlier values more than {ParameterValue} standard deviations distant from the mean. Typical parameter values are 3 or 4.</xs:documentation>
          <xs:documentation xml:lang="de">[Min\{ParameterValue} Std.abw.] -- Minimum; Outlier-korrigiert ({ParameterValue} std. dev.).</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>LowerExtreme</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
              <ues:ParameterIsPercentage>false</ues:ParameterIsPercentage>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MaxOC">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Max\{ParameterValue} s.d.] -- Maximum; outlier corrected ({ParameterValue} std. dev.) -- Absolute maximum value of sample, excluding outlier values more than {ParameterValue} standard deviations distant from the mean. Typical parameter values are 3 or 4.</xs:documentation>
          <xs:documentation xml:lang="de">[Max\{ParameterValue} Std.abw.] -- Maximum; Outlier-korrigiert ({ParameterValue} std. dev.).</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:StatMethodClass>StatisticalEstimate</ues:StatMethodClass>
              <ues:ReportingClass>UpperExtreme</ues:ReportingClass>
              <ues:IsDimensionless>false</ues:IsDimensionless>
              <ues:ParameterIsPercentage>false</ues:ParameterIsPercentage>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="UnivarSimpleStatMeasureEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">An enumeration of univariate statistical measures supported by UBIF (esp. used by SDD). Compare also UnivarParamStatMeasureEnum, containing further statistical measures that use an additional parameter (for percentage of percentile or confidence interval, etc.).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="UnivarAnyStatMeasureEnum">
      <xs:enumeration value="ObserverEstLower"/>
      <xs:enumeration value="ObserverEstUpper"/>
      <xs:enumeration value="ObserverEstCentral"/>
      <xs:enumeration value="UMethLower"/>
      <xs:enumeration value="UMethUpper"/>
      <xs:enumeration value="UMethCentral"/>
      <xs:enumeration value="Min"/>
      <xs:enumeration value="Max"/>
      <xs:enumeration value="Mean"/>
      <xs:enumeration value="HMean"/>
      <xs:enumeration value="GeoMean"/>
      <xs:enumeration value="Mode"/>
      <xs:enumeration value="Median"/>
      <xs:enumeration value="InterqMean"/>
      <xs:enumeration value="Var"/>
      <xs:enumeration value="VarP"/>
      <xs:enumeration value="SD"/>
      <xs:enumeration value="SDP"/>
      <xs:enumeration value="MeanDev"/>
      <xs:enumeration value="MeanDevMode"/>
      <xs:enumeration value="CV"/>
      <xs:enumeration value="CVC"/>
      <xs:enumeration value="TotalRange"/>
      <xs:enumeration value="InterqRange"/>
      <xs:enumeration value="SEMean"/>
      <xs:enumeration value="SEVar"/>
      <xs:enumeration value="Skew"/>
      <xs:enumeration value="Kurt"/>
      <xs:enumeration value="N"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="UnivarParamStatMeasureEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">An enumeration of parameterized univariate statistical measures supported by UBIF (esp. used by SDD). This enumeration is similar to UnivarSimpleStatMeasureEnum, but here a parameter value is supported. Abbreviation, Label and Details (within xs:documentation) may contain the string "{ParameterValue}". Labels are expected to become meaningful if this is replaced with the actual parameter value.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="UnivarAnyStatMeasureEnum">
      <xs:enumeration value="ConfIntervalLower"/>
      <xs:enumeration value="ConfIntervalUpper"/>
      <xs:enumeration value="PercLower"/>
      <xs:enumeration value="PercUpper"/>
      <xs:enumeration value="TrimMean"/>
      <xs:enumeration value="SDRangeLower"/>
      <xs:enumeration value="SDRangeUpper"/>
      <xs:enumeration value="MinOC"/>
      <xs:enumeration value="MaxOC"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- c) Agent role codes</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="AgentRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Provides codes for roles like author, editor, photographer, advisor, or copyright holder. The roles and their codes used here are based on http://www.loc.gov/marc.relators/ (as of 2004/6 available at http://dublincore.org/usage/meetings/2004/03/Relator-codes.html). For example, the enumerated code "aut" for author corresponds to http://www.loc.gov/marc.relators/aut. The DublinCore Agents group is considering using the same codes (see e. g. http://www.loc.gov/marc/dc/Agent-roles.html), but as of 2004/6 the DublinCore Agents subgroup did not yet agree on a Creator/Contributor refinement as qualified DublinCore. Note that the roles selected here are a subset of the roles that are available in MARC. See second annotation for reasons of not using a union-design, which would be easier to maintain!</xs:documentation>
      <xs:documentation xml:lang="x-Internal">Technical note: It would be preferable to define the values in separate enumerations and define this as xs:union memberTypes="AgentCreatorRoleEnum AgentContributorRoleEnum AgentOwnerRoleEnum". However, whereas XML Spy accepts this, Stylus Studio and Xerces have problems in accepting that a member type of a union may be a restriction of the union type including this member. Furthermore, Xerces has problems in understanding that a union of two types, each of which is a restrictions of QName, may be a restriction of QName. Therefore, as of 2005-03, a long enumeration is defined here which is then restricted to shorter enumerations. - Gregor Hagedorn</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="aut">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Author -- A person or corporate body chiefly responsible for the intellectual or artistic content of a work. This term may also be used when more than one person or body bears such responsibility.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="edt">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Editor -- A person who prepares for publication a work not primarily his/her own, such as by elucidating text, adding introductory or other critical matter, or technically directing an editorial staff.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cre">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Creator in general -- A person or corporate body responsible for the intellectual or artistic content of a work. The more specific type Author [aut] or Editor [edt] should be preferred.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ill">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Illustrator -- The person who conceives, and perhaps also implements, a design or illustration, usually to accompany a written text.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="pht">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Photographer -- The person or organization responsible for taking photographs, whether they are used in their original form or as reproductions.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ctb">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Contributor in general -- Someone whose work has been contributed to a larger work, such as an anthology, serial publication, or other compilation of individual works. Do not use for someone whose sole function in relation to a work is as author, editor, compiler or translator.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="trl">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Translator -- A person who renders a text from one language into another, from an older form of a language into the modern form, or from one audience-specific representation to one appropriate for another audience.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="trc">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Transcriber -- A person who prepares a handwritten or typewritten copy from original material, including from dictated or orally recorded material.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="clb">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Collaborator -- A person or corporate body that takes a limited part in the elaboration of a work of another person or corporate body that brings complements (e.g., appendices, notes) to the work.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="col">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Collector -- A person who has brought together material from various sources, which has been arranged, described, and catalogued as a collection. The collector is neither the creator of the material nor the person to whom manuscripts in the collection may have been addressed.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="crp">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Correspondent -- A person or organization who was either the writer or recipient of a letter or other communication.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="prg">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Programmer -- A person or corporate body responsible for the creation and/or maintenance of computer program design documents, source code, and machine-executable digital files and supporting documentation.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rth">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Research team head -- The person or corporate body that directed or managed a research project.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rtm">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Research team member -- The person or corporate body that participated in a research project but whose role did not involve direction or management of it.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="res">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Researcher -- The person or corporate body responsible for performing research.
</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sad">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Scientific advisor -- A person who brings scientific, pedagogical, or historical competence to the conception and realization on a work, particularly in the case of audio-visual items.
</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="pfr">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Proofreader -- A person who corrects text (orthography, grammar).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="mrk">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Markup editor -- The person or organization performing the coding of SGML, HTML, or XML markup of metadata, text, etc.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cmm">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Commentator -- A person who provides interpretation, analysis, or a discussion of the subject matter on a recording, motion picture, or other audiovisual medium.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="rev">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Reviewer -- A person or corporate body responsible for the review of book, motion picture, performance, etc.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="csl">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Consultant -- The person called upon for professional advice or services in a specialized field of knowledge or training.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="own">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Owner -- The person or organization that currently owns an item or collection.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="fmo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Former owner -- The person or organization who owned an item at any time in the past. Includes those to whom the material was once presented. The person or organization giving the item to the present owner is designated as Donor [dnr]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cph">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Copyright holder -- A person or organization owning the copyright of the material.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cpc">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Copyright claimant -- The person listed as a copyright owner at the time of registration. Copyright can be granted or later transferred to another person or agent, at which time the claimant becomes the copyright holder.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="dnr">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Donor -- The donor of a book, manuscript, etc., to its present owner. Donors to previous owners are designated as Former owner [fmo]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="dpt">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Depositor -- A person or organization placing material in the physical custody of a library or repository without transferring the legal title.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AgentCreatorContribRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Union of AgentCreatorRoleEnum and AgentContributorRoleEnum, but no Owner roles. Technical note: currently this is modeled somewhat strangely as an xml-schema restriction of AgentRoleEnum (= union of all three basic role groups). This is a workaround for a problem Xerxes 2.6.2 detected by Jacob Asiedu! We hope that in the future the whole 'xs:restriction' below can be replaced again with the much more straightforward 'xs:union memberTypes="AgentCreatorRoleEnum AgentContributorRoleEnum"/' (= union of the two intended AgentRole enumerations).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="AgentRoleEnum">
      <xs:enumeration value="aut"/>
      <xs:enumeration value="edt"/>
      <xs:enumeration value="cre"/>
      <xs:enumeration value="ill"/>
      <xs:enumeration value="pht"/>
      <xs:enumeration value="ctb"/>
      <xs:enumeration value="trl"/>
      <xs:enumeration value="trc"/>
      <xs:enumeration value="clb"/>
      <xs:enumeration value="col"/>
      <xs:enumeration value="crp"/>
      <xs:enumeration value="prg"/>
      <xs:enumeration value="rth"/>
      <xs:enumeration value="rtm"/>
      <xs:enumeration value="res"/>
      <xs:enumeration value="sad"/>
      <xs:enumeration value="pfr"/>
      <xs:enumeration value="mrk"/>
      <xs:enumeration value="cmm"/>
      <xs:enumeration value="rev"/>
      <xs:enumeration value="csl"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AgentCreatorRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Enumeration of roles supported for creator agents. See AgentRoleEnum for information about the MARC relator codes.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="AgentRoleEnum">
      <xs:enumeration value="aut"/>
      <xs:enumeration value="edt"/>
      <xs:enumeration value="cre"/>
      <xs:enumeration value="ill"/>
      <xs:enumeration value="pht"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AgentContributorRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Enumeration of supported roles for contributor agents. See AgentRoleEnum for information about the MARC relator codes.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="AgentRoleEnum">
      <xs:enumeration value="ctb"/>
      <xs:enumeration value="trl"/>
      <xs:enumeration value="trc"/>
      <xs:enumeration value="clb"/>
      <xs:enumeration value="col"/>
      <xs:enumeration value="crp"/>
      <xs:enumeration value="prg"/>
      <xs:enumeration value="rth"/>
      <xs:enumeration value="rtm"/>
      <xs:enumeration value="res"/>
      <xs:enumeration value="sad"/>
      <xs:enumeration value="pfr"/>
      <xs:enumeration value="mrk"/>
      <xs:enumeration value="cmm"/>
      <xs:enumeration value="rev"/>
      <xs:enumeration value="csl"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AgentOwnerRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Enumeration of supported roles for owner/copyright agents. See AgentRoleEnum for information about the MARC relator codes.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="AgentRoleEnum">
      <xs:enumeration value="own"/>
      <xs:enumeration value="fmo"/>
      <xs:enumeration value="cph"/>
      <xs:enumeration value="cpc"/>
      <xs:enumeration value="dnr"/>
      <xs:enumeration value="dpt"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- d) Label/Title/Detail roles, Media representation roles, Link relationships, IPR Statement roles</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="LabelRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Controlled vocabulary expressing the kind of label text. These are currently highly constrained, but either additional values or free extensibility (by union of this enum type with xs:anyURI) are expected for future releases of UBIF.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Full">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[full] -- full label -- Free-form label text designed to be as concise and expressive as possible while remaining intuitive and (locally) unique. Depending on the object type, this label may often be called 'name' or a 'title'. The recommended length is less than 80 characters; longer text (up to 255 char.) is supported but human user interface software may be optimized for shorter labels. Text is recommended to be unique within dataset, object type, and language/audience combination. A full label may contain abbreviations but is not usually considered an abbreviated label itself. It should uniquely identify an object, but multiple full labels may exist. -- Examples: Agent 'Gregor Hagedorn, BBA, Berlin', 'G. Hagedorn, Biol. Bundesanstalt'; Taxon 'Ascochyta aceris Fuckel', 'Ascochyta aceris Lib.', 'Ascochyta aceris Sacc.' or 'Ascochyta aceris Saccardo'. -- Other standards: ~= DC.Title.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Short">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[short] -- short label -- Short label text designed to represent an object in user interfaces or reports (esp. in tabular format) where space considerations are more important than intuitive understanding or readability. The text short label may be context dependent and may contain unusual abbreviations that require knowledge of the full/concise label to be intelligable. The recommended length is less than 20 characters (including blanks); longer text (up to 255 char.) is supported but may not be readable in all human user interface designs. When missing, applications may attempt to abbreviate the full label, which may result in duplicate labels, however.  Text is recommended to be unique within dataset, object type, and language/audience combination. -- Examples: Agent 'G. Hagedorn'; Taxon 'Asc. aceris Fck.'.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Abbrev">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[abbrev.] -- abbreviation -- A label text abbreviated as far as possible while remaining unique within a dataset. When missing, applications may attempt to abbreviate the short or full label, which may result in duplicate labels, however.  Text is recommended to be unique within dataset, object type, and language/audience combination. -- Examples: Agent 'GH'; Taxon 'A.aceris' (assuming the dataset contains no other Genus abbreviated as 'A.' with a species epithet 'aceris').</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Token">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[token] -- token/variable name -- A highly constrained version of the label designed for exports to applications requiring very short and simple object names, such as fields in databases and variable names in phylogenetic or statistical analysis software like NEXUS or SAS, which often must be short, not having blanks or punctuation, etc. The application for which a token label is designed may be specified using a custom language value, e.g. 'x-SAS', 'x-NEXUS'. -- Examples: Agent 'GHAGE'; Taxon 'AscAceris'.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Sort">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[sort.] -- sorting string -- A string that results in a desired sorting order when sorted with a standard, case-insensitive unicode sorting routine. The most important problems addressed here are word or token order, leading articles, and quoting marks (see examples). Other problems (special locale-specific sorting rules for accented characters like 'ü'='ue' in German but 'u' in Spanish, 'rr/ll' sorted after 'r/l' in Spanish, or character ligatures may or may not be addressed, depending on the data available to the provider. Where the provider has a choice, it is recommended *not* to address these problems, since sorting may be desirable according to rules defines defined in the locale of the consumer, not the provider. Current unicode-based data handling software often provides sufficient locale-specific sorting rules for accented or ligature characters. Problem: The provider may have stored all-uppercase sort-strings. This is not recommened, but consumers should expect that the sorting string has this form. One consequence is that the sorting string, while the best available choice for sorting where provided, may not be suitable for labeling the data in a sorted list. Should a second label type ('sortreport'?) be defined for this purpose? -- Examples: Agent 'Duarte, Amália Mourinha' (pt), 'Pina de Morales, Ana Maria' (es).; Taxon 'Isoetes' for if preferred form uses 'Isoëtes' (as allowable under ICBN); MediaObject 'high plano, the' for image titled 'The "high" plano'. -- Other applicable standards: vCard:Sort-String</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DetailRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Controlled vocabulary expressing the kind of long 'detail' text. In contrast to label text, detail text to which these values are applied are not restricted in length. Note that the text length of detail text elements is not limited by the schema. It is, however, recommended that the length does not exceed 30000 characters because longer text may lead to interoperability problems. Currently the enumerated values are highly constrained, but either extension or free extensibility (by union of this enum type with xs:anyURI) is expected for future releases of UBIF. Note that a 'description' is usually presented instead of the object, and a 'caption' always together with the object. An 'abstract' may be presented instead or together with the object.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Description">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[descript.] -- Description -- Free-form text describing an object. It may summarize the information contained in the object (similar to an abstract) but may also inform about related information. -- Other standards: ~= DC.Description.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Caption">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[caption] -- Caption -- A special form of free-form description that is expected to be displayed together with the object (especially images, video, or audio formats). Caption as defined here is limited to a caption displayed together with the entire object (i. e. excluding timed captions/subtitles of audio/video objects). Frequently description and caption texts are identical, in which case providing the description is sufficient. Specific captions may contain, e. g., references to places or objects in the image such as 'in upper left corner ...', 'bar = 10µm'.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Abstract">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[abstr.] -- Abstract -- A special form of free-form description that is contains a condensed version of the object content itself. Detail text with role 'abstract' is commonly used in the case of publications. The main difference to a 'description' is that an abstract does not contain external or metainformation about the object. Its applicability is therefore more limited, but also the correspondence of the representation with the full object may be assumed to be larger.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Coverage">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[cover.] -- Coverage -- Free-form text describing geographic, taxonomic, or other coverage aspects of the object or data set. -- Other standards: ~= DC.Coverage.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NormativeText">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[norm.] -- Normative definition -- Free-form text defining the concept of the object (applicable only to conceptual objects, not actual objects like specimens or books). Similar to description, but considered normative or translated-normative. Desirable external validation: only a single normative text should be without a "translatedfrom" attribute, all other should specify a translation source (and are "translated-normative", not "fully normative").</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UnknownDetailRole">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[?] -- Unknown -- The role ('Description', 'Caption', 'Abstract') of long detail text is unknown.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="InternalNotes">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[notes] -- Internal notes -- A secondary annotation, remark, explanation, etc. that will often be visible to authors/editors only. This should not be used for confidential text, as is may be publicly visible, depending on the application.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="MediaRepresentationRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Controlled vocabulary expressing the object representation role a media object (image, audio/video, rich text) may have. </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Iconic">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[iconic] -- icon/thumbnail (presented inline, if possible) -- Small image or short audio/video resource to supplement, but usually not replace label text. Most media resources of this role will not be informative enough to represent an object without additional textual representation. Recommendation: Typically only a single icon image should be defined for each object; applications may not be able to display more than one. However, combinations of still image and audio resource should be expected by applications supporting audio resources.</xs:documentation>
          <xs:documentation xml:lang="x-internal">Alternative keywords considered for this concept are: "avatar" - exact, but little known, "icon" (perhaps too much limited to images), "iconic" (may be misleading, since it is also is used in the sense of "typical, capturing the essence"), "symbol" (= "resembling or analogous to the thing it represents"), "thumbnail" (= "concise and brief:a thumbnail sketch"; probably too much limited to images), "thumb" (colloquial abbreviation of thumbnail in the context of computer programming).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Primary">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[primary] -- primary representation (presented inline, if possible) -- Media object intended as a first class representation of the object, fully informative without additional textual representation. If multiple media resources of this role are defined for an object, all of these are expected to be available when making the selection decision.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Diagnostic">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[diagn.] -- representation optimized for selecting one out of several alternatives (presented inline, if possible) -- A subclass of primary media object representations, optimized for being displayed in situations where a human user is expected to choose (select) among multiple instances. Typically the size, duration, or complexity of these resources will be less than in a primary resource. Examples: in a multi-access picture key, the human selects one or several states describing characteristics of a specimen to be identified, or selected one of several images representing the remaining taxa. </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Secondary">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[2ndary] -- additional, secondary, or supplementary representations (available on request) -- Media objects intended to inform the user rather on request. For example, a user interface might provide a single link/button to request additional information, or a short list of links allowing direct access to individual media objects. Examples are images of a character state in a specific taxon, which illustrates the concept, but does not expresses its circumscription.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Normative">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[normat.] -- normative resource for a concept definition -- Detailed information used to define a resource object. Examples are images or rich formatted text (glossary entry, a wiki page, or a taxon/species page). Note: abstract concepts (taxon, character, publication) or physical objects (such as specimens) itself may be identified by URI in Link rel="BasedOn". Reflexive usage: recording that The URI may be identical to a definition resource identified through this resource role (but is not required to be).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UnknownMediaRole">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[?] -- unknown -- The role of the media object is unknown (explictly equivalent to not specifying a value for the role).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="LinkingRelEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Controlled vocabulary expressing the semantics of a Link uri. The vocabulary includes all values from IRPStatementRoleEnum. These are currently highly constrained, but future version may add either more values or free extensibility (union of this type with xs:anyURI).</xs:documentation>
      <xs:appinfo>
        <xs:documentation xml:lang="x-internal">Currently not included:  
value="InstanceOf" ????
value="DetailedIn" [detailed in] -- detailed in -- Link designating more detailed alternate representations for the current object.
value="DefinedIn"  [def. in] -- defined in -- A subclass of "BasedOn", but making a stronger statement about intentional concept equivalence.
REASON: similar mechanism available in Representation/MediaObject role="normative" (but that is representation OF object, not referral to other resource). However, the position of DefinedIn between BasedOn and SameAs is very difficult to determine -&gt; considered not practical.
value="PropertyOf" [prop. of] -- property of -- The linked resource concept describes a property of the current concept. Example: Length is property of Leaf. -- This may be useful in the case of descriptive concepts, but this is so far unclear and for other object types it may be rather confusing.

USAGE EXAMPLE:
State id="234" uri="urn:lsid:LOL/State/88"
   Representation.../Representation
   Link rel="License" uri="urn:444"/
   Link rel="BasedOn" uri="urn:123"/
   Link rel="IsDifferentFrom" uri="urn:123"/
/State

Note that the URI attribute of first-class objects itself is related; in an earlier version of UBIF it was included as a Link with rel=Current, defined as "Link informing about a globally unique identifier of the current resource itself (i.e. the first-class object in which this link element occurs). An object may have multiple identifiers (for example http: or urn:lsid), but compare "SameAs". If retrievable, this should result in the same object representation (e. g., language, format, version); compare 'alternate'. [No equivalent in xhtml; corresponds to rdf:about.] - INTERNAL NOTE: names considered: identity, self, this, me, mine, myguid, objectguid, guid. Atom uses a similar link-structure with 'self' = A feed should contain a link back to the feed itself : &lt;atom:link rel="self" href="feed" /&gt;.

Note: Atom defines the following rel values:
  alternate: an alternate representation of the entry or feed, for example a permalink to the html version of the entry, or the front page of the weblog. 
  enclosure: a related resource which is potentially large in size and might require special handling, for example an audio or video recording. 
  related: an document related to the entry or feed. 
  self: the feed itself. 
  via: the source of the information provided in the entry.</xs:documentation>
      </xs:appinfo>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="LatestVersion">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[latest] -- latest version -- Link resolving to a representation of the latest (i.e. newest) version of the object at the time of resolution. This explicitly assumes that the result of resolution changes over time (non-persistent resource).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PriorVersion">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[prev.] -- prev. version -- Link resolving to the previous version of the current object. [Not related to xhtml prev]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Alternate">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[alt.] -- alternate -- Link designating an alternate (substitute) representation for the object in which this link occurs. These representations may differ in language, format, level of detail, etc. All alternate representations are implicitly about the same abstract resource, and it is recommended to express the abstract resource using rel="about". [Closely related to xhtml 1.0 "alternate" recommended link type value.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SubclassOf">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Subclass] -- Subclass Of -- Generalization relationship pointing to the more general concept (i.e. this concept is a kind-of linked concept).
Example: 'teliospore' and 'conidium are both a kind of 'spore', a 'spore' is a kind of 'propagule'). In the context of phylogenetic analyses a distinction between "homologous" and "heterologous generalizations" may be necessary, this is considered out of the general scope here and may be implemented in external ontologies.</xs:documentation>
          <xs:documentation xml:lang="x-internal">INTERNAL NOTE: synonymous names considered: KindOf.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SuperclassOf">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Superclass] -- Superclass Of -- Inverse of subclass of; generalization relationship pointing to the less general class.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BasedOn">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[BasedOn] -- based on -- The current resource is based on information from another resource, in a way that is different from verbatim copying and different from the extension semantics associated with sub/superclass relations. Specifically, this includes concepts like "source", "origin", or "derivation". "BasedOn" is transitive, not symmetric, not reflexive. Persistence of the other resource is assumed. The current resource may have a similar or entirely different format than the one it is based on. Examples: 1) A record based on a physical specimen (which has a urn). 2) A reference record based on a publication that has a DOI identifier. 3) A character definition based on a standard character definition.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SameAs">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[SameAs] -- same as -- Two resources have same semantics, same creator, same presentation format, but are not necessarily bitwise identical (e. g., sequence of elements in a set changed). SameAs is transitive, symmetric, reflexive. Persistence of the other resource is assumed. Note that multiple URIs of the current object may be given in "current", but this designates these as equal alternatives. Citing only one URI in "current" and others in "SameAs" may inform about older, outdated URIs.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SimilarTo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[SimilarTo] -- similar to -- Both resources (indepently created or of unknown derivation) are analyzed to be similar. "SimilarTo" is symmetric, reflexive, not transitive (problem of chaining). Whether a data consumer desires to make inferences on the weak "SimilarTo" relation or not is its own decision. In the case of character-based identifications, the built-in error tolerance mechansisms of the identification method will often allow doing so. Persistence of the other resource is assumed. Examples: 1) A character state may be (more or less roughly) equivalent to another in another dataset, although neither definition is based on the other. 2) Multiple images may be taken from the same object.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="IsDifferentFrom">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Diff. from] -- Is 
different from -- Opposite assertion to "SimilarTo". This asserts that two resources may appear related, but are not. "IsDifferentFrom" is symmetric, not transitive, not reflexive. Persistence of the other resource is assumed.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PartOf">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Part of] -- Part of -- Indicating composition. Data may be part of other data (a), a physical object may be part of another physical object (b), or an abstract concept may be a part of another concept (c). Examples: plant = root/stem/leaf, leaf = base/stipules/petiole/lamina, etc.; medium preparation and inoculation methods are part of microbial growth rate measurement method.
PartOf is transitive, anti-symmetric, and reflexive (though is of theoretical use only). Detailed information on use case (a): A dataset may be a subset of a larger dataset; if a dataset is dynamically generated in response to a query it may either have a URI encoding the query or no URI at all (i. e. uri-attribute on object itself does not exist), but may want to publish the URI or its base-dataset; one purpose of this is that a publisher may want to inform indexers (crawlers) about a resolvable URI to the larger dataset, another to establish the status of archival data. - On use case b): A microscopic slide may be part of a specimen in a collection. On use case c): A method may be a part (step) of a composite method, an article part of a publication, a petal is a part of the plant flower).</xs:documentation>
          <xs:documentation xml:lang="x-internal">INTERNAL NOTE: synonymous names considered: PartOf, HasPart, ComponentOf and HasComponent, ComposedOf, CompositeOf, ParticleOf, Aggregation.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="HasPart">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[has part] -- has part -- Inverse of the part-of relation, indicating the parts that something consists of. A book may have resources for chapters that are independently retrievable, a specimen unit may have subunits, a descriptive term like "ovate to elliptic" has the parts "ovate" and "elliptic" (the kind of composition being not defined here!).</xs:documentation>
          <xs:documentation xml:lang="x-internal">INTERNAL NOTE: synonymous names considered: PartOf, Contains, HasPart, ComponentOf and HasComponent, ComposedOf, CompositeOf, ParticleOf.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BackwardCompatibleWith">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Backw. Compat.] -- Backward Compatible With -- The linked resource (usually a prior version) is backward compatible with the current resource. Examples: A new species has been added to a genus. The old enumerated taxon concept is backwards compatible with the new one. Related to: owl:backwardCompatibleWith.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="IncompatibleWith">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Incompat.] -- Incompatible With -- The linked resource (usually a prior version) is incompatible compatible with the current resource. Examples: A categorical character with 3 states (which partion a continous value space) now has 4 states. The addition of the forth state not only extends the value space (as in adding "ultra-violet", which might be BackwardCompatibleWith), but changes the borders of the other states (as in adding "orange" between "red" and "yellow". Related to: owl:incompatibleWith.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Meta">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[meta] -- meta -- Link referring to a resource offering meta data or help (more information about the current resource, including meta data like copyright or licensing, links to other sources information, etc.). Compare IRPStatements with role="Copyright", "License", "Acknowledgement", etc. to express more specific relations. [Related to xhtml 2.0 "meta", but also to xhtml 1.0-2.0 "help" recommended link type values.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="IRPStatementRoleEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Controlled vocabulary expressing the kind of IPR (= intellectual property right) statements.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Copyright">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Copyright] -- Copyright -- Copyright information for the current resource (or statement that content is in the public domain).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="License">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[License] -- Licensing conditions for the current resource. -- Data may be distributed under a license. Placing data under a public license (e. g., Creative Commons, GFDL, OpenDocument) while maintaining copyright is recommended. (= DC.Rights.Licence). Example when used with Link: rel="License" href="http://creativecommons.org/licenses/by/2.5/"</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="TermsOfUse">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Terms/use] -- Terms of use -- Defines conditions under which the data may be analyzed, distributed or changed. "Terms of use" includes concepts like "Usage conditions" and "Specific Restrictions".</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Disclaimer">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Disclaimer] -- Disclaimer -- Disclaimer statement, e. g., concerning responsibility for data quality or legal implications.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PrivacyPolicy">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Privacy] -- Privacy policy -- Information and assertion of policy how individual privacy rights are observed.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Acknowledgement">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Acknowl.] -- Acknowledgement -- An acknowledgement of support (e. g., grant money, help, review, permission to reuse published material, etc.)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="IPRDeclaration">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[Declaration] -- Declaration -- Other forms of IPR declaration not covered by other IPR links (e.g., database rights); also used in cases where an automatic converter can not decide whether a statements is copyright, licence, etc.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- e) codes expressing sexual status (SexStatusEnum is a union of the following types)</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="SexStatusEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">
        <html:p>Codes for sex value in humans (clinical status) or animals. The codes are largely based on those defined in DICOM (Digital Imaging and Communications in Medicine, http://medical.nema.org/, Coding Scheme Designator DCM Version 01, PS3.16 Annex B, CID 7455) and ASTM E1633 (= "Standard Specification for Coded Values Used in the Electronic Health Record. Document Number: ASTM E1633-02a. ASTM International, 10-Nov-2002, 76 pages"). Additional codes specific to biology have been added.</html:p>
        <html:p>An alternative standard is ISO 5218, which provides only four codes: "0 = Not known, 1 = Male, 2 = Female, 9 = Not specified".  The difference between 0 and 9 is: "(0) implies that the sex of the person is not provided in the personal details i.e. the data has not been supplied and sex cannot be ascertained from the data provided"; "(9) implies that the sex of the person cannot be determined for physical reasons, e. g. a new born baby". ISO 5218 contains fewer and less intuitive codes. For biological purposes many codes would have to be arbitrarily added. G. Hagedorn, 10. August 2004</html:p>
      </xs:documentation>
      <xs:documentation xml:lang="x-internal">Technical note: It would be preferable to define the values in separate types and define this type as xs:union memberTypes="BasicSexStatusEnum AdditionalSexStatusEnum". However, as explained in the annotation of AgentRoleEnum, Stylus Studio and Xerces have problems with type derivations involving union types. Therefore the current work-around was chosen.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Male">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[m] -- Male -- [= ASTM E1633: M, = ISO 5218: 1]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Female">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[f] -- Female -- [= ASTM E1633: F, = ISO 5218: 2]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UnknownSex">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[?] -- Unknown sex -- No information regarding the sex is available (= "not recorded" or "not examined"). [= ASTM E1633: U, = ISO 5218: 0]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Hermaphrodite">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[h] -- Hermaphrodite -- An organism having both male and female sexual organs at some time during adulthood. General term, not differentiating between simultaneous or sequential hermaphrodites. [= ASTM E1633: H]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SimultaneousHermaphrodite">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[sh] -- Simultaneous hermaphrodite -- An organism having both male and female sexual organs at the same time during adulthood. [Not in ASTM E1633; = B in OBIS 1.0 http://www.iobis.org/FAQschema1.shtml]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Male2Female">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[mc] -- Male changing to Female -- The organism starts as a male, and changes sex to a female later in life (sequential hermaphrodite: protandry). Examples: seabasses (fish); many plant species; humans that underwent surgical sex change. This terms does not identify a phase in which an individual may be. [= ASTM E1633: MC]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Female2Male">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[fc] -- Female changing to Male -- The organism starts as a female, and changes sex to a male later in life (sequential hermaphrodite: protogyny). Example: Wrass reef fishes; some plants; humans that underwent surgical sex change. This terms does not identify a phase in which an individual may be. [= ASTM E1633: FC]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="HermaphroditeMalePhase">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[hm] -- Hermaphrodite, male phase -- Sequential hermaphrodite in male phase. [Not in ASTM E1633]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="HermaphroditeFemalePhase">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[hf] -- Hermaphrodite, female phase -- Sequential hermaphrodite in female phase. [Not in ASTM E1633]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="HermaphroditeTransitional">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[ht] -- Hermaphrodite, transitional phase -- Sequential hermaphrodite currently between sexes. [Not in ASTM E1633, but compare OBIS 1.0 http://www.iobis.org/FAQschema1.shtml]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="IndeterminateSex">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[i] -- Indeterminate sex -- The organism has been studied, but the sex could not be determined (e.g. in larval forms). Compare "ambiguous" and "unknown" sex.  [perhaps = ISO 5218: 9; perhaps = DICOM: code 121103, 'Undetermined'; compare OBIS 1.0 http://www.iobis.org/FAQschema1.shtml]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="AmbiguousSex">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[a] -- Ambiguous sex -- The sex organs have been studied, but the result was ambiguous. Includes abnormal mixed sex situations like "gynandromorph" (e. g. an insect is male on one side, female on the other). Compare "indeterminate" and "unknown" sex.  [= ASTM E1633: A]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MixedSex">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[x] -- Mixed sex status -- Multiple objects of mixed sex status (situation occurring in collections).</xs:documentation>
          <xs:documentation xml:lang="x-Internal">(X - Mixed sex - Requested by Walter Berendsohn).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="BasicSexStatusEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Contains basic sex type codes, sufficient for recording human sexes in most administrative contexts (used, e. g., in the Agent type data interface)</xs:documentation>
    </xs:annotation>
    <xs:restriction base="SexStatusEnum">
      <xs:enumeration value="Male"/>
      <xs:enumeration value="Female"/>
      <xs:enumeration value="UnknownSex"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="AdditionalSexStatusEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Contains codes in addition to those defined in BasicSexStatusEnum that are necessary for animals and clinical sex descriptions of humans. Additional codes "S, I, HM, HF, HT" has been added to those defined in DICOM /ASTM E1633. On the other side, the DICOM /ASTM E1633 codes "MP = male pseudohermaphrodite" and "FP = female pseudohermaphrodite" are omitted here because they are limited to human sex and express a politically contentious perspective (see http://en.wikipedia.org/wiki/Pseudohermaphrodite). See the UBIF type SexStatusEnum for a union of the enumerated values in this type and those in BasicSexStatusEnum.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="SexStatusEnum">
      <xs:enumeration value="Hermaphrodite"/>
      <xs:enumeration value="SimultaneousHermaphrodite"/>
      <xs:enumeration value="Male2Female"/>
      <xs:enumeration value="Female2Male"/>
      <xs:enumeration value="HermaphroditeMalePhase"/>
      <xs:enumeration value="HermaphroditeFemalePhase"/>
      <xs:enumeration value="HermaphroditeTransitional"/>
      <xs:enumeration value="IndeterminateSex"/>
      <xs:enumeration value="AmbiguousSex"/>
      <xs:enumeration value="MixedSex"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- f) Enumerations specific to the biological domain</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="TaxonHierarchyTypeEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Defines the type of a taxon hierarchy (list of enumerated values to support application interoperability).</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="UnspecifiedTaxonomy">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Unspecified taxonomy -- Conventional taxonomic or nomenclatural arrangement (this could be a PhylogeneticTaxonomy, a NonphylogeneticTaxonomy, or a mixture). In the absences of more specific information about a taxon hierarchy, this may be considered the default value.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PhylogeneticTaxonomy">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Phylogenetic taxonomy -- Hierarchy resulting from a phylogenetic analysis, regardless of whether the taxonomic conclusions are already implemented or not. This asserts a higher quality of the hierarchy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NonphylogeneticTaxonomy">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Nonphylogenetic taxonomy -- A hierarchy explicitly proposing a non-phylogenetic arrangements (herbs, shrubs, small trees, large trees).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SubsetFilter">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">SubsetFilter -- A hierarchy of type "SubsetFilter" is intended only for the purpose of filtering taxa for arbitrary purposes. It will often be a flat list, or a list of filter names, each with a list of taxa. Applications should not offer it as a choice when the user selects a hierarchy for displaying or reporting purposes. Note that conversely, the filter selection dialog in applications should not be restricted to hierarchies of type SubsetFilter. Note, however, that any hierarchy may be used as a filter to define subsets.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="IdentificationCertaintyEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Identifications of an Specimen (object/unit) as belonging to a taxon concept may be uncertain. This is especially important in biology, where identification qualifiers like 'cf.' or 'aff.' are often used as part of the scientific name. The following enumerated list provides general categories not restricted to scientific organism names. Note: In biology additional expression is often expressed through the choice of placement of the certainty qualifier. For example, 'Echinonema ferruginea var. campestris' may be qualified as 'cf. Echinonema ferruginea var. campestris', 'Echinonema cf. ferruginea var. campestris', 'Echinonema ferruginea cf. var. campestris'. The first presumably means that the entire name is uncertain, but the infraspecific name may be appropriate, the second indicates that the genus is certain, the species uncertain, and the final that the species in certain and only the infraspecific rank is uncertain. To achieve this level of expressiveness, it is recommended that an additional data element 'IdentificationUncertainTaxonomicRank' of type TaxonomicRankEnum may be combined with an element of IdentificationCertaintyEnum. IdentificationUncertainTaxonomicRank should be optional and omitted to express that an identification is unknown, but the rank not known (e. g. in 'Echinonema ferruginea?'). In ABCD 1.44 a special rank with enumeration beforeName, beforeFirstEpithet, beforeSecondEpithet is used instead.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="IdentificationCertain">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The identification is certain</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="IdentificationUncertain">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The identification is uncertain -- In biology this is often expressed with the Latin 'cf.' (confer).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="IdentificationSimilarTo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The identification names a similar object class. -- In this case the identified object is considered very similar to those objects classified under the given name. Note that in contrast to 'Uncertain' this implies that the object most likely it does <em>not</em> belong to this class. In biology this is often expressed with the Latin 'aff.' or 'afin.' (affinis).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="IdentificationCertaintyUnknown">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">The certainty of identification is unknown.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="NomenclaturalTypeStatusOfSpecimensEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">
        <html:p>This list is a first version of a constrained vocabulary to express typifying relations between taxonomic names and specimens (objects/units preserved in collections). Beyond those type categories explicitly governed by nomenclatural codes (Zoology, Botany, Bacterioloy, Virology), the list also includes some additional type status terms. These categories may be helpful when interpreting the original circumscription (topotypes, ex-types), but do not have the same binding status as terms governed by the nomenclatural codes. The enumeration attempts to strike a balance between listing all possible terms, and remaining comprehensible. In general, including too many terms was considered less problematic than omitting terms. Applications may easily select a subset for presentation in their user interface.</html:p>
        <html:p>This list is intended as a first version and it is hoped that in the review process through TDWG it will achieve sufficient maturity to be truly useful. It is expected that over time revisions will have to be made. Please use the WIKI (http://wiki.tdwg.org/twiki/bin/view/UBIF/NomenclaturalTypeStatusOfSpecimensDiscussion) to discuss the current list and the lists of synonymous, doubtful, or excluded type terms provided therein.</html:p>
        <html:p>Some background information: A type provides the objective standard of reference to determine the application of a taxon name. The type status of a specimen is only meaningful in combination with the name that is being typified (a specimen may have been designated type for multiple names in different publications). The type status of an object may be designated in the original description of a scientific name (original designation), or - under rules layed out in the respective nomenclatural codes - at a later time (subsequent designation). -- For taxa above species rank the type is always a lower rank taxon (e. g., species for genus, genus for family). The type terms for this situation are not included in the enumeration. Ultimately, typication of all taxa goes back to physical type specimens, but this should not be recorded as such in data sets. The indirect type reference in higher taxa means that typification changes to the lower taxon automatically affect the higher taxon.</html:p>
        <html:p>The exact definitions of type status differ between nomenclatural codes (ICBN, ICZN, ICNP/ICNB, etc.). The term definitions are intended to be informative and generally applicable across the different codes. The should not be interpreted as authoritative; in nomenclatural work the exact definitions in the respective codes have to be consulted. A duplication of status codes (bot-holo, zoo-holo, bact-holo, etc.) is not considered desirable or necessary. Since the application of the type status terms is constrained by the relationship of the typified name with a specific code, the exact definition can always be unambiguously retrieved.</html:p>
        <html:p>The following publications have been consulted to determine the number of type terms that should be included and to prepare the semantic definitions:</html:p>
        <html:ul>
          <html:li>Nomenclatural Glossary for Zoology (January 18 2000; ftp://ftp.york.biosis.org/sysgloss.txt; verified 17. June 2004)</html:li>
          <html:li>ICBN St. Louis Code (http://www.bgbm.fu-berlin.de/iapt/nomenclature/code/SaintLouis/0013Ch2Sec2a009.htm; verified 17. June 2004)</html:li>
          <html:li>Draft BioCode 4th version (Greuter et al., 1997; http://www.rom.on.ca/biodiversity/biocode/biocode1997.html)</html:li>
          <html:li>Glossary of 'type' terminology (Ronald H. Petersen; http://fp.bio.utk.edu/mycology/Nomenclature/nom-type.htm)</html:li>
          <html:li>Dictionary of Ichthyology (Brian W. Coad and Don E. McAllister, 2004; http://www.briancoad.com/Dictionary/introduction.htm)</html:li>
          <html:li>A useful resource that was not available when writing this proposal might be: Hawksworth, D.L., W.G. Chaloner, O. Krauss, J. McNeill, M.A. Mayo, D.H. Nicolson, P.H.A. Sneath, R.P. Trehane and P.K. Tubbs. 1994. A draft Glossary of terms used in Bionomenclature. (IUBS Monogr. 9) International Union of Biological Sciences, Paris. 74 pp.</html:li>
        </html:ul>
        <html:p>"not a type" was added from the enumeration published in TaxonConceptSchema v 0.8 by J. Kennedy &amp; Robert Kukla in October 2004</html:p>
        <html:p>Dr. Miguel A. Alonso-Zarazaga and Dr. Walter Gams are thanked for review and help. - Gregor Hagedorn, 13.7.2004-17.11.2004</html:p>
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="allo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Allotype -- A paratype specimen designated from the type series by the original author that is the opposite sex of the holotype. The term is not regulated by the ICZN. [Zoo.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="allolecto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Allolectotype -- A paralectotype specimen that is the opposite sex of the lectotype. The term is not regulated by the ICZN. [Zoo.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="alloneo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Alloneotype -- A paraneotype specimen that is the opposite sex of the neotype. The term is not regulated by the ICZN. [Zoo.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="co">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Cotype -- A deprecated term no longer recognized in the ICZN; formerly used for either syntype or paratype [see ICZN Recommendation 73E]. [Zoo.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="epi">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Epitype -- An epitype is a specimen or illustration selected to serve as an interpretative type when any kind of holotype, lectotype, etc. is demonstrably ambiguous and cannot be critically identified for purposes of the precise application of the name of a taxon (see Art. ICBN 9.7, 9.18). An epitype supplements, rather than replaces existing types. [Bot./Bio.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ex">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ex-Type -- A strain or cultivation derived from some kind of type material. Ex-types are not regulated by the botanical or zoological code. [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="exepi">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ex-Epitype -- A strain or cultivation derived from epitype material. Ex-types are not regulated by the botanical or zoological code. [Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="exholo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ex-Holotype -- A strain or cultivation derived from holotype material. Ex-types are not regulated by the botanical or zoological code. [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="exiso">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ex-Isotype -- A strain or cultivation derived from isotype material. Ex-types are not regulated by the botanical or zoological code. [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="exlecto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ex-Lectotype -- A strain or cultivation derived from lectotype material. Ex-types are not regulated by the botanical or zoological code. [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="exneo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ex-Neotype -- A strain or cultivation derived from neotype material. Ex-types are not regulated by the botanical or zoological code. [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="expara">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ex-Paratype -- A strain or cultivation derived from paratype material. Ex-types are not regulated by the botanical or zoological code. [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="exsyn">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Ex-Syntype -- A strain or cultivation derived from neotype material. Ex-types are not regulated by the botanical or zoological code. [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="hapanto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Hapantotype -- One or more preparations of directly related individuals representing distinct stages in the life cycle, which together form the type in an extant species of protistan [ICZN Article 72.5.4]. A hapantotype, while a series of individuals, is a holotype that must not be restricted by lectotype selection. If a hapantotype is found to contain individuals of more than one species, however, components may be excluded until it contains individuals of only one species [ICZN Article 73.3.2]. [Zoo.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="holo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Holotype -- The one specimen or other element used or designated by the original author at the time of publication of the original description as the nomenclatural type of a species or infraspecific taxon. A holotype may be 'explicit' if it is clearly stated in the originating publication or 'implicit' if it is the single specimen proved to have been in the hands of the originating author when the description was published. [Zoo./Bot./Bio.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="icono">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Iconotype -- A drawing or photograph (also called 'phototype') of a type specimen. Note: the term "iconotype" is not used in the ICBN, but implicit in, e. g., ICBN Art. 7 and 38. [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="iso">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Isotype -- An isotype is any duplicate of the holotype (i. e. part of a single gathering made by a collector at one time, from which the holotype was derived); it is always a specimen (ICBN Art. 7). [Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="isolecto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Isolectotype -- A duplicate of a neotype, compare lectotype. [Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="isoneo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Isoneotype -- A duplicate of a neotype, compare neotype. [Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="isosyn">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Isosyntype -- A duplicate of a syntype, compare isotype = duplicate of holotype. [Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="lecto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Lectotype -- A specimen or other element designated subsequent to the publication of the original description from the original material (syntypes or paratypes) to serve as nomenclatural type. Lectotype designation can occur only where no holotype was designated at the time of publication or if it is missing (ICBN Art. 7, ICZN Art. 74). [Zoo./Bot.] -- Note: the BioCode defines lectotype as selection from holotype material in cases where the holotype material contains more than one taxon [Bio.].</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="neo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Neotype -- A specimen designated as nomenclatural type subsequent to the publication of the original description in cases where the original holotype, lectotype, all paratypes and syntypes are lost or destroyed, or suppressed by the (botanical or zoological) commission on nomenclature. In zoology also called "Standard specimen" or "Representative specimen". [Zoo./Bot./Bio.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="para">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Paratype -- All of the specimens in the type series of a species or infraspecific taxon other than the holotype (and, in botany, isotypes). Paratypes must have been at the disposition of the author at the time when the original description was created and must have been designated and indicated in the publication. Judgment must be exercised on paratype status, for only rarely are specimens explicitly cited as paratypes, but usually as "specimens examined," "other material seen", etc. [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="paralecto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Paralectotype -- All of the specimens in the syntype series of a species or infraspecific taxon other than the lectotype itself. Also called "lectoparatype". [Zoo.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="paraneo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Paraneotype -- All of the specimens in the syntype series of a species or infraspecific taxon other than the neotype itself. Also called "neoparatype". [Zoo.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="plasto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Plastotype -- A copy or cast of type material, esp. relevant for fossil types. Not regulated by the botanical or zoological code (?). [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="plastoholo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Plastoholotype -- A copy or cast of holotype material (compare Plastotype).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="plastoiso">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Plastoisotype -- A copy or cast of isotype material (compare Plastotype).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="plastolecto">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Plastolectotype -- A copy or cast of lectotype material (compare Plastotype).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="plastoneo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Plastoneotype -- A copy or cast of neotype material (compare Plastotype).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="plastopara">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Plastoparatype -- A copy or cast of paratype material (compare Plastotype).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="plastosyn">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Plastosyntype -- A copy or cast of syntype material (compare Plastotype).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="syn">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Syntypes -- The series of specimens used to describe a species or infraspecific taxon when neither a single holotype by the original author, nor a lectotype in a subsequent publication has been designated. The syntypes collectively constitute the name-bearing type. [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="topo">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Topotype -- One or more specimens collected at the same location as the type series (type locality), regardless of whether they are part of the type series. Topotypes are not regulated by the botanical or zoological code. Also called "locotype". [Zoo./Bot.]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="type">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Type -- a) A specimen designated or indicated any kind of type of a species or infraspecific taxon. If possible more specific type terms (holotype, syntype, etc.) should be applied. b) the type name of a name of higher rank for taxa above the species rank. [General]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sec">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Secondary type -- A referred, described, measured or figured specimen in the original publication (including a neo/lectotypification publication) that is not a primary type. [General]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="supp">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Supplementary type -- A referred, described, measured or figured specimen in a revision of a previously described taxon. This is not formally considered a type. Provided as an alternative to "not a type" to express knowledge about material elsewhere presumed to have a more formal type status. [General]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="no">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">not a type -- For specimens erroneously labelled as types an explicit negative statement may be desirable. [General]</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="NomenclaturalStatusEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Controlled vocabulary expressing nomenclatural status of a biological taxon name. ### This needs urgently revision! Enumeration of possible values for nomenclatural status. (Source: initial LinneanCore.)</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Rejected">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Rejected -- The name is rejected (invalid, not accepted)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Fails">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Fails -- The name fails the requirement test for an acceptable name (e.g. pre-starting-date names).</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Conserved">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Conserved -- The name is accepted by means of an explicit conservation proposal</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Sanctioned">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Sanctioned -- The name is sanctioned (a special form of automatic conservation used in ICBN for fungi)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Accepted">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Accepted -- The name is accepted.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="NomenclaturalCodesEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Enumeration of nomenclatural codes under which a name is considered valid. (Source: comparison of enumerations in ABCD 1.49 and first LinneanCore draft.) - Gregor Hagedorn</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="Viral"/>
      <xs:enumeration value="Bacteriological"/>
      <xs:enumeration value="Botanical">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">International Code of Botanical Nomenclature, ICBN</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Zoological">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">International Code of Zoological Nomenclature, ICZN</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CultivatedPlant">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">International Code of cultivated plants, ICNCP</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="Indeterminate">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Examples: ambiregnally named taxa can not be fixed to a code; to express the (pre-starting point) names on which the sanctioning mechanism of fungal names is based.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- TaxonomicRankEnum is the superset of the values in the types following it:</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="TaxonomicRankEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">
        <html:p>Enumerated codes to express the rank of a taxon (scientific organism name) in a taxonomic hierarchy. The list is intended to be interoperable between name providers for bacteria, viruses, fungi, plants, and animals. It is not assumed that in each taxonomic group all ranks have to be used. Individual applications may select appropriate subsets (which may be based on information given inside the enumerated values, see Specifications/BioCode-, Botany-, Zoology-, and BacteriaStatus). The enumeration attempts to strike a balance between listing all possible rank terms, and remaining comprehensible. For example, the "infra-" ranks specifically mentioned in BioCode have been included (although very rarely used), but the additional intermediate zoological ranks (micro, nano, pico, etc.) are not included. Whether the selection of infraspecific ranks (some informal ranks, esp. from bacteriology, may be missing!) probably needs some discussion. However, it is believed that this list may help to start developing data sets that can easily be integrated across the barriers of language and taxonomic traditions.</html:p>
        <html:p>Not included in the list are the botanical "notho-" ranks, which are used to designate hybrids (nothospecies, nothogenus). It is assumed they can be generated from separate information that the taxon is a hybrid. ICBN §4.4 states: "The subordinate ranks of nothotaxa are the same as the subordinate ranks of non-hybrid taxa, except that nothogenus is the highest rank permitted".</html:p>
        <html:p>The following publications have been consulted to determine the number of type terms that should be included and to prepare the semantic definitions:</html:p>
        <html:ul>
          <html:li>The Berlin Taxonomic Information Model, MoReTax view (Berendsohn &amp; al., http://www.bgbm.org/scripts/ASP/BGBMModel/Catalogues.asp?Cat=MT</html:li>
          <html:li>DiversityTaxonomy model version 0.7 (G. Hagedorn &amp; T. Gräfenhan 2002, http://www.diversitycampus.net/Workbench/Taxonomy/Model/InformationModels.html)</html:li>
          <html:li>ABCD version 1.44, types HigherTaxonRankType and RankAbbreviationType, by W. Berendsohn, reviewed by D. Hobern</html:li>
          <html:li>TaxCat2 - Database of Botanical Taxonomic Categories by Jörg Ochsmann, IPK Gatersleben; http://mansfeld.ipk-gatersleben.de/TaxCat2/default.htm</html:li>
        </html:ul>
        <html:p>Many thanks for review and help go to Dr. Walter Gams. - Gregor Hagedorn, 13.7.2004-17.11.2004.</html:p>
        <html:p>Note: the list of all ranks is implemented as a union of all following rank subsets. Note that although BioCode has been used to define the partition into subsets, the ranks are not limited to BioCode but should be an interoperable superset of ranks used in Virology, Bacteriology, Botany and Zoology.</html:p>
        <html:p>Technical note: It would be preferable to define the values in separate types and define this type as xs:union memberTypes="TaxonomicRankBelowSubspeciesEnum TaxonomicRankSpeciesGroupEnum TaxonomicRankGenusSubdivisionEnum TaxonomicRankGenusGroupEnum TaxonomicRankFamilySubdivisionEnum TaxonomicRankFamilyGroupEnum TaxonomicRankAboveSuperfamilyEnum". However, as explained in the annotation of AgentRoleEnum, Stylus Studio and Xerces have problems with type derivations involving union types. Therefore the current work-around was chosen.</html:p>
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:QName">
      <xs:enumeration value="any_rank">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[unknown] -- tax. of unknown or undefined rank -- Use this if no information exists or can be deduced. If at least the rank group is known other values ("any_infrasp", "any_infragen", "any_supragen") should be preferred.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>(any)</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="any_infrasp">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[tax. infrasp.] -- infraspecific tax. of undefined rank -- Undefined ranks (using either no rank identifier in botany, or using greek letters or symbols like stars, crosses) occur in very old publications. Most frequently these are to be interpreted as varieties, but occasionally they are forms or subspecies (see Stearn, W.T. 1957: Species plantarum (Facsimile); Introduction. 1. London, p. 90-95, 160-161, 163). The interpretation of these cases requires taxonomic knowledge that may not be available at the time when data are parsed. Such lack of knowledge can be expressed using this rank identifier.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>tax. infrasp.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cand">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[cand.] -- candidate -- 'Candidatus' rank is proposed in bacteriology for putative taxa, which could not yet be studied sufficiently to warrant the creation of a name with a known rank. (Murray, R.G.E. &amp; Schleifer, K.H.: Taxonomic notes: a proposal for recording the properties of putative taxa of procaryotes. Int. J. Syst. Bacteriol., 1994, 44, 174-176).</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>cand.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>Proposed</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="fsp">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[f. sp.] -- special form -- The ICBN does not formally cover formae specialis (art. 4, note 3). However, because of the economic importance of pathogenic f. sp., and since it is common practice to handle them as if the code would apply (i. e. priority usually observed, name quoted with author), they are included here.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>f. sp.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>forma sp.; fsp.; fm. sp.; f. spec.; fm. spec.; forma spec.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>used, but all ranks below subsp. are not covered by ICNP/ICNB, see Rules 5d and 14a. ##Check whether this rank is used indeed.</ues:BacteriaStatus>
              <ues:BotanyStatus>none</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subsubfm">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subsubfm.] -- subsubform</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subsubfm.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>subsubf.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional(?)</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subfm">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subfm.] -- subform</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subfm.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>subf.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="fm">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[fm.] -- form -- Form, race, variety are not subject to regulation in zoology; see ICZN Article 1.3.4</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>fm.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>f.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>secondary</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>secondary</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subsubvar">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subsubvar.] -- sub-sub-variety</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subsubvar.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>subsubv.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subvar">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subvar.] -- sub-variety</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subvar.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>subv.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="var">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[var.] -- variety -- Form, race, variety are not subject to regulation in zoology; see ICZN Article 1.3.4 Examples: Pinus nigra var. caramanica (= "P. nigra subsp. nigra var. caramanica"; Taxus baccata var. variegata</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>var.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>v.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>secondary</ues:BioCodeStatus>
              <ues:BacteriaStatus>used, but all ranks below subsp. are not covered by ICNP/ICNB, see Rules 5d and 14a. ##Check whether this rank is used indeed.</ues:BacteriaStatus>
              <ues:BotanyStatus>secondary</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="pv">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[pathovar.] -- patho-variety</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>pathovar.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>pv.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>used, but all ranks below subsp. are not covered by ICNP/ICNB, see Rules 5d and 14a. ##Check whether this rank is used indeed.</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="bv">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[biovar.] -- bio-variety</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>biovar.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>bv.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>used, but all ranks below subsp. are not covered by ICNP/ICNB, see Rules 5d and 14a. ##Check whether this rank is used indeed.</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cv">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[cult.] -- cultivar -- The epithet is usually output in single quotes and may contain multiple words, see ICBN §28. Examples: Taxus baccata 'Variegata', Juniperus ×pfitzeriana 'Wilhelm Pfitzer'; Magnolia 'Elizabeth' (= a hybrid, no species epithet).</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>cult.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>Reference to 'Internat. code of nomenclature for cultivated plants'</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="convar">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[convar.] -- convar -- Used in cultivated plants (ICNCP), but deprecated, see 'Some notes on problems of taxonomy and nomenclature of cultivated plants' by J. Ochsmann, http://www.genres.de/IGRREIHE/IGRREIHE/DDD/22-08.pdf</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>convar.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>cv.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cvgroup">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[cultivar. group] -- cultivar-group</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>cultivar. group</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="graftchimaera">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[graft-chimaera] -- graft-chimaera</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>graft-chimaera</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="infrasp">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[infrasp.] -- infraspecies</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>infrasp.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>infrasp.; infraspec.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subsp_aggr">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[aggr.] -- subspecific aggregate (= group, complex) -- A loosely defined group of subspecies. Zoology: "Aggregate - a group of  subspecies within a species. An aggregate may be denoted by a group name interpolated in parentheses."</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>aggr.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ssp">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[ssp.] -- subspecies -- Examples: Pinus nigra subsp. nigra Homo sapiens sapiens</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>ssp.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>subsp.; subspec.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>secondary</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>additional</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sp">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[sp.] -- species -- Examples: Taxus baccata,  Homo sapiens</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>sp.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>spec.</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>primary</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered</ues:BacteriaStatus>
              <ues:BotanyStatus>principal</ues:BotanyStatus>
              <ues:ZoologyStatus>principal</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="aggr">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[aggr.] -- species aggregate (= species group, species complex) -- A loosely defined group of species. Zoology: "Aggregate - a group of species, other than a subgenus, within a genus. An aggregate may be denoted by a group name interpolated in parentheses." -- The Berlin/MoreTax model notes: "[these] aren't taxonomic ranks but cirumscriptions because on the one hand they are necessary for the concatenation of the fullname and on the other hand they are necessary for distinguishing the aggregate or species group from the microspecies." Compare subspecific aggregate for a group of subspecies within a species!</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>aggr.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="any_infragen">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[tax. infragen.] -- infrageneric tax. of undefined rank -- A name that appear between a genus name and a species epitheton and is not clearly marked as series or section, or other may be assigned to this rank until the true rank can be assigned by a taxonomic expert.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>tax. infragen.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subser">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subser.] -- subseries</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subser.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>*</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ser">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[ser.] -- series</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>ser.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>*</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>secondary</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>secondary</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subsect">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subsect.] -- subsection</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subsect.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>*</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="sect">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[sect.] -- section</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>sect.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>*</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>secondary</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>secondary</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="infragen">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[infragen.] -- infragenus</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>infragen.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>*</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subgen">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subgen.] -- subgenus</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subgen.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>*</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>secondary</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>additional</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="gen">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[gen.] -- genus -- Examples: Magnolia Homo</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>gen.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>primary</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered</ues:BacteriaStatus>
              <ues:BotanyStatus>principal</ues:BotanyStatus>
              <ues:ZoologyStatus>principal</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="infratrib">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[infratrib.] -- infratribe</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>infratrib.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subtrib">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subtrib.] -- subtribe</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subtrib.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-inae</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-inae</ues:SuffixPlantae>
              <ues:SuffixAlgae>-inae</ues:SuffixAlgae>
              <ues:SuffixFungi>-inae</ues:SuffixFungi>
              <ues:SuffixAnimalia>-ina</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered (but probably not in current use)</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="trib">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[trib.] -- tribe</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>trib.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-eae</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-eae</ues:SuffixPlantae>
              <ues:SuffixAlgae>-eae</ues:SuffixAlgae>
              <ues:SuffixFungi>-eae</ues:SuffixFungi>
              <ues:SuffixAnimalia>-ini</ues:SuffixAnimalia>
              <ues:BioCodeStatus>secondary</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered (but probably not in current use)</ues:BacteriaStatus>
              <ues:BotanyStatus>secondary</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="supertrib">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[supertrib.] -- supertribe</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>supertrib.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="infrafam">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[infrafam.] -- infrafamily</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>infrafam.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subfam">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subfam.] -- subfamily -- Examples: Magnolioideae</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subfam.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-oideae</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-oideae</ues:SuffixPlantae>
              <ues:SuffixAlgae>-oideae</ues:SuffixAlgae>
              <ues:SuffixFungi>-oideae</ues:SuffixFungi>
              <ues:SuffixAnimalia>-inae</ues:SuffixAnimalia>
              <ues:BioCodeStatus>secondary</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>additional</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="fam">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[fam.] -- family -- Examples: Magnoliaceae Hominidae</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>fam.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-aceae</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-aceae</ues:SuffixPlantae>
              <ues:SuffixAlgae>-aceae</ues:SuffixAlgae>
              <ues:SuffixFungi>-aceae</ues:SuffixFungi>
              <ues:SuffixAnimalia>-idae</ues:SuffixAnimalia>
              <ues:BioCodeStatus>principal</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered</ues:BacteriaStatus>
              <ues:BotanyStatus>principal</ues:BotanyStatus>
              <ues:ZoologyStatus>principal</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="superfam">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[superfam.] -- superfamily -- Examples: Magnoliacea</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>superfam.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-acea</ues:SuffixPlantae>
              <ues:SuffixAlgae>-acea</ues:SuffixAlgae>
              <ues:SuffixFungi>-acea</ues:SuffixFungi>
              <ues:SuffixAnimalia>-oidea; -acea</ues:SuffixAnimalia>
              <ues:BioCodeStatus>secondary</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="infraord">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[infraord.] -- infraorder</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>infraord.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subord">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subord.] -- suborder -- Examples: Magnolineae Catarrhini</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subord.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-ineae</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-ineae</ues:SuffixPlantae>
              <ues:SuffixAlgae>-ineae</ues:SuffixAlgae>
              <ues:SuffixFungi>-ineae</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>additional</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ord">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[ord.] -- order  -- Examples: Magnoliales Primates</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>ord.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-ales</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-ales</ues:SuffixPlantae>
              <ues:SuffixAlgae>-ales</ues:SuffixAlgae>
              <ues:SuffixFungi>-ales</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>principal</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered</ues:BacteriaStatus>
              <ues:BotanyStatus>principal</ues:BotanyStatus>
              <ues:ZoologyStatus>principal</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="superord">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[superord.] -- superorder -- Examples: Magnolianae</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>superord.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-anae</ues:SuffixPlantae>
              <ues:SuffixAlgae>-anae</ues:SuffixAlgae>
              <ues:SuffixFungi>-anae</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>additional</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="infracl">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[infracl.] -- infraclass</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>infracl.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subcl">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subcl.] -- subclass  -- Examples: Magnoliidae Eutheria</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subcl.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-idae [proposed; Stackebrandt, E., Rainey, F.A. &amp; Ward-Rainey, N.L.: Proposal for a new hierarchic classification system, Actinobacteria classis nov. Int. J. Syst. Bacteriol., 1997, 47, 479-491.]</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-idae</ues:SuffixPlantae>
              <ues:SuffixAlgae>-phycidae</ues:SuffixAlgae>
              <ues:SuffixFungi>-mycetidae</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>additional</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cl">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[cl.] -- class  -- Examples: Magnoliopsida Mammalia</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>cl.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-ia [proposed; Stackebrandt, E., Rainey, F.A. &amp; Ward-Rainey, N.L.: Proposal for a new hierarchic classification system, Actinobacteria classis nov. Int. J. Syst. Bacteriol., 1997, 47, 479-491.]</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-opsida</ues:SuffixPlantae>
              <ues:SuffixAlgae>-phyceae</ues:SuffixAlgae>
              <ues:SuffixFungi>-mycetes</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>principal</ues:BioCodeStatus>
              <ues:BacteriaStatus>covered</ues:BacteriaStatus>
              <ues:BotanyStatus>principal</ues:BotanyStatus>
              <ues:ZoologyStatus>principal</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="supercl">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[supercl.] -- superclass</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>supercl.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="infraphyl_div">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[infraphyl./div.] -- infraphylum (= infradivision)</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>infraphyl./div.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subphyl_div">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subphyl./div.] -- subphylum (= subdivision) -- Examples: Magnoliophytina Vertebrata</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subphyl./div.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-phytina</ues:SuffixPlantae>
              <ues:SuffixAlgae>-phytina</ues:SuffixAlgae>
              <ues:SuffixFungi>-mycotina</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>additional</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="phyl_div">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[phyl./div.] -- phylum (= division) -- Examples: Magnoliophyta Chordata</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>phyl./div.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-phyta</ues:SuffixPlantae>
              <ues:SuffixAlgae>-phyta</ues:SuffixAlgae>
              <ues:SuffixFungi>-mycota</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>principal</ues:BioCodeStatus>
              <ues:BacteriaStatus>used, but all ranks above class are not covered by ICNP/ICNB</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>principal</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="superphyl_div">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[superphyl./div.] -- superphylum (= superdivision)</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>superphyl./div.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>additional</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="infrareg">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[infrareg.] -- infrakingdom</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>infrareg.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="subreg">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[subreg.] -- subkingdom</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>subreg.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>additional</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="reg">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[reg.] -- kingdom -- Examples: Plantae Animalia</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>reg.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>principal</ues:BioCodeStatus>
              <ues:BacteriaStatus>used, but all ranks above class are not covered by ICNP/ICNB</ues:BacteriaStatus>
              <ues:BotanyStatus>principal</ues:BotanyStatus>
              <ues:ZoologyStatus>principal</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="superreg">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[superreg.] -- super kingdom -- Examples: Eucaryota</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>superreg.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>additional</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>additional</ues:BotanyStatus>
              <ues:ZoologyStatus>additional</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="dom">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[dom.] -- domain (= empire) -- Examples: Archaea (= Archaeobacteria), Bacteria (= Eubacteria), Eukarya (= Eukaryota)</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>dom.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>secondary</ues:BioCodeStatus>
              <ues:BacteriaStatus>used, but all ranks above class are not covered by ICNP/ICNB</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="any_supragen">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">[tax. supragen.] -- suprageneric tax. of undefined rank -- This value indicates that the rank of a name is unknown. Compare "incertae sedis" which is commonly used as a replacement for a taxon to group all taxa whose position in the classification or phylogenetic tree is uncertain.</xs:documentation>
          <xs:appinfo>
            <ues:Specification>
              <ues:PreferredAbbreviation>tax. supragen.</ues:PreferredAbbreviation>
              <ues:AdditionalAbbreviations>-</ues:AdditionalAbbreviations>
              <ues:SuffixBacteriae>-</ues:SuffixBacteriae>
              <ues:SuffixPlantae>-</ues:SuffixPlantae>
              <ues:SuffixAlgae>-</ues:SuffixAlgae>
              <ues:SuffixFungi>-</ues:SuffixFungi>
              <ues:SuffixAnimalia>-</ues:SuffixAnimalia>
              <ues:BioCodeStatus>-</ues:BioCodeStatus>
              <ues:BacteriaStatus>-</ues:BacteriaStatus>
              <ues:BotanyStatus>-</ues:BotanyStatus>
              <ues:ZoologyStatus>-</ues:ZoologyStatus>
            </ues:Specification>
          </xs:appinfo>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TaxonomicRankBelowSubspeciesEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Subset of ranks; equivalent to BioCode "infra-subspecfic", i.e. below the species group</xs:documentation>
    </xs:annotation>
    <xs:restriction base="TaxonomicRankEnum">
      <xs:enumeration value="any_infrasp"/>
      <xs:enumeration value="cand"/>
      <xs:enumeration value="fsp"/>
      <xs:enumeration value="subsubfm"/>
      <xs:enumeration value="subfm"/>
      <xs:enumeration value="fm"/>
      <xs:enumeration value="subsubvar"/>
      <xs:enumeration value="subvar"/>
      <xs:enumeration value="var"/>
      <xs:enumeration value="pv"/>
      <xs:enumeration value="bv"/>
      <xs:enumeration value="cv"/>
      <xs:enumeration value="convar"/>
      <xs:enumeration value="cvgroup"/>
      <xs:enumeration value="graftchimaera"/>
      <xs:enumeration value="infrasp"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TaxonomicRankSpeciesGroupEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Subset of ranks; equivalent to BioCode "species group", i.e. only species and subspecies</xs:documentation>
    </xs:annotation>
    <xs:restriction base="TaxonomicRankEnum">
      <xs:enumeration value="subsp_aggr"/>
      <xs:enumeration value="ssp"/>
      <xs:enumeration value="sp"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TaxonomicRankGenusSubdivisionEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Subset of ranks; equivalent to BioCode ""subdivision of a genus" ", i.e. all ranks between genus and species group (i.e. not including subgenus and species)</xs:documentation>
    </xs:annotation>
    <xs:restriction base="TaxonomicRankEnum">
      <xs:enumeration value="aggr"/>
      <xs:enumeration value="any_infragen"/>
      <xs:enumeration value="subser"/>
      <xs:enumeration value="ser"/>
      <xs:enumeration value="subsect"/>
      <xs:enumeration value="sect"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TaxonomicRankGenusGroupEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Subset of ranks; equivalent to BioCode "genus group", i.e. infragenus to genus</xs:documentation>
    </xs:annotation>
    <xs:restriction base="TaxonomicRankEnum">
      <xs:enumeration value="infragen"/>
      <xs:enumeration value="subgen"/>
      <xs:enumeration value="gen"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TaxonomicRankFamilySubdivisionEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Subset of ranks; equivalent to BioCode "subdivision of a family", i.e. ranks between genus group and family group</xs:documentation>
    </xs:annotation>
    <xs:restriction base="TaxonomicRankEnum">
      <xs:enumeration value="infratrib"/>
      <xs:enumeration value="subtrib"/>
      <xs:enumeration value="trib"/>
      <xs:enumeration value="supertrib"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TaxonomicRankFamilyGroupEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Subset of ranks; equivalent to BioCode "family group", i.e. infrafamily to superfamily</xs:documentation>
    </xs:annotation>
    <xs:restriction base="TaxonomicRankEnum">
      <xs:enumeration value="infrafam"/>
      <xs:enumeration value="subfam"/>
      <xs:enumeration value="fam"/>
      <xs:enumeration value="superfam"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="TaxonomicRankAboveSuperfamilyEnum">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Subset of ranks; equivalent to BioCode "suprafamilial". This rank group includes all ranks higher than superfamily (class, phylum/division, kingdom, domain)</xs:documentation>
    </xs:annotation>
    <xs:restriction base="TaxonomicRankEnum">
      <xs:enumeration value="infraord"/>
      <xs:enumeration value="subord"/>
      <xs:enumeration value="ord"/>
      <xs:enumeration value="superord"/>
      <xs:enumeration value="infracl"/>
      <xs:enumeration value="subcl"/>
      <xs:enumeration value="cl"/>
      <xs:enumeration value="supercl"/>
      <xs:enumeration value="infraphyl_div"/>
      <xs:enumeration value="subphyl_div"/>
      <xs:enumeration value="phyl_div"/>
      <xs:enumeration value="superphyl_div"/>
      <xs:enumeration value="infrareg"/>
      <xs:enumeration value="subreg"/>
      <xs:enumeration value="reg"/>
      <xs:enumeration value="superreg"/>
      <xs:enumeration value="dom"/>
      <xs:enumeration value="any_supragen"/>
    </xs:restriction>
  </xs:simpleType>
 <xs:annotation>
    <xs:documentation xml:lang="en-us">Unified Biosciences Information Framework (UBIF) XML schema. This part provides a type library of fundamental simple and complex types. See the main UBIF.xsd file for complete information, copyright and licensing.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Copyright © 2006 TDWG (Taxonomic Databases Working Group, www.tdwg.org). See the file UBIF_(c).xsd for authorship and licensing information.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Note: if multiple namespaces shall be used, all of which make use of this library, it would be possible to remove both xmlns="http://rs.tdwg.org/UBIF/2006/" and targetNamespace="http://rs.tdwg.org/UBIF/2006/" from xs:schema. In this 'chameleon pattern' (http://www-106.ibm.com/developerworks/library/x-flexschema/ or http://www.xfront.com/ZeroOneOrManyNamespaces.html), the included type libraries acquire the target namespace of the including schema. However, when testing this pattern in 2003-2004, several validators had problems handling this; for the time being UBIF and related schemata like SDD use only a single namespace.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Imported or included schemata: ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">The following import of xml namespace allows use of xml:lang directly. That schema defines an attribute lang of type="xs:language". The enumerated language values of this type are extensible using "x-" plus identifier. For the case of language-neutral elements (scientific taxon names) the value 'x-neutral' is recommended. To express unknown or mixed language, the special values 'mul' (multiple/mixed) and 'und' (undetermined/unknown) already exist (see http://wiki.tdwg.org/twiki/bin/view/UBIF/ExtendLanguageWithNeutralAndUnknown). Note: the import uses a local schema version, to ensure validation at times when not connected to the internet. The original schemaLocation is "http://www.w3.org/2001/xml.xsd".</xs:documentation>
  </xs:annotation>
  <xs:import namespace="http://www.w3.org/XML/1998/namespace" schemaLocation="w3c-schemata/xml.xsd"/>
  <xs:include schemaLocation="UBIF_EnumLib.xsd"/>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Basic type library: ===</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Basic generic types:</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="LongString">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Normalized string required to contain at least 1 character, currently also limited length 64000 character to reduce implementation costs for some applications. Requiring a minimum length of 1 removes the "xml string anomaly", i. e. required element/attributes may have no content - which differs from behavior of number/date types.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:normalizedString">
      <xs:minLength value="1" fixed="true"/>
      <xs:maxLength value="64000"/>
      <xs:whiteSpace value="collapse"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ShortString">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Normalized string of limited length (currently 1..255 character). The main reason to declare a limited length string types is to reduce implementation cost on some systems. Most database management systems (dbms) limit string length, either per field or per sum of fields in a record. Although probably all dbms also support long strings, these usually have different properties (slower, occasionally not sortable or indexable). Thus designers of logical or physical database models needs information about expected string length for data they intend to import. This cost usually occurs only to consuming applications where it is not acceptable to simply ignore part of the information.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="LongString">
      <xs:maxLength value="255" fixed="true"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ZeroToOne">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Double precision numeric value in the range of [0..1], for probabilities, etc.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:double">
      <xs:minInclusive value="0"/>
      <xs:maxInclusive value="1"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="ColorRGB">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Colors defined as RGB (red-green-blue) values combined as hex-encoded into a string, like in html. Example: #EE88FF. Colors may also be expressed as HSV (hue-saturation-luminance), but this is convertible to RGB. RGB is preferred because it is used in HTML.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="ShortString">
      <xs:pattern value="#([0-9]|[a-f]|[A-F]){6}">
        <xs:annotation>
          <xs:documentation xml:lang="en-us">Html also allows a shortend version with only 3 hexadecimal values. A pattern supporting both would be: #(([0-9]|[a-f]|[A-F]){3}|([0-9]|[a-f]|[A-F]){6})</xs:documentation>
        </xs:annotation>
      </xs:pattern>
    </xs:restriction>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Derived string types with restricting patterns:</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="NumericFormatPattern">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">String containing a format pattern of the type used in the xslt format-number function</xs:documentation>
    </xs:annotation>
    <xs:restriction base="ShortString">
      <xs:pattern value="([#,])*([0,])*([.](0)*(#)*)?(%)?"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- The resource media type carries currently only semantics, no syntax or regular expression pattern:</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="ResourceMediaType">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Resource media type (MIME, "text/html", "image/png", etc.). Compare www.w3.org/TR/xml-media-type.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="ShortString"/>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== The following Range, Date, and Coordinate types describe frequently recurring simple type combinations in a element with attributes</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Elements defining value ranges:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="ValueRangeOrVerbatim">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A value range as upper/lower value, optional, plus additional/alternative verbatim text.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="lower" type="xs:double" use="optional"/>
    <xs:attribute name="upper" type="xs:double" use="optional"/>
    <xs:attribute name="verbatim" type="ShortString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">An uninterpreted textual representation of the range as close as possible to the original (digital/printed/handwritten) information source.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ValueRange">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Restricted to required upper/ower value (no verbatim)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="ValueRangeOrVerbatim">
        <xs:attribute name="lower" type="xs:double" use="required"/>
        <xs:attribute name="upper" type="xs:double" use="required"/>
        <xs:attribute name="verbatim" type="ShortString" use="prohibited"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZeroToOneRange">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Required lower and upper attributes in the range 0-1. Used, e. g., for probabilities or values commonly expressed as percent</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="ValueRangeOrVerbatim">
        <xs:attribute name="verbatim" type="u:ShortString" use="prohibited"/>
        <xs:attribute name="lower" type="ZeroToOne" use="required"/>
        <xs:attribute name="upper" type="ZeroToOne" use="required"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="ZeroToOneEstimateRange">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Optional lower/upper estimate attributes in the range 0-1, with default values. Used, e. g., for certainty and frequency; the default values 0 and 1, resp., indicate that no estimate was possible.</xs:documentation>
    </xs:annotation>
    <xs:attribute name="lowerestimate" type="ZeroToOne" use="optional" default="0"/>
    <xs:attribute name="upperestimate" type="ZeroToOne" use="optional" default="1"/>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Types for composite gregorian calendar date/time (points in time where parts may be missing; following the seven property model described, e. g., in xml Schema 1.1 (http://www.w3.org/TR/2004/WD-xmlschema11-2-20040716/#theSevenPropertyModel). Instead of gYear, gMonth, gDay integer types with constraining facets are used for two reasons: a) each of them may have a timezone, which may lead to inconsistent data with multiple timezones; b) the lexical representation seems to be occasionally poorly implemented (e.g. where '31', or '---5' are accepted, whereas valid examples are '---31', '---05', and '---05+02:00'). In addition to the seven property model additional text attributes for either unsharp additions or complete verbatim dates are added. Note that incomplete dates in most cases are calendar specific and incomplete non-gregorian dates can not be expressed. Furthermore, for complete dates it may be unclear whether a reformed or unreformed date has been used (e.g. in Russia in the 19th century).</xs:documentation>
  </xs:annotation>
  <xs:complexType name="CompositeDate">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Date separated into attributes so that any part of the date may be missing
[ATTR: year = four digit year;
month = two digit month of year;
day = two digit day of month;
verbatim = unparsed textual date representation;
supplement = text additional or modifying the exact dates, e. g., 'end of summer', 'first half or year', 'first decade of month', '1888-1892';
timezone = expressed as integer according to the xml schema seven parameter model]</xs:documentation>
    </xs:annotation>
    <xs:attribute name="year" type="xs:integer" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">The four digit year in the Gregorian calendar (in Western cultures usually without a suffix or with 'AD/Anno Domini', 'CE/Common Era'; negative years with 'BC/Before Christ', 'BCE/Before Common Era'). Whether a year 0 is used or not differs between a true Gregorian calendar and recent astronomic usage, xml schema is likely to change its position, see xml schema draft 1.1. Thus database designers should not use 0 as a missing value representation for year.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="month" use="optional">
      <xs:simpleType>
        <xs:restriction base="xs:integer">
          <xs:minInclusive value="1"/>
          <xs:maxInclusive value="12"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="day" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">two digit day</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:integer">
          <xs:minInclusive value="1"/>
          <xs:maxInclusive value="31"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
    <xs:attribute name="literal" type="ShortString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">A free-form textual representation of the date.  In contrast to 'verbatim' this claims no special status and may contain any amount of interpretation. This may either be equivalent to the numeric data components, or contain additional information like 'end of summer', 'first half or year', 'first decade (of month)', '1888-1892'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verbatim" type="ShortString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">An uninterpreted textual representation of the original date information (date range, 'summer', perhaps unreformed Russian dates, etc.); as close as possible to the  earliest available (digital/printed/ handwritten) information source.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timezone" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Timezone expressed in minutes. In the seven property model (http://www.w3.org/TR/2004/WD-xmlschema11-2-20040716/#theSevenPropertyModel) the timezone has a range of +/- 14 hours (14 * 60 = 840 minutes).</xs:documentation>
      </xs:annotation>
      <xs:simpleType>
        <xs:restriction base="xs:integer">
          <xs:minInclusive value="-840"/>
          <xs:maxInclusive value="840"/>
        </xs:restriction>
      </xs:simpleType>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="CompositeDateTime">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Date + Time separated into attributes so that any part of the date may be missing. Note: adding a single time attribute of type xs:time would be simpler, but a duplication of the timezone information would be possible.</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="CompositeDate">
        <xs:attribute name="hour" use="optional">
          <xs:simpleType>
            <xs:restriction base="xs:integer">
              <xs:minInclusive value="0"/>
              <xs:maxInclusive value="24">
                <xs:annotation>
                  <xs:documentation xml:lang="en-us">'24' may only occur if both minute and second are zero (http://www.w3.org/TR/2004/WD-xmlschema11-2-20040716/#theSevenPropertyModel).
</xs:documentation>
                </xs:annotation>
              </xs:maxInclusive>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="minute" use="optional">
          <xs:simpleType>
            <xs:restriction base="xs:integer">
              <xs:minInclusive value="0"/>
              <xs:maxInclusive value="59"/>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
        <xs:attribute name="second" use="optional">
          <xs:simpleType>
            <xs:restriction base="xs:double">
              <xs:minInclusive value="0"/>
              <xs:maxInclusive value="60">
                <xs:annotation>
                  <xs:documentation xml:lang="en-us">The normal range should be 0-59, but 60 may occur for UTC leap-seconds (http://www.w3.org/TR/2004/WD-xmlschema11-2-20040716/#theSevenPropertyModel). An additional validator may choose to validate this. The simplest validation would attempt to convert those Composite date instance that containing all seven elements to a xs:dateTime value.</xs:documentation>
                </xs:annotation>
              </xs:maxInclusive>
            </xs:restriction>
          </xs:simpleType>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Types for geographical coordinates:</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="DecimalLatitude">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Latitude of geographical coordinates in signed decimal degrees (i.e. 30° 30' S would be expressed as -30.5). The value range is -90 to 90°, South latitude being negative, North latitude being positive.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:double">
      <xs:minInclusive value="-90"/>
      <xs:maxInclusive value="90"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="DecimalLongitude">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Longitude of geographical coordinates in signed decimal degrees (i.e. 30° 30' W would be expressed as -30.5). The value range is -180 to 180°, West longitude being negative, East longitude being positive.</xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:double">
      <xs:minInclusive value="-180"/>
      <xs:maxInclusive value="180"/>
    </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="GeographicalCoordinates">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">ATTR: latitude, longitude (in decimal degrees), geodeticdatum (esp. if different from a Greenwich-based datum).</xs:documentation>
    </xs:annotation>
    <xs:attribute name="latitude" type="DecimalLatitude" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Latitude of geographical coordinates in signed decimal degrees (i.e. 30° 30' S would be expressed as -30.5). The value range is -90 to 90°, South of the equator being negative, North of equator being positive.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="longitude" type="DecimalLongitude" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Longitude of geographical coordinates in decimal degrees (i.e. 30° 30' would be expressed as 30.5). Longitude is expressed from -180 to 180°, West longitude being negative, East longitude being positive.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="literal" type="ShortString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">A free-form string, either in addition to or instead of code (a mapping to the controlled vocabulary may be unavailable or considered ambiguous). In contrast to 'verbatim' this claims no special status and may contain any amount of interpretation.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verbatim" type="ShortString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">An uninterpreted textual representation of the coordinate data (latitude/longitude, UTM, TRS, etc.), as close as possible to the earliest available (digital/printed/handwritten) information source.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="geodeticdatum" type="ShortString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Where knowledge of the geodetic datum is readily available it should be passed on. However, in most situations investigating all unknown geodetic data would not be cost-effective. Many geodetic datum systems result in differences only up to a 100 m, some up to several hundred meters. For many purposes in biodiversity sciences are acceptable. The 'World Geodetic System 1984 (WGS-84)' is the most commonly used geodetic datum. It is used, e. g., by the 'Global Positioning System (GPS)'. Other important systems are used (e. g., ITRF, ETRS89, NZGD2000, OSGB36, ED50, see also http://www.ncgia.ucsb.edu/education/curricula/giscc/units/u015/tables/table03.html or http://www.colorado.edu/geography/gcraft/notes/datum/edlist.html). The differences between WGS-84 and International Terrestrial Reference Frame (ITRF) are in the centimeter range worldwide, and ETRF 89 and NAD 83 are identical to WGS84 for Europe and North America, respectively. -- An exception to what has been said above are historical coordinates, which for many countries up to ca. 1900 (and even much later for France) may be based on a prime meridian other than Greenwich/Airy (e. g., the NTF datum uses Paris as its prime meridian, 2.33723° east of Greenwich).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Complex types closely related to enumerations (these may alternative be placed in UBIF_TypeLib)</xs:documentation>
  </xs:annotation>
  <xs:complexType name="AbstractStringOrCode" abstract="true">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Three attributes provide options to express a value constrained (enumerated/extensible) vocabulary, simple free-form text (perhaps interpreted), or verbatim (uninterpreted original version). At least one attribute should be present; this can not be validated by the schema (external validation is required for this and for all types derived from this).</xs:documentation>
    </xs:annotation>
    <xs:attribute name="code" type="xs:QName" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">A value from a controlled vocabulary (with or without extensibility) to support application interoperability. Instead of using xs:string, xs:anyURI might be more desirable, but this requires changing the base type of the enumerations.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="literal" type="u:ShortString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">A free-form string, either in addition to or instead of code (a mapping to the controlled vocabulary may be unavailable or considered ambiguous). In contrast to 'verbatim' this claims no special status and may contain any amount of interpretation.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="verbatim" type="u:ShortString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">An uninterpreted literal; in contrast to 'label' this claims to be as close as possible to the (digital/printed/ handwritten) information source.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other" processContents="lax"/>
  </xs:complexType>
  <xs:complexType name="Sex">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Expressing sex as code (enumerated vocabulary) or free-form literal or verbatim text. At least one attribute should be present; this can not be validated by the schema (external validation).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="AbstractStringOrCode">
        <xs:attribute name="code" type="SexStatusEnum" use="optional" default="UnknownSex"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="TaxonomicRank">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Expressing taxon rank as code (enumerated vocabulary), simple free-form text (perhaps interpreted), or verbatim (uninterpreted original version). At least one attribute should be present; this can not be validated by the schema (external validation).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="AbstractStringOrCode">
        <xs:attribute name="code" type="TaxonomicRankEnum" use="optional" default="any_rank"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="RevisionStatus">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Expressing actual revision level relative to intended revision level as code (enumerated vocabulary: RevisionStatusEnum), optionally plus literal text (free-form comment).</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="AbstractStringOrCode">
        <xs:attribute name="code" type="RevisionStatusEnum" use="required"/>
        <xs:attribute name="verbatim" type="u:ShortString" use="prohibited"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="DataStatus">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Expressing reasons why data are missing (not coded) as enumerated vocabulary (DataStatusEnum) only (i.e. literal/verbatim text equivalents currently not supported!)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="AbstractStringOrCode">
        <xs:attribute name="code" type="DataStatusEnum" use="required"/>
        <xs:attribute name="literal" type="u:ShortString" use="prohibited"/>
        <xs:attribute name="verbatim" type="u:ShortString" use="prohibited"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">-- Complex types referring to UnivarStatMeasureEnum (used, e. g., by SDD):</xs:documentation>
  </xs:annotation>
  <xs:complexType name="UnivarAnyStatMeasure">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A univariate statistical measure (with or without 1 parameter)</xs:documentation>
    </xs:annotation>
    <xs:attribute name="type" type="UnivarAnyStatMeasureEnum" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Refers to an enumerated value in the UBIF type, declaring which kind of statistical measure has been used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other" processContents="lax"/>
  </xs:complexType>
  <xs:complexType name="UnivarSimpleStatMeasure">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A univariate statistical measure (without parameter)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="UnivarAnyStatMeasure">
        <xs:attribute name="type" type="UnivarSimpleStatMeasureEnum" use="required"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="UnivarParamStatMeasure">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A univariate statistical measure (without parameter)</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:restriction base="UnivarAnyStatMeasure">
        <xs:attribute name="type" type="UnivarParamStatMeasureEnum" use="required"/>
      </xs:restriction>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="UnivarSimpleStatMeasureData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A univariate statistical measure (without parameter) plus a numeric value</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="UnivarSimpleStatMeasure">
        <xs:attribute name="value" type="xs:double" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Value of univariate statistical measure.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="significant" type="xs:positiveInteger" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Measurement precision expressed as number of significant figures in value. Examples: '1.300' has precision=4 '72000' may have a precision between 2 and 5 figures.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:complexType name="UnivarParamStatMeasureData">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">A univariate statistical measure (with 1 parameter) plus a numeric value</xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="UnivarParamStatMeasure">
        <xs:attribute name="par" type="xs:double" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">This is a parameter value that further defines the univariate statistical measure. Example: for a percentile (ref='PercLower'), '0.10' would define the 10%-percentile.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value" type="xs:double" use="required">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Value of univariate statistical measure.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="significant" type="xs:positiveInteger" use="optional">
          <xs:annotation>
            <xs:documentation xml:lang="en-us">Measurement precision expressed as number of significant figures in value. Examples: '1.300' has precision=4 '72000' may have a precision between 2 and 5 figures.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Other complex types</xs:documentation>
  </xs:annotation>
  <xs:complexType name="TelephoneNumber">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Telephone, fax, etc. number
ATTR: number = should be provided in the ITU Recommendation E.164 international format ("+CountryCode AreaCode Number") (vCard:Tel.Number)
ATTR: devicetype = voice, fax, mobile, pager, modem (identical with vCard:Tel.Voice etc.; if several flags apply to a single phone number list the phone number multiple times!)
ATTR: usagenote = free-form text for constraints on use e. g. "weekdays only" or "home number" (partly: vCard:Tel.Home/Work flags)
ATTR: preferred = preferred number, may occur multiple times for different device types (vCard:Tel.Pref)</xs:documentation>
    </xs:annotation>
    <xs:attribute name="number" type="ShortString" use="required">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Numbers should be provided in the ITU Recommendation E.164 international format ("+CountryCode AreaCode Number").</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="devicetype" type="TelephoneDeviceEnum" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Note that telephone device types are not necessarily exclusive (voice/fax, mobile/modem, etc.) and vCard 3.0 allows multiple for a single number. However, in UBIF this can be represented by adding a single number multiple times for each device type. This attribute should not have a default value voice, even though this is the most likely case. However, an exporting database may not have properly reported the type, or the type may be indicated only in the usage note.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="usagenote" type="ShortString" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Free-form text for constraints on use e. g. "weekdays only" or "home number"
(partly: vCard:Home/Work flags)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preferred" type="xs:boolean" use="optional" default="false">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Elements with preferred = true indicate recommendation by the data provider. The consumer may have reasons to make a different choice.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Base type and derived types for all document internal cross reference.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">These types are used by id/ref attributes. The use of a type derivation allows to redefine the value type throughout the schema. Currently we decide to use document-wide IDs, but initial designs called only for within-object class identifiers (similar to database primary keys). Even with document-wide IDs, the standard version of the schema uses NCName as base type. Software designers using xslt may whish to change this to xs:ID and xs:IDREF in a local version of their schema to simplify the use of xslt (e.g. id() and idref() functions). However, using IDREF in the primary schema version would prevent using the schema for object or fragment interchange (the xs:IDREF values would always require a corresponding xs:ID value in the same document).</xs:documentation>
  </xs:annotation>
  <xs:simpleType name="LocalInstanceID">
    <xs:restriction base="xs:NCName"/>
  </xs:simpleType>
  <xs:simpleType name="LocalInstanceRef">
    <xs:restriction base="xs:NCName"/>
  </xs:simpleType>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Language and audience attributes form the basis of text representations of labels and other types:</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Note: the use of attribute groups instead of globally defined and referred attributes is a work-around for namespace problems occurring with attribute definitions in included library schemata.</xs:documentation>
  </xs:annotation>
  <xs:attributeGroup name="language">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">The enumerated language values of this type are extensible using "x-" plus identifier. For the case of language-neutral elements (scientific taxon names) the value 'x-neutral' is recommended. To express unknown or mixed language, the special values 'mul' (multiple/mixed) and 'und' (undetermined/unknown) already exist (see http://wiki.tdwg.org/twiki/bin/view/UBIF/ExtendLanguageWithNeutralAndUnknown).</xs:documentation>
    </xs:annotation>
    <xs:attribute ref="xml:lang" use="required"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="optional_language">
    <xs:attribute ref="xml:lang" use="optional"/>
  </xs:attributeGroup>
  <xs:attributeGroup name="multilingual">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">(multilingual support attributes)</xs:documentation>
      <xs:documentation xml:lang="en-us">Required 'xml:lang' plus optional 'translatedfrom' and 'audience' attributes</xs:documentation>
    </xs:annotation>
    <xs:attribute ref="xml:lang" use="optional"/>
    <xs:attribute name="translatedfrom" type="xs:language" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">For translations, the source language may be indicated.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="audience" type="LocalInstanceRef" use="optional">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">Optional information on expertise (pupil, student, expert), profess. background (farmer), etc. Values are recommended to correspond to the id of Audience objects (not validated). See further comments for background information.</xs:documentation>
        <xs:documentation xml:lang="en-us">*Why introduce audience and not use a third-level language subtag?*
xml:lang already expresses language and culture or region in tag and subtag ('en-CA'), but the use of further subtags to express audiences is problematic. RFC3066 supports 'en-CA-farmers' but does not define rules for how to add a level 3 subtag on "en" itself, 'en--farmers' being invalid according to rfc3066 production rules. Further, subtag length is restricted to 8 characters.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute namespace="##other">
      <xs:annotation>
        <xs:documentation xml:lang="en-us">(provides extensibility through attributes from other namespaces)</xs:documentation>
      </xs:annotation>
    </xs:anyAttribute>
  </xs:attributeGroup>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">Audience is also available as an object type to define label and expertise level for audiences. However, audience values may be used even if no Audience object with a corresponding id can be found.)</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">The reason for this is that all object labels, representations may already use audience in addition to language. To avoid circular dependencies or introducing special cases for audience objects, it was considered acceptable not to validate the correspondence using schema identity constraints (= referential integrity) here.</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">(Note: If audience definitions are present, a missing attribute (and one explicitly containing the default set in this schema, e.g. "-") in multilingual or AudienceRef should be treated as pointing to the first audience with expertiselevel=0 (undefined).</xs:documentation>
  </xs:annotation>
  <xs:annotation>
    <xs:documentation xml:lang="en-us">=== Complex types that add language/audience or 'preferred' attributes to the simple types LongString, ShortString, anyURI:</xs:documentation>
  </xs:annotation>
  <xs:complexType name="LongStringL">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">Long string (i. e. xs:string with minimum length=1) extended with *optional* language attribute</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="LongString">
        <xs:attributeGroup ref="multilingual"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="ShortStringL">
    <xs:annotation>
      <xs:documentation xml:lang="en-us">ShortString (i. e. xs:string with limited length), extended with *optional* xml:lang attribute</xs:documentation>
    </xs:annotation>
    <xs:simpleContent>
      <xs:extension base="ShortString">
        <xs:attributeGroup ref="multilingual"/>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>
</xs:schema>
