<?php

/**
 * Implements hook_install().
 */
function character_editor_install(){
  // New module weights in core: put char editor as the very last in the chain.
  db_update('system')->fields(array(
    'weight' => 100
  ))->condition('type', 'module')->condition('name', 'character_editor')->execute();
}

/**
 * Implements hook_schema().
 */
function character_editor_schema(){
  $schema = array();
  // Projects schema defintion
  $schema['character_editor_project'] = array(
    'description' => 'The base table for character_project entities.',
    'fields' => array(
      'id' => array(
        'description' => 'Primary Key: Identifier for a character project.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE
      ),
      'type' => array(
        'description' => 'The {character_project_type}.type of this character project.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''
      ),
      'title' => array(
        'description' => 'The human-readable name of this character project type.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''
      ),
      'uid' => array(
        'description' => 'The {users}.uid that created this character project.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0
      ),
      'created' => array(
        'description' => 'The Unix timestamp when the character project was created.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0
      ),
      'changed' => array(
        'description' => 'The Unix timestamp when the character project was most recently saved.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0
      ),
      'status' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 1,
        'size' => 'tiny',
        'description' => 'The published status of a character project. (0 = Not Published, 1 = Published)'
      ),
      'data' => array(
        'type' => 'blob',
        'not null' => FALSE,
        'size' => 'big',
        'serialize' => TRUE,
        'description' => 'A serialized array of additional data.'
      )
    ),
    'foreign keys' => array(
      'character_project_type' => array(
        'table' => 'character_project_type',
        'columns' => array(
          'type' => 'type'
        )
      ),
      'character_project_author' => array(
        'table' => 'users',
        'columns' => array(
          'uid' => 'uid'
        )
      )
    ),
    'primary key' => array(
      'id'
    ),
    'indexes' => array(
      'type' => array(
        'type'
      )
    )
  );
  $schema['character_editor_project_type'] = array(
    'description' => 'Stores information about defined character project types.',
    'fields' => array(
      'id' => array(
        'type' => 'serial',
        'not null' => TRUE,
        'description' => 'Primary Key: Unique character project type identifier.'
      ),
      'type' => array(
        'description' => 'The machine-readable name of this character project type.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE
      ),
      'label' => array(
        'description' => 'The human-readable name of this character project type.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''
      ),
      'weight' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'tiny',
        'description' => 'The weight of this character project type in relation to others.'
      )
    ) + entity_exportable_schema_fields(),
    'primary key' => array(
      'id'
    ),
    'unique keys' => array(
      'type' => array(
        'type'
      )
    )
  );
  // Characters schema definiton
  $schema['character_editor_character'] = array(
    'description' => 'The base table for character entities.',
    'fields' => array(
      'id' => array(
        'description' => 'Primary Key: Identifier for a character .',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE
      ),
      'type' => array(
        'description' => 'The {character_editor_character_type}.type of this character.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''
      ),
      'title' => array(
        'description' => 'The human-readable name of this character.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''
      ),
      'uid' => array(
        'description' => 'The {users}.uid that created this character.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0
      ),
      'created' => array(
        'description' => 'The Unix timestamp when the character was created.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0
      ),
      'changed' => array(
        'description' => 'The Unix timestamp when the character was most recently saved.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0
      ),
      'data' => array(
        'type' => 'blob',
        'not null' => FALSE,
        'size' => 'big',
        'serialize' => TRUE,
        'description' => 'A serialized array of additional data.'
      ),
      'weight' => array(
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'size' => 'tiny',
        'description' => 'The weight of this character type in relation to others.'
      )
    ),
    'foreign keys' => array(
      'character_editor_character_type' => array(
        'table' => 'character_editor_character_type',
        'columns' => array(
          'type' => 'type'
        )
      ),
      'character_project_author' => array(
        'table' => 'users',
        'columns' => array(
          'uid' => 'uid'
        )
      )
    ),
    'primary key' => array(
      'id'
    ),
    'indexes' => array(
      'type' => array(
        'type'
      )
    )
  );
  $schema['character_editor_character_type'] = array(
    'description' => 'Stores information about defined character types.',
    'fields' => array(
      'id' => array(
        'type' => 'serial',
        'not null' => TRUE,
        'description' => 'Primary Key: Unique character type identifier.'
      ),
      'type' => array(
        'description' => 'The machine-readable name of this character type.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE
      ),
      'label' => array(
        'description' => 'The human-readable name of this character type.',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => ''
      )
    ) + entity_exportable_schema_fields(),
    'primary key' => array(
      'id'
    ),
    'unique keys' => array(
      'type' => array(
        'type'
      )
    )
  );
  return $schema;
}

/**
 * Set the image style for characters to thumbnail
 */
function character_editor_update_7001(){
  module_load_include('features.field.inc', 'character_editor');
  $info = character_editor_field_default_fields();
  $to_update = array(
    'character_editor_character' => array(
      'dna' => array(
        'field_char_image',
        'field_char_description'
      ),
      'group' => array(
        'field_char_image'
      ),
      'numeric' => array(
        'field_char_image'
      ),
      'text' => array(
        'field_char_image'
      )
    ),
    'field_collection_item' => array(
      'field_char_states' => array(
        'field_char_state_image'
      )
    )
  );
  foreach($to_update as $entity_type => $bundles){
    foreach($bundles as $bundle => $fields){
      foreach($fields as $field_name){
        $field_info = $info[$entity_type . '-' . $bundle . '-' . $field_name];
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        if($instance){
          $instance['display']['default'] = $field_info['field_instance']['display']['default'];
          $instance['widget'] = $field_info['field_instance']['widget'];
          field_update_instance($instance);
        }
      }
    }
  }
}

/**
 * Remove the relation select field_characters
 */
function character_editor_update_7002(){
  $remove = array(
    'character_editor_project' => array(
      'default_character_project'
    ),
    'character_editor_character' => array(
      'controlled',
      'dna',
      'numeric',
      'text',
      'group'
    )
  );
  foreach($remove as $type => $bundles){
    foreach($bundles as $bundle){
      $instance = field_info_instance($type, 'field_characters', $bundle);
      if($instance){
        field_delete_instance($instance);
      }
    }
  }
}

/**
 * Add a weight field to character relations
 */
function character_editor_update_7003(){
  module_load_include('features.field.inc', 'character_editor');
  $definitions = character_editor_field_default_fields();
  $info = field_info_field('field_character_weight');
  if(!$info){
    field_create_field($definitions['relation-character-field_character_weight']['field_config']);
  }
  $instance = field_info_instance('relation', 'field_character_weight', 'character');
  if(!$instance){
    field_create_instance($definitions['relation-character-field_character_weight']['field_instance']);
  }
}

/**
 * Add the specimen field to character projects
 */
function character_editor_update_7004(){
  module_load_include('features.field.inc', 'character_editor');
  $definitions = character_editor_field_default_fields();
  $info = field_info_field('field_char_proj_specimen');
  if(!$info){
    field_create_field($definitions['character_editor_project-default_character_project-field_char_proj_specimen']['field_config']);
  }
  $instance = field_info_instance('character_editor_project', 'field_char_proj_specimen', 'default_character_project');
  if(!$instance){
    field_create_instance($definitions['character_editor_project-default_character_project-field_char_proj_specimen']['field_instance']);
  }
}

/**
 * Add the flags field to character projects
 */
function character_editor_update_7005(){
  // Enable the field collection & field collection table modules
  if(!module_exists('field_collection')){
    module_enable(array(
      'field_collection'
    ));
  }
  if(!module_exists('field_collection_table')){
    module_enable(array(
      'field_collection_table'
    ));
  }
  // Create the field collection and it's fields
  module_load_include('features.field.inc', 'character_editor');
  $definitions = character_editor_field_default_fields();
  $create = array(
    'character_editor_project' => array(
      'default_character_project' => array(
        'field_char_proj_flags'
      )
    ),
    'field_collection_item' => array(
      'field_char_proj_flags' => array(
        'field_char_proj_flags_flag',
        'field_char_proj_flags_abbr',
        'field_char_proj_flags_id'
      )
    )
  );
  foreach($create as $entity_type => $bundles){
    foreach($bundles as $bundle => $fields){
      foreach($fields as $field_name){
        $info = field_info_field($field_name);
        if(!$info){
          field_create_field($definitions["$entity_type-$bundle-$field_name"]['field_config']);
        }
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        if(!$instance){
          field_create_instance($definitions["$entity_type-$bundle-$field_name"]['field_instance']);
        }
      }
    }
  }
}

/**
 * Update characters
 */
function character_editor_update_7006(){
  module_load_include('features.field.inc', 'character_editor');
  $definitions = character_editor_field_default_fields();
  $create = array(
    'character_editor_character' => array(
      'controlled' => array(
        'field_char_ordered' => false,
        'field_char_and_or' => 'AND'
      ),
      'numeric' => array(
        'field_char_integer' => false
      )
    )
  );
  // Create new fields
  foreach($create as $entity_type => $bundles){
    foreach($bundles as $bundle => $fields){
      foreach($fields as $field_name => $default){
        $info = field_info_field($field_name);
        if(!$info){
          field_create_field($definitions["$entity_type-$bundle-$field_name"]['field_config']);
        }
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        if(!$instance){
          field_create_instance($definitions["$entity_type-$bundle-$field_name"]['field_instance']);
        }
      }
    }
  }
  // Set default values on existing characters
  foreach($create as $entity_type => $bundles){
    foreach($bundles as $bundle => $fields){
      $efq = new EntityFieldQuery();
      $efq->entityCondition('entity_type', $entity_type);
      $efq->entityCondition('bundle', $bundle);
      $r = $efq->execute();
      if(isset($r[$entity_type])){
        foreach(array_keys($r[$entity_type]) as $entity_id){
          $w = entity_metadata_wrapper($entity_type, entity_load_single($entity_type, $entity_id));
          if(!$w){
            continue;
          }
          foreach($fields as $field_name => $default){
            $w->{$field_name} = $default;
          }
          $w->save();
        }
      }
    }
  }
}

/**
 * Set default flags for existing character projects
 */
function character_editor_update_7007(){
  $flag_defaults = array(
    'c' => 'computed',
    'i' => 'inherited',
    'a' => 'approximate',
    'g' => 'guessed',
    'r' => 'rare'
  );
  module_load_include('features.field.inc', 'character_editor');
  $definitions = character_editor_field_default_fields();
  $efq = new EntityFieldQuery();
  $efq->entityCondition('entity_type', 'character_editor_project');
  $r = $efq->execute();
  if(isset($r['character_editor_project'])){
    foreach(array_keys($r['character_editor_project']) as $entity_id){
      $project = entity_load_single('character_editor_project', $entity_id);
      if(empty($project->field_char_proj_flags)){
        foreach($flag_defaults as $flag_abbr => $flag){
          $f = entity_create('field_collection_item', array(
            'item_id' => NULL,
            'revision_id' => NULL,
            'field_name' => 'field_char_proj_flags',
            'default_revision' => TRUE,
            'archived' => FALSE,
            'field_char_proj_flags_abbr' => array(
              LANGUAGE_NONE => array(
                array(
                  'value' => $flag_abbr
                )
              )
            ),
            'field_char_proj_flags_flag' => array(
              LANGUAGE_NONE => array(
                array(
                  'value' => $flag
                )
              )
            ),
            'field_char_proj_flags_id' => array(
              LANGUAGE_NONE => array(
                array(
                  'value' => $flag
                )
              )
            )
          ));
          $f->setHostEntity('character_editor_project', $project);
          $f->save();
        }
      }
    }
  }
}

/**
 * Add fields to computed character
 * 
 */
function character_editor_update_7008(){
  module_load_include('features.field.inc', 'character_editor');
  $definitions = character_editor_field_default_fields();
  $create = array(
    'character_editor_character' => array(
      'computed' => array(
        'field_char_image' => false,
        'field_char_description' => false,
        'field_char_expr' => false
      )
    )
  );
  // Create new fields
  foreach($create as $entity_type => $bundles){
    foreach($bundles as $bundle => $fields){
      foreach($fields as $field_name => $default){
        $info = field_info_field($field_name);
        if(!$info){
          field_create_field($definitions["$entity_type-$bundle-$field_name"]['field_config']);
        }
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        if(!$instance){
          field_create_instance($definitions["$entity_type-$bundle-$field_name"]['field_instance']);
        }
      }
    }
  }
}

/**
 * Add conditional fields
 *
 */
function character_editor_update_7009(){
  module_load_include('features.field.inc', 'character_editor');
  $definitions = character_editor_field_default_fields();
  $new_fields = array(
    'character_editor_character' => array(
      'text' => array(
        'field_char_condition'
      ),
      'dna' => array(
        'field_char_condition'
      ),
      'numeric' => array(
        'field_char_condition'
      ),
      'controlled' => array(
        'field_char_condition'
      )
    )
  );
  // Create new fields
  foreach($new_fields as $entity_type => $bundles){
    foreach($bundles as $bundle => $fields){
      foreach($fields as $field_name){
        $info = field_info_field($field_name);
        if(!$info){
          field_create_field($definitions["$entity_type-$bundle-$field_name"]['field_config']);
        }
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        if(!$instance){
          field_create_instance($definitions["$entity_type-$bundle-$field_name"]['field_instance']);
        }
      }
    }
  }
}

/**
 * Create the inheritance flag field, and add a condition field to computed
 * characters.
 */
function character_editor_update_7010(){
  module_load_include('features.field.inc', 'character_editor');
  $definitions = character_editor_field_default_fields();
  $new_fields = array(
    'character_editor_character' => array(
      'computed' => array(
        'field_char_condition'
      )
    ),
    'relation' => array(
      'character_state' => array(
        'field_character_state_pass'
      )
    )
  );
  // Create new fields
  foreach($new_fields as $entity_type => $bundles){
    foreach($bundles as $bundle => $fields){
      foreach($fields as $field_name){
        $info = field_info_field($field_name);
        if(!$info){
          field_create_field($definitions["$entity_type-$bundle-$field_name"]['field_config']);
        }
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        if(!$instance){
          field_create_instance($definitions["$entity_type-$bundle-$field_name"]['field_instance']);
        }
      }
    }
  }
}

/**
 * Switch metadata from a serialized value to a number of fields
 */
function character_editor_update_7011(){
  // Create the new 'flag' field
  module_load_include('features.field.inc', 'character_editor');
  $definitions = character_editor_field_default_fields();
  $new_fields = array(
    'relation' => array(
      'character_state' => array(
        'field_character_state_flag'
      )
    )
  );
  // Create new fields
  foreach($new_fields as $entity_type => $bundles){
    foreach($bundles as $bundle => $fields){
      foreach($fields as $field_name){
        $info = field_info_field($field_name);
        if(!$info){
          field_create_field($definitions["$entity_type-$bundle-$field_name"]['field_config']);
        }
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        if(!$instance){
          field_create_instance($definitions["$entity_type-$bundle-$field_name"]['field_instance']);
        }
      }
    }
  }
  // If there is a meta field, copy existing data from meta to flag
  $info = field_info_field('field_character_state_meta');
  if(!$info){return;}
  $efq = new EntityFieldQuery();
  $efq->entityCondition('entity_type', 'relation');
  $efq->entityCondition('bundle', 'character_state');
  $efq->fieldCondition('field_character_state_meta', 'value', '', '!=');
  $result = $efq->execute();
  if(!empty($result['relation'])){
    $relations = array_keys($result['relation']);
    foreach($relations as $rid){
      $relation = relation_load($rid);
      $meta = unserialize($relation->field_character_state_meta[LANGUAGE_NONE][0]['value']);
      $relation->field_character_state_flag = array(
        LANGUAGE_NONE => array(
          0 => array(
            'value' => $meta['flag']
          )
        )
      );
      relation_save($relation);
    }
  }
  // Delete the meta field
  $meta_field = field_info_instance('relation', 'field_character_state_meta', 'character_state');
  if($meta_field){
    field_delete_instance($meta_field);
  }
}

/**
 * Rename 'flags' to 'annotations'
 */
function character_editor_update_7012(){
  module_load_include('features.field.inc', 'character_editor');
  $definitions = character_editor_field_default_fields();
  $update_fields = array(
    'character_editor_project' => array(
      'default_character_project' => array(
        'field_char_proj_flags'
      )
    ),
    'field_collection_item' => array(
      'field_char_proj_flags' => array(
        'field_char_proj_flags_flag'
      )
    ),
    'relation' => array(
      'character_state' => array(
        'field_character_state_flag'
      )
    )
  );
  // Update the fields
  foreach($update_fields as $entity_type => $bundles){
    foreach($bundles as $bundle => $fields){
      foreach($fields as $field_name){
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        if($instance){
          $instance['label'] = $definitions["$entity_type-$bundle-$field_name"]['field_instance']['label'];
          $instance['description'] = $definitions["$entity_type-$bundle-$field_name"]['field_instance']['description'];
          field_update_instance($instance);
        }
      }
    }
  }
}

/**
 * Delete any "s" conditions
 */
function character_editor_update_7013(){
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'character_editor_character')->fieldCondition('field_char_condition', 'value', 's', '=');
  $result = $query->execute();
  if(!empty($result)){
    db_delete('field_data_field_char_condition')->condition('entity_id', array_keys($result['character_editor_character']))->condition('field_char_condition_value', 's')->execute();
    db_delete('field_revision_field_char_condition')->condition('entity_id', array_keys($result['character_editor_character']))->condition('field_char_condition_value', 's')->execute();
  }
}

/**
 * Create the Alternative wording fields
 */
function character_editor_update_7014(){
  module_load_include('features.field.inc', 'character_editor');
  $fields = character_editor_field_default_fields();
  $fields_to_add = array(
    'field_collection_item' => array(
      'field_char_state_alt_wording' => array(
        'field_char_states'
      )
    ),
    'character_editor_character' => array(
      'field_char_alt_wording' => array(
        'controlled',
        'dna',
        'group',
        'numeric',
        'text',
        'computed'
      )
    )
  );
  foreach($fields_to_add as $entity => $bundles_and_field){
    foreach($bundles_and_field as $field => $bundles){
      foreach($bundles as $bundle){
        if(!field_info_field($field)){
          field_create_field($fields["{$entity}-{$bundle}-{$field}"]['field_config']);
        }
        if(!field_info_instance($entity, $field, $bundle)){
          field_create_instance($fields["{$entity}-{$bundle}-{$field}"]['field_instance']);
        }
      }
    }
  }
}