<?php


function dwca_export_views_menu() {
	
	$items = array();	

	$items['admin/config/system/views_dwca_export'] = array(
		'title' => 'DarwinCore Archive (DwC-A) export mapping module',
		'description' => t('Allow a use to select views for DwC-A and map terms to those views to create the metadata file meta.xml for the DwC-A archive.'),
		'page callback' => 'drupal_get_form',
		//'page arguments' => array('dwca_export_views_config_form'),
		'page arguments' => array('dwca_export_views_wizard'),
		'access arguments' => array('access DwC-A export settings'),
		'type' => MENU_NORMAL_ITEM,
	//'file' => 'dwca_export.admin.inc'
	);	
	
	return $items;
}

/**
* Form function, called by drupal_get_form()
* in dwca_export_menu().
*/
function dwca_export_views_config_form($form, &$form_state) {

	global $base_url;

	$form['dwca_export_info'] = array(
		'#markup' => '<p>Select the views to map to dwca terms.'
.'</p>'
	);

	$form['dwca_export_view_mapping'] = dwca_export_views_select_view_form();
	//$form['dwca_export_view_mapping'] = views_get_all_views();

	$form['#submit'][] = 'dwca_export_views_config_form_submit';
	//lorna remove we don't want the save configuration button
	//return system_settings_form($form);	
	return $form;
}
function dwca_export_views_select_view_form() {

	$allviews = views_get_all_views();

	$views = array(
	    		'#type' => 'fieldset',
	    		'#title' => t('DwC-A views'),
	//'#tree' => TRUE,
	);

	foreach($allviews as $view){
		// select only the views that are prefixed with dwca_export for the form
		if(substr($view->name, 0, 11) == 'dwca_export' && substr($view->name, 0, 23) != 'dwca_export_description'){
				
			$dwca_filename = $view->name;
			$views[$dwca_filename] = array(
			//$form[$dwca_filename] = array(
								  	'#type' => 'checkbox',
								  	'#title' => t($dwca_filename),
								  	'#description' => t('select view for ' . $dwca_filename),
				
			);
				
		}
	}

	$dwca_views_to_map = variable_get('VIEWS_MAP');

	/*foreach ($savedvariables as $key => $value) {

		echo "VALUE saved" . $value;
		echo $savedvariables[$key];
		print_r(t('key ') . $key . t('key ') . $value);
	}*/
	//$meta_string = file_get_contents('http://www.google.com/');
	//drupal_set_message(t('The meta - is ') . $meta_string);
	//print_r($meta_string);
	return $views;
}

function _dwca_export_views_steps() {
  return array(
      1 => array(
        'form' => 'dwca_export_views_config_form',
      ),
  2 => array(
          'form' => 'dwca_export_views_extension_form',
  ),
      3 => array(
        'form' => 'dwca_export_views_fields_form',
      ),
    );
}


//add this intermediate step which displays the view_name to extension mapping
/**
* Creates the form to map extension - rowType in dwca to a view
* TODO NEED TO ADD FUNCTIONALITY TO ADD A NEW EXTENSION
*
*/
function dwca_export_views_extension_form($form, &$form_state) {

	$form = array(
	    		'#type' => 'fieldset',
	    		'#title' => t('Extension to view mapping'),
	);


	//returns an array containing the terms for the core and each extension
	//TODO Do values exist in the database for the views we want to map
	//$view_ext_map = _dwca_export_views_meta_xml_map_new(); //store data in database for the first time
	
	$dwca_views_to_map = variable_get('VIEWS_MAP');
	
	$view_ext_map = _dwca_export_views_view_ext_map($dwca_views_to_map);// 26th Sept assuming already in database here so need to check first
	
	foreach ($dwca_views_to_map as $key => $view_name_to_map) {
		
			//print_r(t('key') . $key . t(' value') . $value);
		
		//if the key exists in view_ext_map get the known ext rowType else just print an empty field
		
		if (array_key_exists($view_name_to_map, $view_ext_map)) {
			//echo "The 'first' element is in the array";
			$ext = $view_ext_map[$view_name_to_map];
			
			$form[$view_name_to_map][$ext] = array(
			//$form[$view_name_to_map] = array(
			
							    '#type' => 'textfield',
							    '#title' => $view_name_to_map,
							    '#description' => t('Enter the URL for the rowType that maps to the view - ' . $view_name_to_map),
								'#default_value' => $ext,
								'#size' => 60,
			
			);
		} else {
			$form[$view_name_to_map][] = array(
			//$form[$view_name_to_map] = array(
				
					'#type' => 'textfield',
					'#title' => $view_name_to_map,
					'#description' => t('Enter the URL for the rowType that maps to the view - ' . $view_name_to_map),
					'#size' => 60,
				
			);
		}
					
		/*foreach ($view_ext_map as $view_name => $ext) {

			$form[$ext] = array(
			 
				    '#type' => 'textfield',
				    '#title' => $view_name,
				    '#description' => t('Enter the URL for the rowType that maps to the view - ' . $view_name),
					'#default_value' => $ext,
					'#size' => 80,

			);
		}*/
	}
	return $form;	
}

/**
* Creates the form to map fields in view to terms in dwca
*
*/
function dwca_export_views_fields_form($form, &$form_state) {
	
	$form = array(
	    		'#type' => 'fieldset',
	    		'#title' => t('Field to DwC-A term mapping'),
	);
	
	$form['dwca_export_info'] = array(
			'#markup' => '<p>Click on a view name below to expand the form to map field names to terms in DwC-A. </p>'
	.'</p>'
	);
	
	//TODO create an array containing the terms for the core and each extension
	//TODO Do values exist in the database for the views we want to map
	$views = _dwca_export_views_meta_xml_map_new(); //store data in database for the first time
	//$views = _dwca_export_views_meta_xml_map();

	$count = 0;
	$dwca_views_to_map = variable_get('VIEWS_MAP');
	
	//lorna TODO create a collapsable form for each view
	// A FORM OF FORMS
	foreach ($dwca_views_to_map as $key => $value) {
	
		//print_r(t('key') . $key . t(' value') . $value);
		
		$view = views_get_view($value);
		//////////////////print_r(t('key') . $key . t(' value') . $value);
		
		$collapsed = 1;
		if($count == 0) {
			$collapsed = 0;
		}
		$form[$value] = array(
			    		'#type' => 'fieldset',
			    		'#title' => $value,
						//'#size' => 30,
						//'#collapsible' => $collapsed,
						//'#collapsed' => $collapsed,
						//'#tree' => $collapsed,
						'#collapsible' => 1,
						'#collapsed' => 1,
						'#tree' => 1,
		
		);
		// check whether there is a view named with this value
		//if($view) {
			//$fields = $view->display_handler->get_field_labels();
			$fields =$view->display['default']->display_options['fields'];
			
			$field_index = 0;//// we should use the index attribute in the XML file to associate a particular value with a field name (field_key)
			$exclude_hidden_field = FALSE;
			
			foreach ($fields as $field_key => $field_label) {
				
				//display the field_keys as the names of each text box in this form
								
				foreach ($field_label as $key => $label) {				
					
					// if there is a key exclude and the value = TRUE exclude this field
					if($key == 'exclude' && $label == TRUE){
						$exclude_hidden_field = TRUE;
					}
					
				}
				
				if ($exclude_hidden_field == FALSE) {	
				$form[$value][$field_key] = array(
				    '#type' => 'textfield',
				    '#title' => $field_key,
				    '#description' => t('Enter the DwC-A term for the field - ' . $field_key),
					'#default_value' => $views[$value][$field_index],
					'#size' => 60,
					'#collapsible' => 1,
					'#collapsed' => 1,
					'#tree' => 1,
				);
				$field_index++;
				}

				$exclude_hidden_field = FALSE;
		}		
	}
	$count++;	
	return $form;
}

// TODO 4th Sept the parameter $field_term_map should contain the values from the database
function _dwca_export_views_meta_xml_update($field_term_map){
	
	//convert the field_term_map to an array of terms. The order of the terms corresponds to the 
	//order in the meta.xml. We don't need the keys (view field names)
	
	$term_array = array();
		
		foreach ($field_term_map as $key => $value) {
			
			$term_array[$key] = array();
			
			//drupal_set_message(t(' THE key... ') . $key);
			//if the value is an array with key names dwca_export_
			if ( (array) $value === $value ) {
				
				foreach ($value as $key2 => $value2) {
					
					/////////drupal_set_message(t(' THE key2... ') . $key2);
					//$term_array[] = $key;
					//////////////////////////////////////////////$term_array[$key] = array();
					if (substr($key, 0, 11) == 'dwca_export') {
						
						$term_array[$key][] = $value2;
					}
			}
		}		
		
}
	
	//check if the array size is the same as the number of fields in the meta.xml for either the
	//core or the particular extension
	
	//if the view has more fields than the default meta.xml we can add a node to the meta.xml
	//TODO: Need to work this out.
	
	//if the view has less fields we could either leave them blank e.g. <field index="21" term=""/>
	//or simply remove them

	$xml_file = drupal_get_path('module', 'dwca_export') . '/static/meta.xml';
	$meta_string = simplexml_load_file($xml_file);	
	
	$meta_string->core->files->location[0] = 'classification.txt';
	
	$core_string = $meta_string->core->files->location[0];
	$classification_view_name = "dwca_export_" . substr($core_string, 0, -4);
	
	//the first position in the dwca is always the id and this doesn't point to a term so use the empty string
	$views[$classification_view_name][0] = '';
	
	//set the core node of the meta.xml with dwca_export_classifcation values from the form
	//currently we're relying on the order of fields in the view to correspond to the order of fields in the meta.xml
	
	//in the meta.xml id index="0" fields start at index 1
	$index = 1;
	
	foreach($meta_string->core->field as $field)
	{
		$term = (string)$field[@term];
		
		if (isset($term_array['dwca_export_classification'][$index])) {
			$field[@term] = $term_array['dwca_export_classification'][$index];
		}
		
		$index++;
		//$views[$classification_view_name][] = $term;	
	}
	
	
	
	//only modify the extensions which have been modified in the form	
	foreach($meta_string->extension as $extension)
	{
		//echo $extension->files->location[0] . "\n";
		$extension_string = $extension->files->location[0] . "\n";	
		$extension_view_name = "dwca_export_" . substr($extension_string, 0, -5);
		//echo "The ext view name is:" . $classification_view_name . "\n";
		//drupal_set_message(t(' THE ext view name is ') . $extension_view_name);
				
		if ( array_key_exists($extension_view_name, $term_array)) {
		$views[$extension_view_name][0] = '';
		
		$index2 = 1;
	
		foreach($extension->field as $field2)
			{
				$term = (string)$field2[@term];
				//$views[$extension_view_name][] = $term;
				if (isset($term_array[(string)$extension_view_name][$index2])) {
					$field2[@term] = $term_array[(string)$extension_view_name][$index2];
				}
				$index2++;
			}
		}
	}

	// Saving the whole modified XML to a new filename
	$meta_string->asXml('updated_meta.xml');
	//$meta_string->asXml($xml_file);
	
	//drupal_set_message(t('VALUES: <pre>@result</pre>', array('@num' => 1, '@result' => print_r($term_array, TRUE))));
}

//_dwca_export_views_insert
function hook_field_insert($entity_type, $entity, $field, $instance, $langcode, &$items) {
	if (variable_get('taxonomy_maintain_index_table', TRUE) && $field['storage']['type'] == 'field_sql_storage' && $entity_type == 'node' && $entity->status) {
		$query = db_insert('taxonomy_index')->fields(array('nid', 'tid', 'sticky', 'created'));
		foreach ($items as $item) {
			$query->values(array(
        'nid' => $entity->nid, 
        'tid' => $item['tid'], 
        'sticky' => $entity->sticky, 
        'created' => $entity->created,
			));
		}
		$query->execute();
	}
}



//save the extension to view mapping if it does not already exist
//this method only works for one view linked to a single extension or rowType
//need to modify this so that one view can map to multiple extensions
function dwca_export_views_save_view_ext($items) {

	$query = db_insert('dwca_extension_view_mapping')->fields(array('extension', 'view_name'));
	
	foreach ($items as $key => $value) {		
			
		
		//$results = db_query("SELECT * FROM {dwca_extension_view_mapping} WHERE extension = :extn AND view_name = :view", array(':extn' => $key, ':view' => $value))->fetchAll();
		$evid = _dwca_export_views_get_extension_view_mapping_id($value, $key);
		
		
		if (count($evid) < 1 || $evid == '') {		
			
			
			$query->values(array(
	        	'extension' => $value, 
	        	'view_name' => $key, 
			));
			$query->execute();
		}		
	}	
}


// fri 14th call this from above method
// and when we're checking if the values already exist in database
//then create the map from the database
function _dwca_export_views_get_extension_view_mapping_id($extension, $view_name) {
	
	return db_query("SELECT evid FROM {dwca_extension_view_mapping} WHERE extension = :extn AND view_name = :view", array(':extn' => $extension, ':view' => $view_name))->fetchField();
}

function _dwca_export_views_get_rowType_extension_for_view($view_name) {

	return db_query("SELECT extension FROM {dwca_extension_view_mapping} WHERE view_name = :view", array(':view' => $view_name))->fetchCol();
}

function dwca_export_views_save_field_mapping($extension, $rowType, $view_name) {
//function dwca_export_views_save_field_mapping($xmlfield, $rowType, $view_name) {
	
	//If there are hidden fields then the field index in the XML file does not correpond to the column index in the view so we need to account for this
	$hidden_field_count = 0;
	
	$evid = _dwca_export_views_get_extension_view_mapping_id($rowType, $view_name); 
	
	foreach($extension->field as $xmlfield)
	{
	
	$term = (string)$xmlfield[@term];
	$field_index = (string)$xmlfield[@index];//// we should use the index attribute in the XML file to associate a particular term with a field name (field_key)
	$view = views_get_view($view_name);
	
	// the column index in the view correspondS to the index in the xml file so we can match it up with the term in this way
	$fields =$view->display['default']->display_options['fields'];

	//iterate through fields in a view and associate each with a term from the meta xml file
	//associate the field at correct index with the term from the meta xml file
	//field_name e.g. uuid term = http://purl.org...
	$position = 0;
	
	if ( (array) $fields === $fields ) {
		foreach ($fields as $field_key => $field_label) {
			
		$exclude_hidden_field = FALSE;
		
		//TODO:Can't we just select the field at the appropriate index instead of looping
		if ($field_index == ($position - $hidden_field_count) ) {
		
				
			//the field_keys are the names of each field in the view
			foreach ($field_label as $key => $label) {
					
				// if there is a key exclude and the value = TRUE exclude this field
				if($key == 'exclude' && $label == TRUE){
					$exclude_hidden_field = TRUE;
					$hidden_field_count++;
				}
			}
		
			if ($exclude_hidden_field == FALSE) {

							
				$query = db_insert('dwca_term_field_mapping')->fields(array('term', 'field_name', 'evid'));
				
					//select the evid from dwca_extension_view_mapping					
					//if (count($evid) > 0) {
						//if (count($evid) != 0) {
							if ( (integer) $evid === $evid ) {
						
						
						$results = db_query("SELECT * FROM {dwca_term_field_mapping} WHERE evid = :evid AND term = :term AND field_name = :fn", array(':evid' => $evid, ':term' => $term, ':fn' => $field_key))->fetchAll();
						
						if (count($results) < 1) {
							
						
							$query->values(array(
						        	'term' => $term, 
						        	'field_name' => $field_key,
									'evid' => $evid,
							));
							$query->execute();
						}
					}
			}	
		}
		$position++;
		}
	}
	}	
}


// a user may want to add a new extension  or different mappings to existing view (as in the case of EOL)
// the rowType attribute specfies a new extension
//this method now stores the data from the meta xml into the database
function _dwca_export_views_meta_xml_map_new(){

	//TODO: Should we store the map in the database so we don't need to keep reading in the XML file?
	// 4th Sept if all the database fields are empty shall we read in file?

	//1. Query database to see if there are values existing for the rowTypes in the meta.xml
	//2. If values exists populate map
	//3. If values don't exist read in XML file
	
	// the first time the module is installed the database tables should be populated from the meta.xml
	$views = array();///////////remove this ////////////
	//$view_ext_map = array();
	
	//create a 2D array so that each extension or view name points to an array of terms
	$meta_string = simplexml_load_file(drupal_get_path('module', 'dwca_export') . '/static/meta.xml');
	
	$core_string = $meta_string->core->files->location[0];
	$rowType = (string)$meta_string->core[@rowType];
	
	$classification_view_name = "dwca_export_" . substr($core_string, 0, -4);	
	
	//$view_ext_map = array( $rowType => $classification_view_name );
	$view_ext_map = array( $classification_view_name => $rowType );
	dwca_export_views_save_view_ext($view_ext_map);
	
	//the first postion in the dwca is always the id and this doesn't point to a term so use the empty string
	$views[$classification_view_name][0] = '';///////remove this
	
	foreach($meta_string->core->field as $xmlfield)
	{
		$term = (string)$xmlfield[@term]; ///////////remove this ///////////////
		$views[$classification_view_name][] = $term; //////remove this//////  ///////////////////////////get from database	
	}
	
	dwca_export_views_save_field_mapping($meta_string->core, $rowType, $classification_view_name);
	
	foreach($meta_string->extension as $extension)
	{
		$rowType = (string)$extension[@rowType];	
		$extension_string = $extension->files->location[0] . "\n";	
		$extension_view_name = "dwca_export_" . substr($extension_string, 0, -5);
		//echo "The ext view name is:" . $extension_view_name . "\n";
		$view_ext_map = array( $extension_view_name => $rowType );
		dwca_export_views_save_view_ext($view_ext_map);
	
		$views[$extension_view_name][0] = '';//////////remove this
	
		// call method on each field
		foreach($extension->field as $field)
		{
			$term = (string)$field[@term];///////////remove this ///////////////
			$views[$extension_view_name][] = $term;//////remove this//////  ///////////////////////////get from database
		}
		dwca_export_views_save_field_mapping($extension, $rowType, $extension_view_name);
	}
	
	$dwca_views_to_map = variable_get('VIEWS_MAP');	
	foreach ($dwca_views_to_map as $key => $dwca_view_name) {
		
		
		//select the rowType from the database
		$saved_extensions = _dwca_export_views_get_rowType_extension_for_view($dwca_view_name);
		
		foreach($saved_extensions as $key => $value) {
			
			//$view_ext_map[$value] = $dwca_view_name; //Do we want this map the other way around
			$view_ext_map[$dwca_view_name] = $value; //yes - also need multiple rowTypes for 1 view
		}
		
		
		// else ask the user to provide a rowType for this new extension (user may want to create a new mapping anyway e.g. more than one mapping for reference)
	}

 //14th sept - instead of returning $views which map the view name to the terms in the meta xml
 //we are now going to return the extension - i.e. rowType view mapping

//////////return $view_ext_map;
	return $views;
}

function _dwca_export_views_view_ext_map($dwca_views_to_map){
	
	$view_ext_map = array();
	//$dwca_views_to_map = variable_get('VIEWS_MAP');	
	foreach ($dwca_views_to_map as $key => $dwca_view_name) {
		
		//select the rowType from the database
		$saved_extensions = _dwca_export_views_get_rowType_extension_for_view($dwca_view_name);
		
		foreach($saved_extensions as $key => $value) {
			
			//$view_ext_map[$value] = $dwca_view_name; //Do we want this map the other way around
			$view_ext_map[$dwca_view_name] = $value; //yes - also need multiple rowTypes for 1 view
		}
		// else ask the user to provide a rowType for this new extension (user may want to create a new mapping anyway e.g. more than one mapping for reference view)
		// for now if there are no saved extensions in the dwca_extensdion_view_mapping table in database then add the empty field to the map
		//else {
		//drupal_set_message(t('SAVED extensions ') . $saved_extensions);
		//}
	}
	return $view_ext_map;
}


//TODO: This method now populates the database tables from the default meta xml.
function _dwca_export_views_meta_xml_map(){
	
	//TODO: Should we store the map in the database so we don't need to keep reading in the XML file?
	// 4th Sept if all the database fields are empty shall we need in file?
	
	//1. Query database
	//2. If values exists populate map
	//3. If values don't exist read in XML file
	//4. populate database
	//5. goto 1
	
	//(1 and 2 create map by reading values from DB)
	//(3 AND 4 as below except we need to write to db)
	
	//static $file_map;
	//if(!isset($file_map)){
		//$file_map = variable_get(FILE_MAP);
	//}
	$views = array();
	//$view_ext_map = array(); // to add to dwca_extension_view_mapping table

//create a 2D array so that each extension or view name points to an array of terms
	$meta_string = simplexml_load_file(drupal_get_path('module', 'dwca_export') . '/static/meta.xml');
	//simplexml_load_string()
	
	$core_string = $meta_string->core->files->location[0];
	$rowType = (string)$meta_string->core[@rowType];
	
	$classification_view_name = "dwca_export_" . substr($core_string, 0, -4);
	
	//$view_ext_map[$rowType] = $classification_view_name;

	
	$view_ext_map = array( $rowType => $classification_view_name );
	dwca_export_views_save_view_ext($view_ext_map);
	
	/*$a = array(); // array of columns
	for($c=0; $c<5; $c++){
		$a[$c] = array(); // array of cells for column $c
		for($r=0; $r<3; $r++){
			$a[$c][$r] = rand();
		}
	}*/
	

	//the first postion in the dwca is always the id and this doesn't point to a term so use the empty string
	$views[$classification_view_name][0] = '';
	
	//get the classification view
	$view = views_get_view($classification_view_name); //do we use view anywhere else?
	
	//extract this method out as we need to do it for the extensions as well as the core
	//TODO: In new method pass in the field and index
	//instead of iterating through each field go directly to the (integer)$field[@index] corresponding to the position of the field in the view
	foreach($meta_string->core->field as $xmlfield)
	{	
		$term = (string)$xmlfield[@term]; ///////////remove this ///////////////
		$views[$classification_view_name][] = $term; //////remove this//////  ///////////////////////////get from database
		
	}
	
	/////  pass in the meta_string as we need to select which we exclude within the method
	dwca_export_views_save_field_mapping($meta_string->core, $rowType, $classification_view_name);

	foreach($meta_string->extension as $extension)
	{
		//echo $extension->files->location[0] . "\n";
		$rowType = (string)$extension[@rowType];
		
		
		$extension_string = $extension->files->location[0] . "\n";
		
		$extension_view_name = "dwca_export_" . substr($extension_string, 0, -5);
		//echo "The ext view name is:" . $extension_view_name . "\n";
		$view_ext_map = array( $rowType => $extension_view_name);
		dwca_export_views_save_view_ext($view_ext_map);
		
		$views[$extension_view_name][0] = '';
		
		
		// call method on each field
		foreach($extension->field as $field)
		{
			$term = (string)$field[@term];
			$views[$extension_view_name][] = $term;
		}
		dwca_export_views_save_field_mapping($extension, $rowType, $extension_view_name);
	}

	foreach($meta_string->children() as $child)
	{
		// core or extension
		//foreach($child->children() as $child2)
		//{
		// core or extension
		//echo $child2->getName() . ": " . $child2 . "<br />";
		//}


	}
	//$result = $meta_string->xpath("//archive/core/files/location");

	return $views;
}

function dwca_export_views_wizard($form, &$form_state) {
	
		// Initialize a description of the steps for the wizard.
		if (empty($form_state['step'])) {
			$form_state['step'] = 1;
	
			// This array contains the function to be called at each step to get the
			// relevant form elements. It will also store state information for each
			// step.
			$form_state['step_information'] = _dwca_export_views_steps();
		}
		$step = &$form_state['step'];
		drupal_set_title(t('DwC-A to views mapping: Step @step', array('@step' => $step)));
		//lorna
		//drupal_set_message(t('Extensible Wizard: Step @step', array('@step' => $step)));
	
		// Call the function named in $form_state['step_information'] to get the
		// form elements to display for this step.
		$form = $form_state['step_information'][$step]['form']($form, $form_state);
	
		// Show the 'previous' button if appropriate. Note that #submit is set to
		// a special submit handler, and that we use #limit_validation_errors to
		// skip all complaints about validation when using the back button. The
		// values entered will be discarded, but they will not be validated, which
		// would be annoying in a "back" button.
		if ($step > 1) {
			$form['prev'] = array(
	      '#type' => 'submit',
	      '#value' => t('Previous'),
	      '#name' => 'prev',
	      '#submit' => array('dwca_export_views_wizard_previous_submit'),
	      '#limit_validation_errors' => array(),
			);
		}
	
		// Show the Next button only if there are more steps defined.
		if ($step < count($form_state['step_information'])) {
			// The Next button should be included on every step
			$form['next'] = array(
	      '#type' => 'submit',
	      '#value' => t('Next'),
	      '#name' => 'next',
	      '#submit' => array('dwca_export_views_wizard_next_submit'),
			);
		}
		else {
			// Just in case there are no more steps, we use the default submit handler
			// of the form wizard. Call this button Finish, Submit, or whatever you
			// want to show. When this button is clicked, the
			// dwca_export_views_wizard_submit handler will be called.
			$form['finish'] = array(
	      '#type' => 'submit',
	      '#value' => t('Finish'),
			);
		}
	
		// Include each validation function defined for the different steps.
		if (function_exists($form_state['step_information'][$step]['form'] . '_validate')) {
			$form['next']['#validate'] = array($form_state['step_information'][$step]['form'] . '_validate');
		}
	
		return $form;
	}
function dwca_export_views_wizard_next_submit($form, &$form_state) {
	$current_step = &$form_state['step'];
	$form_state['step_information'][$current_step]['stored_values'] = $form_state['values'];

	if ($current_step < count($form_state['step_information'])) {
		
		// lorna save the values for the first step
		if ($current_step == 1) {
			_dwca_export_views_step1_submit($form, &$form_state);
		}
		//save the values for the second submit
		if ($current_step == 2) {
			_dwca_export_views_step2_submit($form, &$form_state);
		}
		$current_step++;
		if (!empty($form_state['step_information'][$current_step]['stored_values'])) {
			$form_state['values'] = $form_state['step_information'][$current_step]['stored_values'];
			
			
		}
		else {
			$form_state['values'] = array();
		}
		$form_state['rebuild'] = TRUE;  // Force rebuild with next step.
		return;
	}
}
function dwca_export_views_wizard_previous_submit($form, &$form_state) {
	$current_step = &$form_state['step'];
	$form_state['step_information'][$current_step]['stored_values'] = $form_state['values'];
	if ($current_step > 1) {
		$current_step--;
		$form_state['values'] = $form_state['step_information'][$current_step]['stored_values'];
	}
	$form_state['rebuild'] = TRUE;
}


function _dwca_export_views_step1_submit($form, &$form_state) {
	//function dwca_export_views_wizard_submit($form, &$form_state) {

	$variables = $form_state['input'];
	$save_variables = '';
	$views_map = variable_get('VIEWS_MAP');
	$views_to_map = array();	

	foreach ($variables as $key => $value) {

		if(substr($key, 0, 11) == 'dwca_export'){
			
			if ($value == 1) {
				$views_to_map[] = $key;
				//drupal_set_message(t('MAPPING VALUE ') . $value);
			}
					
		}
	}

	//save a map of the views the user want to change in the database
	variable_del('VIEWS_MAP');
	variable_set('VIEWS_MAP', $views_to_map);
	
	$dwca_views_to_map = variable_get('VIEWS_MAP');
	
}

//save the extension to view mapping in the table dwca_extension_view_mapping

//fs KEYdwca_export_distribution
//fs values Array
//fs KEYdwca_export_eol_agents
//fs values Array
//fs KEYdwca_export_image
//fs values Array
function _dwca_export_views_step2_submit($form, &$form_state) {
	$variables = $form_state['values'];
	$view_ext_map = array();
	//$form_state['input'];
	drupal_set_message(t('saving the ext view mapping ') . $variables);
	//dwca_export_views_save_view_ext($variables);

	foreach ($form as $key => $values) {

		//drupal_set_message(t('KEY') . $key);//view_name

		//IF the key is a dwca_view name then get the associated rowType which has been entered in the form
		if ( (array) $values === $values ) {
			
			foreach ($values as $k => $v) {
				
				if (substr($key, 0, 11) == 'dwca_export') {
					//drupal_set_message(t('KEY') . $key);//view_name
				//drupal_set_message(t('MAPKEY ') . $k);//extension
				//drupal_set_message(t('MAPVAL ') . $v);
				
				//foreach ($variables as $key2 => $value2) {
				
					//if($key2 == $k){

					if ($variables[$k]) {
						drupal_set_message(t('setting the key to ') . $key . t('and value to ') . $variables[$k]);//EXT
						//////////drupal_set_message(t('MAPPING VALUE ') . $value2);//EXTENSION ENTERED IN FORM FIELD
						//drupal_set_message(t('MAPPING key ') . $key2);
						
						//$view_ext_map = array( $key => $variables[$k]);
						$view_ext_map[$key] = $variables[$k];
						//$view_ext_map = array( $key => $value2 );
					//}
					}
					
			}
			}
		}

	}

	dwca_export_views_save_view_ext($view_ext_map);///2ND OCT - CORRECT MAP IS GOING IN BUT WHY NOT SAVED?
	//fs KEYdwca_export_distribution
	//fs values Array
	//MAPKEY http://rs.gbif.org/terms/1.0/Distribution

	//foreach ($variables as $key => $value) {

	//}
}


// And now comes the magic of the wizard, the function that should handle all the
// inputs from the user on each different step.
/**
 * Wizard form submit handler.
 * - Saves away $form_state['values']
 * - Process all the form values.
 *
 * This demonstration handler just do a drupal_set_message() with the information
 * collected on each different step of the wizard.
 *
 * @param $form
 * @param $form_state
 *
 * @ingroup form_example
 */
function dwca_export_views_wizard_submit($form, &$form_state) {
	$current_step = &$form_state['step'];
	$form_state['step_information'][$current_step]['stored_values'] = $form_state['values'];

	// In this case we've completed the final page of the wizard, so process the
	// submitted information.
	foreach ($form_state['step_information'] as $index => $value) {
		// Remove FAPI fields included in the values (form_token, form_id and form_build_id
		// This is not required, you may access the values using $value['stored_values']
		// but I'm removing them to make a more clear representation of the collected
		// information as the complete array will be passed through drupal_set_message().
		unset($value['stored_values']['form_id']);
		unset($value['stored_values']['form_build_id']);
		unset($value['stored_values']['form_token']);
		
		
		//drupal_set_message(t('INFO COLLECTED @result'), array('@result' => print_r($value['stored_values'], TRUE)));
		

		// Now show all the values.
		if ($index == 2) {
			_dwca_export_views_meta_xml_update($value['stored_values']);
		//drupal_set_message(t('Step @num collected the following values: <pre>@result</pre>', array('@num' => $index, '@result' => print_r($value['stored_values'], TRUE))));
	}
}
}


